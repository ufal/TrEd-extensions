# -*- cperl -*-

# Makras common to other TrEd extensions for annotation of non-dependency relations in PDT
# Jiri Mirovsky, Petr Pajas, Zdenek Zabokrtsky

{
package NonDepRel_Common;
BEGIN { import PML_T; }

use strict;
use warnings;
no warnings qw(redefine);

use vars qw($this $root $grp);

my $coreferential_chain_max_size = 100; # just a simple way to avoid circles

sub macros_reloaded_hook {
  # it exists here to avoid warnings when called from macros_reloaded_hook in discourse.mac
  return;
}


my %ha_pdtb3_sense_2_short = ('Comparison.Concession.Arg1-as-denier' => 'Conc.Arg1-as-denier',
                              'Comparison.Concession.Arg2-as-denier' => 'Conc.Arg2-as-denier',
                              'Comparison.Concession+SpeechAct.Arg2-as-denier+SpeechAct' => 'Conc+SA.Arg2-as-denier+SA',
                              'Comparison.Contrast' => 'Contrast',
                              'Comparison.Similarity' => 'Similarity',
                              'Contingency.Cause.Reason' => 'Cause.Reason',
                              'Contingency.Cause.Result' => 'Cause.Result',
                              'Contingency.Cause+Belief.Reason+Belief' => 'Cause+B.Reason+B',
                              'Contingency.Cause+Belief.Result+Belief' => 'Cause+B.Result+B',
                              'Contingency.Cause+SpeechAct.Reason+SpeechAct' => 'Cause+SA.Reason+SA',
                              'Contingency.Cause+SpeechAct.Result+SpeechAct' => 'Cause+SA.Result+SA',
                              'Contingency.Negative-cause.NegResult' => 'Neg-cause.NegResult',
                              'Contingency.Condition.Arg1-as-cond' => 'Cond.Arg1-as-cond',
                              'Contingency.Condition.Arg2-as-cond' => 'Cond.Arg2-as-cond',
                              'Contingency.Condition+SpeechAct' => 'Cond+SA',
                              'Contingency.Negative-condition.Arg1-as-negCond' => 'Neg-cond.Arg1-as-negCond',
                              'Contingency.Negative-condition.Arg2-as-negCond' => 'Neg-cond.Arg2-as-negCond',
                              'Contingency.Negative-condition+SpeechAct' => 'Neg-cond+SA',
                              'Contingency.Purpose.Arg1-as-goal' => 'Purp.Arg1-as-goal',
                              'Contingency.Purpose.Arg2-as-goal' => 'Purp.Arg2-as-goal',
                              'Expansion.Conjunction' => 'Conjunction',
                              'Expansion.Disjunction' => 'Disjunction',
                              'Expansion.Equivalence' => 'Equivalence',
                              'Expansion.Exception.Arg1-as-excpt' => 'Excpt.Arg1-as-excpt',
                              'Expansion.Exception.Arg2-as-excpt' => 'Excpt.Arg2-as-excpt',
                              'Expansion.Instantiation.Arg1-as-instance' => 'Inst.Arg1-as-instance',
                              'Expansion.Instantiation.Arg2-as-instance' => 'Inst.Arg2-as-instance',
                              'Expansion.Level-of-detail.Arg1-as-detail' => 'Lvl-of-det.Arg1-as-detail',
                              'Expansion.Level-of-detail.Arg2-as-detail' => 'Lvl-of-det.Arg2-as-detail',
                              'Expansion.Manner.Arg1-as-manner' => 'Manner.Arg1-as-manner',
                              'Expansion.Manner.Arg2-as-manner' => 'Manner.Arg2-as-manner',
                              'Expansion.Substitution.Arg1-as-subst' => 'Subst.Arg1-as-subst',
                              'Expansion.Substitution.Arg2-as-subst' => 'Subst.Arg2-as-subst',
                              'Temporal.Asynchronous.Precedence' => 'Asynch.Precedence',
                              'Temporal.Asynchronous.Succession' => 'Asynch.Succession',
                              'Temporal.Synchronous' => 'Synchronous');

sub set_color_bridging {
  my ($color) = @_;
  FileUserData('color_bridging',$color);
  # print STDERR "Setting color bridging: " . FileUserData('color_bridging') . "\n";
  CustomColor('arrow_bridging',$color);
}
sub get_color_bridging {
  # print STDERR "Getting color bridging: " . FileUserData('color_bridging') . "\n";
  # return FileUserData('color_bridging') or '#00ccff'; # this did not work for PCEDT-cz (wsj-anot extension)
  return '#00ccff';
}

sub set_color_coref_text {
  my ($color) = @_;
  FileUserData('color_coref_text',$color);
  CustomColor('arrow_textual',$color);
}
sub get_color_coref_text {
  return FileUserData('color_coref_text') || CustomColor('arrow_textual') || 'darkblue';
  # return 'darkblue';
}

sub set_color_coref_text_line { # the color in the sentence of the words connected with textual coreference
  my ($color) = @_;
  FileUserData('color_coref_text_line',$color);
}
sub get_color_coref_text_line {
  my $color = FileUserData('color_coref_text_line');
  if ($color && length($color)>1) { return $color; }
  $color = FileUserData('color_coref_text'); # if not set, use the color of the arrows
  if ($color && length($color)>1) { return $color; }
  return CustomColor('arrow_textual'); # if not set, use the color of the arrows
}

sub set_color_coref_gram {
  my ($color) = @_;
  FileUserData('color_coref_gram',$color);
  CustomColor('arrow_grammatical',$color);
}
sub get_color_coref_gram {
  return FileUserData('color_coref_gram') || CustomColor('arrow_grammatical');
}

sub set_color_discourse {
  my ($color) = @_;
  FileUserData('color_discourse',$color);
  CustomColor('arrow_discourse',$color);
}
sub get_color_discourse {
  return FileUserData('color_discourse') || '#ff710c';
}

sub set_color_discourse_pdtb3 {
  my ($color) = @_;
  FileUserData('color_discourse_pdtb3',$color);
  CustomColor('arrow_discourse_pdtb3',$color);
}
sub get_color_discourse_pdtb3 {
  return FileUserData('color_discourse_pdtb3') || '#ff30dd';
}

sub get_color_connective_in_text {
  return '#20d000';
}

sub set_display_discourse_arrows {
  my ($display) = @_;
  FileUserData('display_discourse_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_discourse()) {
      precompute_file_related_resources({'discourse' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_discourse();
  }
}
sub get_display_discourse_arrows {
  return FileUserData('display_discourse_arrows');
}
sub switch_display_discourse_arrows {
  my $display = 1 - FileUserData('display_discourse_arrows');
  FileUserData('display_discourse_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_discourse()) {
      precompute_file_related_resources({'discourse' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_discourse();
  }
}

sub set_display_coref_gram_arrows {
  my ($display) = @_;
  FileUserData('display_coref_gram_arrows',$display);
}
sub get_display_coref_gram_arrows {
  return FileUserData('display_coref_gram_arrows');
}
sub switch_display_coref_gram_arrows {
  my $display = 1 - FileUserData('display_coref_gram_arrows');
  FileUserData('display_coref_gram_arrows',$display);
}

sub set_display_coref_text_arrows {
  my ($display) = @_;
  FileUserData('display_coref_text_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_coref_text()) {
      precompute_file_related_resources({'coref_text' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_coref_text();
  }
}
sub get_display_coref_text_arrows {
  return FileUserData('display_coref_text_arrows');
}
sub switch_display_coref_text_arrows {
  my $display = 1 - FileUserData('display_coref_text_arrows');
  FileUserData('display_coref_text_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_coref_text()) {
      precompute_file_related_resources({'coref_text' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_coref_text();
  }
}

sub set_display_bridging_arrows {
  my ($display) = @_;
  FileUserData('display_bridging_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_bridging()) {
      precompute_file_related_resources({'bridging' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_bridging();
  }
}
sub get_display_bridging_arrows {
  return FileUserData('display_bridging_arrows');
}
sub switch_display_bridging_arrows {
  my $display = 1 - FileUserData('display_bridging_arrows');
  FileUserData('display_bridging_arrows',$display);
  if ($display) {
    if (!is_precomputed_file_related_resources_bridging()) {
      precompute_file_related_resources({'bridging' => 1}); # not all resources need to be precomputed now but this is easier than trying to separate them
    }
  }
  else {
    free_file_related_resources_bridging();
  }
}

sub set_display_complement_arrows {
  my ($display) = @_;
  FileUserData('display_complement_arrows',$display);
}
sub get_display_complement_arrows {
  return FileUserData('display_complement_arrows');
}
sub switch_display_complement_arrows {
  my $display = 1 - FileUserData('display_complement_arrows');
  FileUserData('display_complement_arrows',$display);
}

sub set_underline_same_t_lemmas {
  my ($underline) = @_;
  FileUserData('underline_same_t_lemmas',$underline);
}
sub get_underline_same_t_lemmas {
  return FileUserData('underline_same_t_lemmas');
}
sub switch_underline_same_t_lemmas {
  my $underline = 1 - FileUserData('underline_same_t_lemmas');
  FileUserData('underline_same_t_lemmas',$underline);
}



sub set_highlight_one_bridging_source {
  my ($highlight) = @_;
  FileUserData('highlight_one_bridging_source',$highlight);
}
sub get_highlight_one_bridging_source {
  return FileUserData('highlight_one_bridging_source');
}
sub switch_highlight_one_bridging_source {
  my $highlight = 1 - FileUserData('highlight_one_bridging_source');
  FileUserData('highlight_one_bridging_source',$highlight);
}


# set it to an empty string to not separate the paragraphs
sub set_paragraph_separator {
  my ($separator) = @_;
  FileUserData('paragraph_separator', $separator);
}
sub get_paragraph_separator {
  return FileUserData('paragraph_separator');
}

sub set_show_bridging_arrow_type {
  my ($show) = @_;
  # print STDERR "set_show_bridging_arrow_type: $show\n";
  FileUserData('show_bridging_arrow_type',$show);
}
sub get_show_bridging_arrow_type {
  return FileUserData('show_bridging_arrow_type');
}

sub get_show_bridging_arrow_comment {
  return 1;
}

sub set_show_coref_text_arrow_type {
  my ($show) = @_;
  FileUserData('show_coref_text_arrow_type',$show);
}
sub get_show_coref_text_arrow_type {
  return FileUserData('show_coref_text_arrow_type');
}

sub get_show_coref_text_arrow_comment {
  return 1;
}

sub set_show_discourse_arrow_type {
  my ($show) = @_;
  FileUserData('show_discourse_arrow_type',$show);
}
sub get_show_discourse_arrow_type {
  return FileUserData('show_discourse_arrow_type');
}

sub set_show_discourse_arrow_comment {
  my ($show) = @_;
  FileUserData('show_discourse_arrow_comment',$show);
}
sub get_show_discourse_arrow_comment {
  return FileUserData('show_discourse_arrow_comment');
}

sub set_show_discourse_arrow_connector {
  my ($show) = @_;
  FileUserData('show_discourse_arrow_connector',$show);
}
sub get_show_discourse_arrow_connector {
  return FileUserData('show_discourse_arrow_connector');
}

sub set_show_discourse_arrow_range {
  my ($show) = @_;
  FileUserData('show_discourse_arrow_range',$show);
}
sub get_show_discourse_arrow_range {
  return FileUserData('show_discourse_arrow_range');
}

sub set_show_discourse_node_comment {
  my ($show) = @_;
  FileUserData('show_discourse_node_comment',$show);
}
sub get_show_discourse_node_comment {
  return FileUserData('show_discourse_node_comment');
}

=item set_mode_remember_nodes($mode)

  Sets the mode of remembering nodes.
  Possible values:
  SINGLE - only one node can be remembered at a time; uses PML_T_Edit->RememberNode
  MULTI - several nodes can be remembered at the same time; uses its own method

=cut

sub set_mode_remember_nodes {
  my ($mode) = @_;
  if (($mode eq 'SINGLE') or ($mode eq 'MULTI')) {
    FileUserData('mode_remember_nodes',$mode);
  }
}

sub get_mode_remember_nodes {
  return FileUserData('mode_remember_nodes');
}

=item set_enable_remember_words($enable)

  Enables/disables the possibility of remembering individual words by clicking in the sentences.
  Possible values:
  true - individual words (a-nodes) can be remembered
  false - the feature is disabled

=cut

sub set_enable_remember_words {
  my ($enable) = @_;
  if ($enable) {
    FileUserData('enable_remember_words',$enable);
  }
  else {
    FileUserData('enable_remember_words',undef);
  }
}

sub is_enabled_remember_words {
  return FileUserData('enable_remember_words');
}


=item select_bridging_and_coref_text_source

  Let the user choose bridging and coref_text arrows from which source to display; source '0' stands for 'all sources'.

=cut

sub select_bridging_and_coref_text_source {
  my @selection = (FileUserData('selected_source_bridging_and_coref_text'));
  my $rh_sources = FileUserData('list_of_bridging_and_coref_text_sources');
  my @sources = keys(%$rh_sources);
  push(@sources, 0);
  ListQuery("Select a source of bridging and coref-text arrows:",'browse',\@sources,\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_source = $selection[0];
  print "Selected bridging and coref-text source: $selected_source\n";
  FileUserData('selected_source_bridging_and_coref_text',$selected_source);
}

sub get_selected_bridging_and_coref_text_source {
  return FileUserData('selected_source_bridging_and_coref_text');
}

sub is_selected_bridging_and_coref_text_source {
  my ($source) = @_;
  my $selected_source = FileUserData('selected_source_bridging_and_coref_text');
  if (!defined($selected_source) or $selected_source eq 0) {
    return 1;
  }
  if (!defined($source)) {
    return 0;
  }
  if ($source eq $selected_source) {
    return 1;
  }
  return 0;
}

=item select_discourse_source

  Let the user choose discourse arrows from which source to display; source '0' stands for 'all sources'.

=cut

sub select_discourse_source {
  my @selection = (FileUserData('selected_source_discourse'));
  my $rh_sources = FileUserData('list_of_discourse_sources');
  my @sources = keys(%$rh_sources);
  push(@sources, 0);
  ListQuery("Select a source of discourse arrows:",'browse',\@sources,\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_source = $selection[0];
  print "Selected discourse source: $selected_source\n";
  FileUserData('selected_source_discourse',$selected_source);
}

sub get_selected_discourse_source {
  return FileUserData('selected_source_discourse');
}

sub is_selected_discourse_source {
  my ($source) = @_;
  my $selected_source = FileUserData('selected_source_discourse');
  if (!defined($selected_source) or $selected_source eq 0) {
    return 1;
  }
  if (!defined($source)) {
    return 0;
  }
  if ($source eq $selected_source) {
    return 1;
  }
  return 0;
}

sub get_source_display_text {
  my ($source) = @_;
  if (!defined($source) or $source eq 0) {
    return '';
  }
  my $display_text = '_(' . $source . ')';
  return $display_text;
}

sub get_hash_ref_print_in_italics {
  return FileUserData('hash_print_in_italics');
}

=item set_hash_ref_print_in_italics($hash_ref)

  The function takes as an argument a reference to a hash with keys equal to t_lemmas
  of nodes that should be displayd in italics in the sentences.
  E.g.: set_hash_ref_print_in_italics({"zdejší" => 1, "místní" => 1, "tamní" => 1});

=cut

sub set_hash_ref_print_in_italics {
  my ($hash_ref) = @_;
  FileUserData('hash_print_in_italics', $hash_ref);
}


=item dialog_edit_text_area

  The function creates a modal dialog with a multi-line text area to edit a text. It returns the edited text.
  Four string parameters are required: A title of the window, an original text, a label of the button "Ok", a label of the button "Cancel".

=cut

sub dialog_edit_text_area {
  my ($title, $original_text, $button_label_Ok, $button_label_Cancel) = @_;

  my $mw = ToplevelFrame();
  my $dialogBox = $mw->DialogBox(-title => $title, -buttons=>[$button_label_Ok, $button_label_Cancel], -default_button => $button_label_Ok);
  my $text = $dialogBox->add('Text', -width => 50, -height => 10, -wrap => 'word')->grid(-row=>3, -column=>1, -sticky=>'ew');
  $text->insert('end',$original_text);
  $dialogBox->configure(-focus => $text);
  $dialogBox->bind('<Return>' => undef);
  my $response = $dialogBox->Show;

  my $new_text = $text->get("1.0","end");
  chomp($new_text);
  #print STDERR "response: $response\n";
  if ($response eq $button_label_Ok) {
    #print STDERR "New content: $new_text";
    return $new_text;
  }
  else {
    #print STDERR "Editing canceled.\n";
    return $original_text;
  }
} # dialog_edit_text_area


=item dialog_edit_line

  The function creates a modal dialog with a single-line text widget to edit a text. It returns the edited text.
  Four string parameters are required: A title of the window, an original text, a label of the button "Ok", a label of the button "Cancel".

=cut

sub dialog_edit_line {
  my ($title, $original_text, $button_label_Ok, $button_label_Cancel) = @_;

  my $mw = ToplevelFrame();
  my $dialogBox = $mw->DialogBox(-title => $title, -buttons=>[$button_label_Ok, $button_label_Cancel], -default_button => $button_label_Ok);
  my $text = $dialogBox->add('Entry', -width => 50)->grid(-row=>3, -column=>1, -sticky=>'ew');
  $text->insert('end',$original_text);
  $dialogBox->configure(-focus => $text);
  my $response = $dialogBox->Show;

  my $new_text = $text->get();
  #print STDERR "response: $response\n";
  if ($response eq $button_label_Ok) {
    #print STDERR "New content: $new_text";
    return $new_text;
  }
  else {
    #print STDERR "Editing canceled.\n";
    return $original_text;
  }
} # dialog_edit_line


=item GotoNodeById

  Selects a node given an id in any tree in the current file.

=cut

sub GotoNodeById {
  my ($id)=@_;
  my($node,$treeNo)=PML::SearchForNodeById($id);
  return unless $node;
  TredMacro::GotoTree($treeNo);
  $this=$node;
  ChangingFile(0);
} # GotoNodeById



=item node_click_hook

  With a modifier, it does not select the node but remembers/forgets the node (with Control).
  The function is overwritten in bridging.mac!

=cut

sub node_click_hook {
  my ($node,$modifier,$xevent)=@_;
  if ($modifier =~ /^Control/) {
    if (get_mode_remember_nodes() eq 'SINGLE') {
      remember_single_node($node);
    }
    else {
      switch_remember_node($node);
    }
    main::update_value_line(GUI()->{framegroup});
  }
} # node_click_hook

=item value_line_click_hook

  Make sure that a single click in the sentences changes the current node (written by Petr Pajas, changed by JM)
  With a modifier, it does not select a node but remembers/forgets the word / whole node (depending on the modifier)

=cut

sub value_line_click_hook {
  my ($button,$modifier,$tags)=@_;

  #print STDERR "value_line_click_hook:\n  button: $button\n  modifier: $modifier\n  tags:\n";
  #foreach my $tag (@$tags) {
  #  print STDERR "         $tag\n";
  #}
  # to remember/forget a whole t-node
  if (($button eq 1) && ($modifier eq 'Control')) {
    # check if the clicked node is in the current tree:
    for my $t (grep /Treex::PML::Node/, @$tags) {
      for my $node ($root,$root->descendants) {
        next unless $node eq $t;
        if (get_mode_remember_nodes() eq 'SINGLE') {
          remember_single_node($node);
        }
        else {
          switch_remember_node($node);
        }
        # since current_node_change_hook is not called from another (this one) hook:
        # main::update_value_line(GUI()->{framegroup});
        Redraw();
        return;
      }
    }
    # otherwise it should be in some other tree
    for my $t (grep /Treex::PML::Node/, @$tags) {
      foreach my $root (GetTrees()) {
        foreach my $node (GetNodes($root)) {
          next unless $node eq $t;
          if (get_mode_remember_nodes() eq 'SINGLE') {
            remember_single_node($node);
          }
          else {
            switch_remember_node($node);
          }
          # since current_node_change_hook is not called from another (this one) hook:
          # main::update_value_line(GUI()->{framegroup});
          Redraw();
          return;
        }
      }
    }
  }

  # to remember/forget a single word (e.g. only a preposition), not the whole t-node
  if (($button eq 1) && ($modifier eq 'Shift') && is_enabled_remember_words()) {
    my $a_node_id;
    foreach my $p (@$tags) {
      if ($p =~ /^anode:(.+)$/) {
        $a_node_id = $1;
        last;
      }
    }
    if ($a_node_id) {
      my $a_node = PML_T::GetANodeByID($a_node_id);
      switch_remember_a_node($a_node);
    }
    main::update_value_line(GUI()->{framegroup});
    return;
  }

  # check if the clicked node is in the current tree:
#  for my $t (grep /^FSNode/, @$tags) { # this stopped working, the following line works
  for my $t (grep /Treex::PML::Node/, @$tags) {
    for my $node ($root,$root->descendants) {
      next unless $node eq $t;
      # make the node current (from hook we cannot just set $this)
      SetCurrentNodeInOtherWindow(CurrentWindow(),$node);
      CenterOtherWinTo(CurrentWindow(),$node);
      # since current_node_change_hook is not called from another (this one) hook:
      main::update_value_line(GUI()->{framegroup});
      return;
    }
  }

  # did not found in the current tree,
  # if neigh_sent minor mode is enabled, do what it
  # does for double-click
  if (IsMinorModeEnabled('Show_Neighboring_Sentences')) {
    # low-level stuff so that we do not have to
    # copy code from SNS
    my $sub = GUI()->{framegroup}{minorPostHooks}{value_line_doubleclick_hook}
{Show_Neighboring_Sentences};
    if (ref($sub) eq 'CODE') {
      $sub->(@$tags,undef);
    }
    # since current_node_change_hook is not called from another (this one) hook:
    main::update_value_line(GUI()->{framegroup});
  }
} # value_line_click_hook

=cut

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_secondary.

=cut

sub is_secondary {
  my ($arrow_structure) = @_;
  my $is_secondary = $arrow_structure->{'is_secondary'};
  return $is_secondary;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_compositional.

=cut

sub is_compositional {
  my ($arrow_structure) = @_;
  my $is_compositional = $arrow_structure->{'is_compositional'};
  return $is_compositional;
}


=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns 1 if the value of attribute 'type' is 'question-answer'.

=cut

sub is_question_answer {
  my ($arrow_structure) = @_;
  if ($arrow_structure->{'type'} and $arrow_structure->{'type'} eq 'question-answer') {
    return 1;
  }
  return 0;
}


=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns 1 if the value of attribute 'type' is 'entrel'.

=cut

sub is_entrel {
  my ($arrow_structure) = @_;
  if ($arrow_structure->{'type'} and $arrow_structure->{'type'} eq 'entrel') {
    return 1;
  }
  return 0;
}


=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_NP.

=cut

sub is_NP {
  my ($arrow_structure) = @_;
  my $is_NP = $arrow_structure->{'is_NP'};
  return $is_NP;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_one_arg.

=cut

sub is_one_arg {
  my ($arrow_structure) = @_;
  my $is_one_arg = $arrow_structure->{'is_one_arg'};
  return $is_one_arg;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_implicit.

=cut

sub is_implicit {
  my ($arrow_structure) = @_;
  my $is_implicit = $arrow_structure->{'is_implicit'};
  return $is_implicit;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute is_negated.

=cut

sub is_negated {
  my ($arrow_structure) = @_;
  my $is_negated = $arrow_structure->{'is_negated'};
  return $is_negated;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute missing_arg_appropriate

=cut

sub is_missing_arg_appropriate {
  my ($arrow_structure) = @_;
  my $missing_arg_appropriate = $arrow_structure->{'missing_arg_appropriate'};
  return $missing_arg_appropriate;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the value of attribute missing_arg_inappropriate

=cut

sub is_missing_arg_inappropriate {
  my ($arrow_structure) = @_;
  my $missing_arg_inappropriate = $arrow_structure->{'missing_arg_inappropriate'};
  return $missing_arg_inappropriate;
}


# get the document genre according to ACL/DCI corpus
sub get_document_genre_ad {
  my $genre = $grp->{FSFile}->metaData('pml_root')->{meta}{genre_ad};
  return $genre;
}

# set the document genre according to ACL/DCI corpus
sub set_document_genre_ad {
  my ($genre) = @_;
  $grp->{FSFile}->metaData('pml_root')->{meta}{genre_ad} = $genre;
}

# get the document genre according to Bonnie Webber's ACL 2009 paper
sub get_document_genre_bw {
  my $genre = $grp->{FSFile}->metaData('pml_root')->{meta}{genre_bw};
  return $genre;
}

# set the document genre according to Bonnie Webber's ACL 2009 paper
sub set_document_genre_bw {
  my ($genre) = @_;
  $grp->{FSFile}->metaData('pml_root')->{meta}{genre_bw} = $genre;
}


sub get_pdtb3_sense_short {
  my ($sense) = @_;
  return '' if !$sense;
  my $last_level = $ha_pdtb3_sense_2_short{$sense} // $sense;
  return $last_level;
}

sub get_pdtb3_arrow_senses_label {
  my ($arrow) = @_;
  my $label = '';
  $label .= get_pdtb3_sense_short($arrow->{'sense1A'}) // '';
  if ($arrow->{'sense1B'}) {
    $label .= '/' . get_pdtb3_sense_short($arrow->{'sense1B'});
  }
  if ($arrow->{'sense2A'}) {
    $label .= ' [' . get_pdtb3_sense_short($arrow->{'sense2A'});
    if ($arrow->{'sense2B'}) {
      $label .= '/' . get_pdtb3_sense_short($arrow->{'sense2B'});
    }
    $label .= ']';
  }
  return $label;
}

sub get_pdtb3_connectives_label {
  my ($arrow) = @_;
  my $label = '';
  if ($arrow->{'conn1'}) {
    $label .= 'conn';
    if ($arrow->{'type'} eq 'Implicit') {
      $label .= '_ins';
    }
    $label .= ': ' . $arrow->{'conn1'};
    if ($arrow->{'conn2'}) {
      $label .= ' [' . $arrow->{'conn2'} . ']';
    }
  }
  return $label;
}



=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the surface representation
  of the connectors attached to the arrow.

=cut

sub get_surface_connective {
  my ($arrow_structure) = @_;

  my @connectors_t_ids;
  my @connectors_a_ids;

  if ($arrow_structure->{'t-connectors.rf'} or $arrow_structure->{'a-connectors.rf'}) { # new attributes used
    @connectors_t_ids = ListV($arrow_structure->{'t-connectors.rf'});
    @connectors_a_ids = ListV($arrow_structure->{'a-connectors.rf'});
    if (!scalar(@connectors_t_ids) and !scalar(@connectors_a_ids)) {
      return '';
    }
  }
  elsif ($arrow_structure->{'connectors.rf'}) { # old attribute used
    my @connectors_ids = ListV($arrow_structure->{'connectors.rf'});
    if (! @connectors_ids) {
      return '';
    }
    @connectors_t_ids = grep {$_ =~ /^t-/} @connectors_ids; # take references to tectogrammatical nodes
    @connectors_a_ids = grep {$_ =~ /^a-/} @connectors_ids; # take references to analytical nodes
  }
  else { # no attribute used
    return '';
  }
  return get_surface_connective_or_extended_connective(\@connectors_t_ids, \@connectors_a_ids);
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns the surface representation
  of the extended connectors attached to the arrow.

=cut

sub get_surface_connective_ext {
  my ($arrow_structure) = @_;

  my @connectors_t_ids;
  my @connectors_a_ids;

  if ($arrow_structure->{'t-connectors_ext.rf'} or $arrow_structure->{'a-connectors_ext.rf'}) {
    @connectors_t_ids = ListV($arrow_structure->{'t-connectors_ext.rf'});
    @connectors_a_ids = ListV($arrow_structure->{'a-connectors_ext.rf'});
    if (!scalar(@connectors_t_ids) and !scalar(@connectors_a_ids)) {
      return '';
    }
  }
  else { # no attribute used
    return '';
  }
  return get_surface_connective_or_extended_connective(\@connectors_t_ids, \@connectors_a_ids);
}


sub get_surface_connective_or_extended_connective {
  my ($pa_connectors_t_ids, $pa_connectors_a_ids) = @_;
  
  my @connectors_t_ids = @$pa_connectors_t_ids;
  my @connectors_a_ids = @$pa_connectors_a_ids;

  my @connectors_t_nodes = map {PML::GetNodeByID($_)} @connectors_t_ids; # find tectogrammatical nodes given the references
  my @connectors_a_nodes = map {PML_T::GetANodeByID($_)} @connectors_a_ids; # find analytical nodes given the references

  my %h_a_surface_connectors;

  my $add_negation = 0;

  foreach my $t_node (@connectors_t_nodes) {
    my @a_nodes = PML_T::GetANodes($t_node);
    if (!@a_nodes) { # no analytical counterparts
      if ($t_node->attr('t_lemma') eq '#Neg') {
        $add_negation = 1;
      }
      else {
        # print STDERR "No analytical counterparts of the node " . $t_node->attr('id') . " with t_lemma " . $t_node->attr('t_lemma') . "\n";
        my $t_parent = $t_node->parent;
        if ($t_parent) {
          # print STDERR "It has a parent.\n";
          @a_nodes = PML_T::GetANodes($t_parent);
        } # if no parent - give up
      }
    }
    if (@a_nodes) {
      push(@connectors_a_nodes, @a_nodes);
    }
  }

  foreach my $a_node (@connectors_a_nodes) {
    if ($a_node) {
    my $ord = $a_node->attr('ord');
    # my ($file_name, $tree_number, $deepfirst_order) = LocateNode($a_node); # NEFUNGUJE, protože aktuálně nahraný je t-soubor a tohle je a-node a já neumím LocateNode dát správný odkaz na soubor
    # print "LocateNode: $file_name $tree_number $deepfirst_order\n";
    my $root_id = $a_node->root->attr('id');
    my $tree_fake_number = 0;
    if ($root_id =~ /-p(\d+)s(\d+)([A-Z]?)/) {
      $tree_fake_number = $1 * 1000000 + $2 * 1000;
      if ($3) {
        $tree_fake_number += ord($3);
      }
    }
    my $pa_a_surface_connector = $h_a_surface_connectors{"$tree_fake_number"};
    if (!defined($pa_a_surface_connector)) {
      $h_a_surface_connectors{"$tree_fake_number"} = [];
      $pa_a_surface_connector = $h_a_surface_connectors{"$tree_fake_number"};
    }
    if (defined($$pa_a_surface_connector[$ord])) {
      $$pa_a_surface_connector[$ord] = $$pa_a_surface_connector[$ord] . ' ' . $a_node->attr('m/form');
    }
    else {
      $$pa_a_surface_connector[$ord] = $a_node->attr('m/form');
    }
    }
  }

  my $surface_connective = "";
  foreach my $tree_fake_number (sort keys %h_a_surface_connectors) { # for each tree containing a part of the connective
    #print "Fake tree number: $tree_fake_number\n";
    my $pa_a_surface_connector = $h_a_surface_connectors{"$tree_fake_number"};
    foreach my $form (@$pa_a_surface_connector) {
      if (defined($form)) {
        if (length($surface_connective)) {
          $surface_connective .= ' ';
        }
        $surface_connective .= $form;
        # print "The connective so far: $surface_connective\n";
      }
    }
  }

  if ($add_negation) {
    $surface_connective = '#Neg ' . $surface_connective;
  }
  return $surface_connective;
} # get_surface_connective


=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns an array of all a-nodes representing
  the connective attached to the arrow (i.e. analytical counterparts of t-nodes marked as connectors and also a-nodes directly marked as connectors.

=cut

sub get_all_a_connectors {
  my ($arrow) = @_;
  # get a-connectors and also analytical counterparts of t-connectors and create a list of all-a-connectors:
  my @all_a_connectors = ListV($arrow->{'a-connectors.rf'});
  foreach my $t_connector_id (ListV($arrow->{'t-connectors.rf'})) {
    my $t_connector = PML::GetNodeByID($t_connector_id);
    my $lex_counterpart_id = $t_connector->attr('a/lex.rf');
    my @aux_counterparts_ids = ListV($t_connector->attr('a/aux.rf'));
    if ($lex_counterpart_id) {
      push (@all_a_connectors, $lex_counterpart_id);
    }
    push (@all_a_connectors, @aux_counterparts_ids);
  }
  return @all_a_connectors;
}

=item

  Given an arrow structure (a member of the list obtained e.g. by ListV($node->{'discourse'})), it returns an array of all a-nodes representing
  the extended connective attached to the arrow (i.e. analytical counterparts of t-nodes marked as extended connectors and also a-nodes directly marked as extended connectors.

=cut

sub get_all_a_connectors_ext {
  my ($arrow) = @_;
  # get a-connectors_ext and also analytical counterparts of t-connectors_ext and create a list of all-a-connectors_ext:
  my @all_a_connectors_ext = ListV($arrow->{'a-connectors_ext.rf'});
  foreach my $t_connector_ext_id (ListV($arrow->{'t-connectors_ext.rf'})) {
    my $t_connector_ext = PML::GetNodeByID($t_connector_ext_id);
    my $lex_counterpart_ext_id = $t_connector_ext->attr('a/lex.rf');
    my @aux_counterparts_ext_ids = ListV($t_connector_ext->attr('a/aux.rf'));
    if ($lex_counterpart_ext_id) {
      push (@all_a_connectors_ext, $lex_counterpart_ext_id);
    }
    push (@all_a_connectors_ext, @aux_counterparts_ext_ids);
  }
  return @all_a_connectors_ext;
}


sub get_structured_comment_from_arrow_structure {
  my ($arrow) = @_;
  my @str_comments = ListV($arrow->{'str_comment'});
  return get_structured_comment_from_ListV(@str_comments);
}

sub get_node_anaph_str_comment {
  my ($node) = @_;
  my @str_comments = ListV($node->{'anaph_str_comment'});
  my $str = '';
  foreach my $comment (@str_comments) {
    my $label = $comment->{'name'};
    my $text = $comment->{'comment'};
    if ($str) {
      $str .= "\n";
    }
    $str .= "ANAPH/$label: $text";
  }
  return $str;
}

sub get_structured_comment_from_ListV {
  my @str_comments = @_;
  my $str = '';
  foreach my $comment (@str_comments) {
    my $label = $comment->{'name'};
    my $text = $comment->{'comment'};
    $str .= "\n  - $label: $text";
  }
  return $str;
}


sub root_style_hook {
  # for each tree, determine the %cortype only once
  my %cortype = (
    grammatical => ['coref_gram.rf', get_display_coref_gram_arrows(), 0],
    textual => [ 'coref_text' , get_display_coref_text_arrows(), get_selected_bridging_and_coref_text_source() ],
    compl => [ 'compl.rf', get_display_complement_arrows(), 0 ],
    bridging => [ 'bridging', get_display_bridging_arrows(), get_selected_bridging_and_coref_text_source() ],
    discourse => [ 'discourse', get_display_discourse_arrows(), get_selected_discourse_source() ],
    discourse_pdtb3 => [ 'discourse-pdtb3', get_display_discourse_arrows(), get_selected_discourse_source() ],
  );
  FileUserData('node_style_hook__refha_cortype',\%cortype);
  PML_T::root_style_hook(@_);
}


sub node_style_hook {
  my ($node,$styles)=@_;

  my $nodes;
  my $is_folded = FileUserData('folded_clauses');
  # print "is_folded: $is_folded, show: $display_discourse_arrows\n";
  if ($is_folded) {
    $nodes = FileUserData('precomputed_clause_segmentation')->{$node};
  } else {
    $nodes=[$node];
  }

  my %arrows;
  my $refha_cortype = FileUserData('node_style_hook__refha_cortype'); # it is set in root_style_hook - thus only once for each displayed tree
  # (unfortunately, there is no hook called only once before all trees are redrawn)

  my $node_id_to_clause_head_id = FileUserData('precomputed_clause_head_id');
  my %target_ids_counts; # for keeping track of how many arrows go to the same target (in order to make them all visible)
  for my $type (keys %$refha_cortype) {
    my ($attr,$show,$source)=@{ $$refha_cortype{$type} };
    if ($show) {
      my $map_target = ($attr=~/\.rf$/) ? 0 : 1;
      for my $n (@$nodes) {
        my @arrows_structures_with_correct_source;
        if ($source) { # source is not zero, the attribute 'src' needs to be checked
          @arrows_structures_with_correct_source = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($n->{$attr});
        }
        else { # source is zero, all arrows will be taken
          @arrows_structures_with_correct_source = ListV($n->{$attr});
        }

        my @arrs = map {
          my $arrow = $_;

          my $ref_id; # there used to be here: my $ref_id = $map_target ? (ref($arrow) && $arrow->{'target-node.rf'}) : $arrow;

          if ($map_target) {
            if ($type eq 'discourse' or $type eq 'discourse_pdtb3') {
              $ref_id = ref($arrow) && $arrow->{'target_node.rf'};
            }
            else {
              $ref_id = ref($arrow) && ($arrow->{'target-node.rf'} or $arrow->{'target_node.rf'});
            }
          }
          else {
            $ref_id = $arrow;
          }
          if (!defined($ref_id)) {
            $ref_id = 0; # let's get rid of warnings when the target_node.rf is not defined (like at the first member of the discourse 'list')
          }

          # if folded, the adjusted target of the arrow may differ from the real (original) target
          my $adjusted_target_id = ($is_folded ? ($node_id_to_clause_head_id->{$ref_id} || $ref_id) : $ref_id);
          my $adjusted_target = PML::GetNodeByID($adjusted_target_id);
          my $target = $adjusted_target_id eq $ref_id ? $adjusted_target : PML::GetNodeByID($ref_id);
          # ??? tohle tu bylo: my $target = $real_target eq $target_id ? $real_target : PML::GetNodeByID($target_id);
          my $ret = {
            -target_id => $adjusted_target_id,
            -cortype => $type,
          };
          
          # add a hint and set properties to the discourse arrow:
          
          if ($type eq 'discourse') {
            my $arrow_type = $arrow->{'type'};
            if (! $arrow_type) {
              $arrow_type = '';
            }
            my $discourse_type = $arrow->{'discourse_type'};
            if (! $discourse_type) {
              $discourse_type = '';
            }
            if (is_negated($arrow)) {
              $discourse_type = '!' . $discourse_type;
            }
            my $start_range = $arrow->{'start_range'};
            if (! defined($start_range)) {
              $start_range = "undefined!";
            }
            if ($start_range eq 'group') {
              my $start_group_id = $arrow->{'start_group_id'};
              if (! $start_group_id) {
                $start_group_id = 'undefined!';
              }
              $start_range .= ' ' . $start_group_id;
            }
            my $target_range = $arrow->{'target_range'};
            if (! defined($target_range)) {
              $target_range = "undefined!";
            }
            if ($target_range eq 'group') {
              my $target_group_id = $arrow->{'target_group_id'};
              if (! $target_group_id) {
                $target_group_id = 'undefined!';
              }
              $target_range .= ' ' . $target_group_id;
            }
            my $comment = $arrow->{'comment'} // '';
            if ($comment =~/PHASE:1/) {
              $ret->{'-dash'} = '30,15';
            }

            my $hint = 'connective' . (is_secondary($arrow) ? '_sec: ' : ': ') . get_surface_connective($arrow);
            my $ext_conn = get_surface_connective_ext($arrow);
            if ($ext_conn) {
              $hint .= "\next. connective: $ext_conn";
            }
            $hint .= "\ntype: " . $arrow_type;
            if ($arrow_type eq 'discourse') {
              $hint .= "\ndiscourse type: " . $discourse_type;
            }
            $hint .= "\nstart range: " . $start_range
                   . "\ntarget range: " . $target_range;
            if ($comment) {
              $hint .= "\ncomment: " . $comment;
            }
            my $source = $arrow->{'src'};
            if ($source) {
              $hint .= "\nsource: " . $source;
            }
            $hint =~ s/&/_amp_/g; # a hint cannot contain '&'
            $ret->{'-hint'} = $hint;

            $ret->{'-width'} = $arrow_type eq 'list' ? 1 : 2;
            $ret->{'-width'} = 3 if $arrow_type eq 'discourse';
            $ret->{'-dash'} = '80,16' if $arrow_type eq 'entrel';
            $ret->{'-dash'} = '40,12' if $arrow_type eq 'question-answer';
            $ret->{'-dash'} = '160,20' if is_implicit($arrow);
          }
          
          # add a hint and set properties to the pdtb3 discourse arrow:
          
          elsif ($type eq 'discourse_pdtb3') {
          
            my $arrow_type = $arrow->{'type'} // '';
            my $id = $arrow->{'id'} // '';
            my $sense = get_pdtb3_arrow_senses_label($arrow);
            my $connective = get_pdtb3_connectives_label($arrow);
            my $arg1 = $arrow->{'arg1'}{'text_orig'} // $arrow->{'arg1'}{'text'};
            my $arg2 = $arrow->{'arg2'}{'text_orig'} // $arrow->{'arg2'}{'text'};
            my $provenance = $arrow->{'provenance'};
            
            my $hint = "id: $id";
            $hint .= "\ntype: $arrow_type";
            if ($sense) {
              $hint .= "\nsense: $sense";
            }
            if ($connective) {
              $hint .= "\n$connective";
            }
            if ($arg1) {
              $hint .= "\narg1: $arg1";
            }
            if ($arg2) {
              $hint .= "\narg2: $arg2";
            }
            if ($provenance) {
              $hint .= "\nprov: $provenance";
            }
            
            $hint =~ s/&/_amp_/g; # a hint cannot contain '&'
            $ret->{'-hint'} = $hint;

            $ret->{'-width'} = 3;
            $ret->{'-dash'} = '80,16' if $arrow_type eq 'EntRel';
            $ret->{'-dash'} = '160,20' if $arrow_type eq 'Implicit';
            $ret->{'-dash'} = '240,25' if $arrow_type eq 'NoRel';
          }

          # add a hint to the coref_text arrow:
          
          elsif ($type eq 'textual') {
            my $inf_type = $arrow->{'informal-type'};
            if (!$inf_type) {
              $inf_type = "";
            }
            my $hint = "type: " . $inf_type;
            my $comment = $arrow->{'comment'};
            if ($comment) {
              $hint .= "\ncomment: " . $comment;
            }
            my @str_comments = ListV($arrow->{str_comment});
            if (scalar(@str_comments)) {
              $hint .= "\nstructured comments:" . get_structured_comment_from_ListV(@str_comments);
            }
            my $source = $arrow->{'src'};
            if ($source) {
              $hint .= "\nsource: " . $source;
            }
            $hint =~ s/&/_amp_/g; # a hint cannot contain '&'
            $ret->{'-hint'} = $hint;
          }
          
          # add a hint to the bridging arrow:
          
          elsif ($type eq 'bridging') {
            my $inf_type = $arrow->{'informal-type'};
            if (!$inf_type) {
              $inf_type = "";
            }
            my $hint = 'type: ' . $inf_type;
            my $comment = $arrow->{'comment'};
            if ($comment) {
              $hint .= "\ncomment: " . $comment;
            }
            my @str_comments = ListV($arrow->{str_comment});
            if (scalar(@str_comments)) {
              $hint .= "\nstructured comments:" . get_structured_comment_from_ListV(@str_comments);
            }
            my $source = $arrow->{'src'};
            if ($source) {
              $hint .= "\nsource: " . $source;
            }
            $hint =~ s/&/_amp_/g; # a hint cannot contain '&'
            $ret->{'-hint'} = $hint;
          }
          
          # check if there have been previous arrows going to the same target
          
          my $target_id_count = $target_ids_counts{$adjusted_target_id};
          if (!defined($target_id_count)) {
            $target_id_count = 0;
          }
          $target_id_count ++;
          $target_ids_counts{$adjusted_target_id} = $target_id_count;
          if ($target_id_count > 1) { # more than one arrow going to the same target
            $ret->{'-frac'} = ($target_id_count - 1.0) * 0.1 + 0.12;
          }
          if ($is_folded) {
            if ($n != $node) {
              $ret->{-dash} = ($adjusted_target_id ne $ref_id) ? '.' : '10,6,2,2';
            } elsif ($adjusted_target_id ne $ref_id) {
              $ret->{-dash} = '10,2,2,6';
            }
            if ($n && $adjusted_target) {
              if ( defined($PML_T::displayed_nodes{ $node }) and
                defined($PML_T::displayed_nodes{ $target }) and
                $PML_T::displayed_nodes{ $node } > $PML_T::displayed_nodes{ $target }) {
                $ret->{-hint} = qq{$type: $adjusted_target->{t_lemma}.$adjusted_target->{functor} <--- $n->{t_lemma}.$n->{functor}}
              } else {
                $ret->{-hint} = qq{$type: $n->{t_lemma}.$n->{functor} ---> $adjusted_target->{t_lemma}.$adjusted_target->{functor}}
              }
            }
          }
          $ret
        } grep { defined and length } @arrows_structures_with_correct_source;

        push @{$arrows{$type}}, @arrs;
      }
    }
  }

  my @arrow_types = sort keys %arrows;
  my $refar_node_ids = [ map { map $_->{'-target_id'}, @{$arrows{$_}} } @arrow_types ];
  my $refar_coreftypes = [ map { @{$arrows{$_}} } @arrow_types ];
  #my $refha_style_opts = {
  #    '*' => { -width => 1},
  #    'discourse' => { -width => 3 }, # commented out becouse we need to distinguish between two types of discourse arrows
  #   };

  DrawCorefArrows($node, $styles, undef, $refar_node_ids, $refar_coreftypes, undef, undef); # $refha_style_opts);

  return 1;
} # node_style_hook



=pod DrawCorefArrows() from .tred.d/extensions/pdt20/contrib/pml/PML_T.inc

Called from C<node_style_hook>. Draws coreference arrows using
following properties: textual arrows in CustomColor C<arrow_textual>,
grammatical in <arrow_grammatical> (and dashed in Full stylesheet),
complement arrow in C<arrow_compl> (and dot-dashed in Full
stylesheet), segment arrow in C<arrow_segm> and exophora arrow in
C<arrow_exoph>.

sub DrawCorefArrows {
  my ($node,$styles,$line,$corefs,$cortypes,$reserved,$style_opts)=@_;

  # corefs is an array-ref of node IDs
  # coreftypes is an array-ref of cortypes strings or
  # of hashes { -cortype => 'cortype', ...edge_options... }
  # specifying a cortype and custom edge drawing options passed to
  # DrawArrows from <contrib/support/arrows.inc>

=cut



=item get_value_line_hook

  Highlight all necessary things in the sentences

=cut



sub get_value_line_hook {


    my ($fsfile,$treeNo)=@_;
    my $items = PML_T::get_value_line_hook(@_);

    my @list_coref_text;
    my @list_coref_gram;
    my @list_bridging;
    my $ref_bridging_anaphors;
    my $ref_coref_text_anaphors;
    my @list_first_discourse;
    my @list_first_discourse_pdtb3;

    my $color_discourse;
    my $color_discourse_pdtb3;
    my $color_connective_in_text;
    my $color_bridging;
    my $color_coref_text;
    my $color_coref_gram;

    my $display_coref_text = get_display_coref_text_arrows();
    my $display_coref_gram = get_display_coref_gram_arrows();
    my $display_bridging = get_display_bridging_arrows();
    my $display_discourse = get_display_discourse_arrows();
    my $display_discourse_pdtb3 = get_display_discourse_arrows();

    if ($display_coref_text) {
      $color_coref_text = get_color_coref_text_line();
      @list_coref_text = get_list_coref_text($this, 0);
      $ref_coref_text_anaphors = FileUserData('coref_text_anaphors');
    }
    if ($display_coref_gram) {
      $color_coref_gram = get_color_coref_gram();
      @list_coref_gram = get_list_coref_gram($this, 0);
    }

    if ($display_bridging) {
      $color_bridging = get_color_bridging();
      # create a list of nodes connected with one bridging arrow from a node that is a part of one of the previous lists
      @list_bridging = get_direct_bridging_antecedents($this);
      $ref_bridging_anaphors = FileUserData('bridging_anaphors');
      for my $text_chain_node (@list_coref_text) {
        push (@list_bridging, get_direct_bridging_antecedents($text_chain_node));
        my $ref_array = $ref_bridging_anaphors->{$text_chain_node->attr('id')};
        if ($ref_array) {
          push (@list_bridging, @$ref_array);
        }
      }
      for my $gram_chain_node (@list_coref_gram) {
        push (@list_bridging, get_direct_bridging_antecedents($gram_chain_node));
        if ($gram_chain_node) {
          my $ref_array = $ref_bridging_anaphors->{$gram_chain_node->attr('id')};
          if ($ref_array) {
            push (@list_bridging, @$ref_array);
          }
        }
      }
    }
    if ($display_discourse) {
      $color_discourse = get_color_discourse();
      $color_connective_in_text = get_color_connective_in_text();
      @list_first_discourse = ListV($this->{'discourse'});
    }

    if ($display_discourse_pdtb3) {
      $color_discourse_pdtb3 = get_color_discourse_pdtb3();
      $color_connective_in_text = get_color_connective_in_text();
      @list_first_discourse_pdtb3 = ListV($this->{'discourse-pdtb3'});
    }

    my $selected_group_id = FileUserData('clicked_group_id');

    for my $item (@$items) {

      #print STDERR "-----------\n";
      #foreach my $p (@$item) {
      #  print STDERR "item: $p\n";
      #}

      my $node = $item->[1];

      if (ref $node) { # a reference to a t-node

        my $node_id = $node->attr('id');

        # get id of the analytical node:
        my $a_node_id;
        foreach my $p (@$item) {
          if ($p =~ /^anode:(.+)$/) {
            $a_node_id = $1;
            last;
          }
        }
        # get the analytical node:
        my $a_node;
        if ($a_node_id) {
          $a_node = PML_T::GetANodeByID($a_node_id);
        }
        # print STDERR "\nitem - anode: $a_node_id";
        # print STDERR "\n";

        # underline all words with the same t_lemma as the current node:
        if (get_underline_same_t_lemmas()) {
          if ($node->attr('t_lemma') && $this->attr('t_lemma')) {
            if ($node->attr('t_lemma') eq $this->attr('t_lemma')) {
              push @$item, '-underline => 1';
            }
          }
        }

        # print some words in italics:
        my $hash_italics_ref = get_hash_ref_print_in_italics();
        if ($hash_italics_ref) { # if the hash is not empty
          my $node_t_lemma = $node->attr('t_lemma');
          if ($$hash_italics_ref{$node_t_lemma}) {
            push @$item, '-font => C_italic';
          }
        }

        # highlite the remembered node if standard $PML_T_Edit::remember is used
        if ($PML_T_Edit::remember) {
          if ($PML_T_Edit::remember eq $node) {
            push @$item, '-background => red';
          }
        }

        # highlight all the remembered nodes
        if (is_remembered_node($node)) {
          push @$item, '-background => red';
        }
        # highlight all the remembered a-nodes
        if (is_remembered_a_node($a_node)) {
          push @$item, '-background => #fe76fe';
        }

        # if a group is selected, highlite all nodes in the selected group (except the current node)
        if (defined($selected_group_id)) {
          if (is_member_of_group($node, $selected_group_id)) {
            if ($node ne $this) { # the current node will be highlighted in a different way
              push @$item, '-background => #FFFAAA';
            }
          }
        }
        else { # only highlight nodes in the subtree of the current node if no group is selected
          # highlite all nodes in the subtree of the current node (except the current node)
          if (is_pure_predecessor_safer($this, $node)) {
            push @$item, '-background => #FFFAAA';
          }
        }

        # for a generated node, highlight sentence counterparts of its non-generated father
        if ($this->attr('is_generated') and $this->attr('is_generated') eq 1) {
          if ($node eq $this->parent) {
            push @$item, '-background => #FFFAAA';
          }
        }

        my $toggle_highlighting_coref_words = FileUserData('toggle_highlighting_coref_words');
        if (!defined($toggle_highlighting_coref_words)) {
          $toggle_highlighting_coref_words = 0;
        }

        # highlight all nodes in the sentences where a coreference arrow starts or ends:
        if ($toggle_highlighting_coref_words eq 1) { # highlight all coref words (not only the current chain)
          my @coref_text_from_here = ListV($node->{coref_text}); # first if a coref_text starts here
          if (scalar(@coref_text_from_here)) {
            push @$item, "-foreground => " . '#671522';
          }
          else { # maybe there ends a coref_text arrow here
            my $ref_node_coref_text_anaphors = $ref_coref_text_anaphors->{$node_id};
            if (defined($ref_node_coref_text_anaphors) and scalar(@$ref_node_coref_text_anaphors)) {
              push @$item, "-foreground => " . '#671522';
            }
          }
        }

        # highlight the members of the coreferential chains (in the sentences) going to the current node:
        if ($display_coref_text) {
          my @text_links = get_list_coref_first_text($node, 0);
          my $index = Index(\@text_links,$this);
          if (defined($index) && $index>=0) {
            push @$item, "-foreground => " . $color_coref_text;
          }
        }
        if ($display_coref_gram) {
          my @gram_links = get_list_coref_first_gram($node, 0);
          my $index = Index(\@gram_links,$this);
          if (defined($index) && $index>=0) {
            push @$item, "-foreground => " . $color_coref_gram;
          }
        }
        if ($display_bridging) {
        # nodes connected with one bridging arrow with any node from a coreferential chain going to the current node:
          my @bridging_links = get_list_coref_first_bridging($node, 0);
          my $index = Index(\@bridging_links,$this);
          if (defined($index) && $index>=0) {
            push @$item, "-foreground => " . $color_bridging;
          }
          # now let us take care of nodes that are targets of a bridging arrow going from a node that is a part of a coreferential
          # chain going to the current node
          my $ref_node_bridging_anaphors = $ref_bridging_anaphors->{$node_id};
          foreach my $bridging_anaphora (@$ref_node_bridging_anaphors) {
            my @text_links = get_list_coref($bridging_anaphora, 0);
            my $index = Index(\@text_links,$this);
            if (defined($index) && $index>=0) {
              push @$item, "-foreground => " . $color_bridging;
            }
          }
        }

        # highlight the members of the coreferential chains (in the sentences) going from the current node:
        if ($display_coref_text) {
          foreach my $coref_text_node (@list_coref_text) {
            if ($node_id eq $coref_text_node->{'id'}) {
              push @$item, "-foreground => " . $color_coref_text;
            }
          }
        }
        if ($display_coref_gram) {
          foreach my $coref_gram_node (@list_coref_gram) {
            if ($coref_gram_node && ($node_id eq $coref_gram_node->{'id'})) {
              push @$item, "-foreground => " . $color_coref_gram;
            }
          }
        }
        if ($display_bridging) {
          foreach my $bridging_node (@list_bridging) {
            if ($node_id and $node_id eq $bridging_node->{'id'}) {
              push @$item, "-foreground => " . $color_bridging;
            }
          }
        }

        # highlight the words connected with a single discourse arrow (both directions):
        if ($display_discourse) {
          foreach my $discourse_link (@list_first_discourse) { # take all discourse pointers from the current node ($this) and check if any of them goes to the tested node ($node)
            my $target_node_id = $discourse_link->{'target_node.rf'};
            if ($target_node_id && $target_node_id eq $node_id) {
              push @$item, "-foreground => " . $color_discourse;
            }
          }
          foreach my $discourse_link (ListV($node->{'discourse'})) { # take all discourse pointers from the tested node $node and check if any of them goes to the current node ($this)
            my $target_node_id = $discourse_link->{'target_node.rf'};
            if ($target_node_id && $target_node_id eq $this->attr('id')) {
              push @$item, "-foreground => " . $color_discourse;
            }
          }
        }

        # highlight the words connected with a single discourse pdtb3 arrow (both directions):
        if ($display_discourse_pdtb3) {
          foreach my $discourse_link (@list_first_discourse_pdtb3) { # take all pdtb3 discourse pointers from the current node ($this) and check if any of them goes to the tested node ($node)
            my $target_node_id = $discourse_link->{'target_node.rf'};
            if ($target_node_id && $target_node_id eq $node_id) {
              push @$item, "-foreground => " . $color_discourse_pdtb3;
            }
          }
          foreach my $discourse_link (ListV($node->{'discourse-pdtb3'})) { # take all pdtb3 discourse pointers from the tested node $node and check if any of them goes to the current node ($this)
            my $target_node_id = $discourse_link->{'target_node.rf'};
            if ($target_node_id && $target_node_id eq $this->attr('id')) {
              push @$item, "-foreground => " . $color_discourse_pdtb3;
            }
          }
        }
        
        
        # highlight the words that belong to t-connectors of an arrow starting at $this
        if ($display_discourse) {
          foreach my $discourse_link (@list_first_discourse) { # take all discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
            my @t_connectors = ListV($discourse_link->{'t-connectors.rf'});
            # print STDERR "Checking " . scalar(@t_connectors) . " t-connectors\n";
            if (is_member_of_array($node_id, @t_connectors)) {
              # print STDERR "found!\n";
              push @$item, "-foreground => $color_connective_in_text";
              last;
            }
          }
        }
        # highlight the words with tectogrammatical counterpart that belong to a-connectors of an arrow starting at $this
        if ($display_discourse) {
          if ($a_node_id) {
            my $a_node_id_prefixed = "a#$a_node_id";
            foreach my $discourse_link (@list_first_discourse) { # take all discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
              my @a_connectors = ListV($discourse_link->{'a-connectors.rf'});
              # print STDERR "Checking " . scalar(@a_connectors) . " a-connectors\n";
              if (is_member_of_array($a_node_id_prefixed, @a_connectors)) {
                # print STDERR "found!\n";
                push @$item, "-foreground => $color_connective_in_text";
                last;
              }
            }
          }
        }
        
        # highlight the words that belong to t-connectors of a pdtb3 arrow starting at $this
        if ($display_discourse_pdtb3) {
          foreach my $discourse_link (@list_first_discourse_pdtb3) { # take all pdtb3 discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
            my @t_connectors = ListV($discourse_link->{'t-nodes.rf'});
            # print STDERR "Checking " . scalar(@t_connectors) . " t-connectors\n";
            if (is_member_of_array($node_id, @t_connectors)) {
              # print STDERR "found!\n";
              push @$item, "-foreground => $color_connective_in_text";
              last;
            }
          }
        }
        # highlight the words with tectogrammatical counterpart that belong to a-connectors of a pdtb3 arrow starting at $this
        if ($display_discourse_pdtb3) {
          if ($a_node_id) {
            my $a_node_id_prefixed = "a#$a_node_id";
            foreach my $discourse_link (@list_first_discourse_pdtb3) { # take all pdtb3 discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
              my @a_connectors = ListV($discourse_link->{'a-nodes.rf'});
              # print STDERR "Checking " . scalar(@a_connectors) . " a-connectors\n";
              if (is_member_of_array($a_node_id_prefixed, @a_connectors)) {
                # print STDERR "found!\n";
                push @$item, "-foreground => $color_connective_in_text";
                last;
              }
            }
          }
        }
        
      }

      else { # not a t-node; it still may be an a-node without a tecto counterpart
        # get id of the analytical node:
        my $a_node_id;
        foreach my $p (@$item) {
          if ($p =~ /^anode:(.+)$/) {
            $a_node_id = $1;
            last;
          }
        }
        if ($a_node_id) {
          # get the analytical node:
          my $a_node;
          if ($a_node_id) {
            $a_node = PML_T::GetANodeByID($a_node_id);
          }
          # highlight all the remembered a-nodes without a tecto counterpart
          if (is_remembered_a_node($a_node)) {
            push @$item, '-background => #fe76fe';
          }
          # highlight the words without tectogrammatical counterpart that belong to a-connectors of an arrow starting at $this
          if ($display_discourse) {
            my $a_node_id_prefixed = "a#$a_node_id";
            foreach my $discourse_link (@list_first_discourse) { # take all discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
              my @a_connectors = ListV($discourse_link->{'a-connectors.rf'});
              # print STDERR "Checking " . scalar(@a_connectors) . " a-connectors\n";
              if (is_member_of_array($a_node_id_prefixed, @a_connectors)) {
                # print STDERR "found!\n";
                push @$item, "-foreground => $color_connective_in_text";
                last;
              }
            }
          }
          # highlight the words without tectogrammatical counterpart that belong to a-connectors of a pdtb3 arrow starting at $this
          if ($display_discourse_pdtb3) {
            my $a_node_id_prefixed = "a#$a_node_id";
            foreach my $discourse_link (@list_first_discourse_pdtb3) { # take all pdtb3 discourse pointers from the current node ($this) and check if any of them has the tested node among its connectors
              my @a_connectors = ListV($discourse_link->{'a-nodes.rf'});
              # print STDERR "Checking " . scalar(@a_connectors) . " a-connectors\n";
              if (is_member_of_array($a_node_id_prefixed, @a_connectors)) {
                # print STDERR "found!\n";
                push @$item, "-foreground => $color_connective_in_text";
                last;
              }
            }
          }          
        }
      }
    }


    my $actual_tree = $fsfile && $fsfile->tree($treeNo);
    my $toggle_translation = FileUserData('toggle_translation') // 0;

    # add the translated sentence in PEDT:
    if ($toggle_translation eq 0) { # only the translation of the actual sentence
      if ($root eq $actual_tree ) {
        if($actual_tree->{cze_sentence}){
          push @$items,(["\n".$actual_tree->{cze_sentence}."\n",'-foreground=>blue']);
        }
      }
    }
    elsif ($toggle_translation eq 1) { # translation of all sentences
      if($actual_tree->{cze_sentence}) {
        push @$items,(["\n".$actual_tree->{cze_sentence}."\n",'-foreground=>blue']);
      }
    }

    # add the translated sentence in PCEDT-cz:
    if ($toggle_translation eq 0) { # only the translation of the actual sentence
      if ($root eq $actual_tree ) {
        if($actual_tree->{eng_sentence}){
          push @$items,(["\n[".$actual_tree->{eng_sentence}."]\n",'-foreground=>blue']);
        }
      }
    }
    elsif ($toggle_translation eq 1) { # translation of all sentences
      if($actual_tree->{eng_sentence}) {
        push @$items,(["\n[".$actual_tree->{eng_sentence}."]\n",'-foreground=>blue']);
      }
    }

    
    # paragraph separation
    if (my $separator = get_paragraph_separator()) {
      if ($separator eq "\n") {
        # create an empty line if a new paragraph starts after the sentence
        # "\n" is put at the end of the last sentence of the ending paragraph so that the arrow marking the actual sentence
        # does not point to an empty line
        my $nextTree = $fsfile && $fsfile->tree($treeNo+1);
        if ($nextTree && $nextTree->{id}) {
          if ($nextTree->{id}=~/s1[A-Z]*$/) { # next tree starts a new paragraph
            push @$items, [$separator, 'space'];
          }
        }
      }
      else {
      # if the separator is not "\n", let us put it in front of the sentence (if it starts the new paragraph)
        if (my $separator = get_paragraph_separator()) {
          my $actual_tree = $fsfile && $fsfile->tree($treeNo);
          if ($actual_tree && $actual_tree->{id}) {
            if ($actual_tree->{id}=~/s1[A-Z]*$/) { # the actual tree starts a new paragraph
              unshift @$items, [$separator, 'space'];
            }
          }
        }
      }
    }

    return $items;
} # get_value_line_hook


=item is_member_of_group($node, $group_id)

  Return a positive integer if the node is a member of the group with C<id>, i.e. if the C<id> appears in the list of the node's groups ids.
  Otherwise returns 0.
  The returned number represents the order of the group in the list of groups of the node (starting from 1).

=cut

sub is_member_of_group {
  my ($node, $group_id) = @_;
  my @groups = ListV($node->attr('discourse_groups'));
  my $number = 1;
  foreach my $group (@groups) {
    if ($group_id == $group->{'id'}) {
      return $number;
    }
    $number++;
  }
  return 0;
} # is_member_of_group



=item get_list_coref_gram

  It creates recursively a list of nodes a grammatical coreferential chain goes to from the given node.
  Textual coreference is considered to continue the coreferential chain but
  the nodes connected by the textual coreference will not become part of the result list.

=cut

sub get_list_coref_gram {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;
  foreach my $coref_gram_link (ListV($start->{'coref_gram.rf'})) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_gram_link);
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref_gram($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_coref_text_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_coref_text_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'coref_text'});
  }
  else { # source is zero, all arrows will be taken
    @a_coref_text_links = ListV($start->{'coref_text'});
  }

  foreach my $coref_text_link (@a_coref_text_links) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_text_link->{'target-node.rf'} || $coref_text_link->{'target_node.rf'});
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref_gram($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }

  return @coref_nodes;
} # get_list_coref_gram

=item get_list_coref_text

  It creates recursively a list of nodes a text coreferential chain goes to from the given node.
  Grammatical coreference is considered to continue the coreferential chain but
  the nodes connected by the grammatical coreference will not become part of the result list.

=cut

sub get_list_coref_text {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_coref_text_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_coref_text_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'coref_text'});
  }
  else { # source is zero, all arrows will be taken
    @a_coref_text_links = ListV($start->{'coref_text'});
  }

  foreach my $coref_text_link (@a_coref_text_links) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_text_link->{'target-node.rf'} || $coref_text_link->{'target_node.rf'});
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref_text($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }

  foreach my $coref_gram_link (ListV($start->{'coref_gram.rf'})) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_gram_link);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref_text($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  return @coref_nodes;
} # get_list_coref_text


=item get_list_coref($start_node, 0)

  It creates recursively a list of nodes a text- or gramm-coreferential chain goes to from the given node.
  Both grammatical and textual coreferences are considered to be part of the coreferential chain.

=cut

sub get_list_coref {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_coref_text_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_coref_text_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'coref_text'});
  }
  else { # source is zero, all arrows will be taken
    @a_coref_text_links = ListV($start->{'coref_text'});
  }

  foreach my $coref_text_link (@a_coref_text_links) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_text_link->{'target-node.rf'} || $coref_text_link->{'target_node.rf'});
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  foreach my $coref_gram_link (ListV($start->{'coref_gram.rf'})) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_gram_link);
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  return @coref_nodes;
} # get_list_coref


=item get_list_coref_first_text

  It creates recursively a text- or gramm-coreferential chain starting at the given node with a textual arrow.
  Both grammatical and textual coreferences are considered to be part of the coreferential chain.

=cut

sub get_list_coref_first_text {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_coref_text_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_coref_text_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'coref_text'});
  }
  else { # source is zero, all arrows will be taken
    @a_coref_text_links = ListV($start->{'coref_text'});
  }

  foreach my $coref_text_link (@a_coref_text_links) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_text_link->{'target-node.rf'} || $coref_text_link->{'target_node.rf'});
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  return @coref_nodes;
} # get_list_coref_first_text


=item get_list_coref_first_gram

  It creates recursively a text- or gramm-coreferential chain starting at the given node with a grammatical arrow.
  Both grammatical and textual coreferences are considered to be part of the coreferential chain.

=cut

sub get_list_coref_first_gram {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;
  foreach my $coref_gram_link (ListV($start->{'coref_gram.rf'})) { # take all coreferential pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($coref_gram_link);
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  return @coref_nodes;
} # get_list_coref_first_gram

=item get_list_coref_first_bridging

  It creates recursively a text- or gramm-coreferential chain starting at the given node with a bridging arrow.
  Both grammatical and textual coreferences are considered to be part of the coreferential chain.

=cut

sub get_list_coref_first_bridging {
  my ($start, $size) = @_;
  my @coref_nodes;
  my $node;
  my @nodes;

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_bridging_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_bridging_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'bridging'});
  }
  else { # source is zero, all arrows will be taken
    @a_bridging_links = ListV($start->{'bridging'});
  }

  foreach my $bridging_link (@a_bridging_links) { # take all bridging pointers, resolve the references and go on in the recursion
    $node = PML::GetNodeByID($bridging_link->{'target-node.rf'} || $bridging_link->{'target_node.rf'});
    push(@coref_nodes, $node);
    $size ++;
    if ($size < $coreferential_chain_max_size) {
      @nodes = get_list_coref($node, $size);
      push(@coref_nodes, @nodes);
      $size += @nodes;
    }
  }
  return @coref_nodes;
} # get_list_coref_first_bridging


=item get_direct_bridging_antecedents

  Returns all direct bridging antecedents of a given node in an array.

=cut

sub get_direct_bridging_antecedents {
  my ($start) = @_;

  my $source = get_selected_bridging_and_coref_text_source();

  my @a_bridging_links;
  if ($source) { # source is not zero, the attribute 'src' needs to be checked
    @a_bridging_links = grep {exists($_->{'src'}) && $_->{'src'} eq $source} ListV($start->{'bridging'});
  }
  else { # source is zero, all arrows will be taken
    @a_bridging_links = ListV($start->{'bridging'});
  }

  my @bridging_nodes = map {PML::GetNodeByID($_->{'target-node.rf'}  || $_->{'target_node.rf'})} @a_bridging_links;
#  foreach my $bridging_link (ListV($start->{'bridging'})) { # take all coreferential pointers and resolve the references
#    my $node = PML::GetNodeByID($bridging_link->{'target-node.rf'});
#    push(@bridging_nodes, $node);
#  }
  return @bridging_nodes;
}



=item initialize_file_related_resources()

  After a file is opened (or reloaded), certain variables and data structures need to be initialized.
  It takes a hash reference as an argument - the keys of the hash define which
  types of resources need to be initialized (and how):
  'bridging', 'coref_text', 'discourse'

=cut

sub initialize_file_related_resources {
  my ($r_types) = @_;

  if (exists($r_types->{'bridging'})) {
    set_display_bridging_arrows(1);
    set_show_bridging_arrow_type(1);
  }

  if (exists($r_types->{'coref_text'})) {
    set_display_coref_gram_arrows(1);
    set_display_coref_text_arrows(1);
    set_show_coref_text_arrow_type(1);
  }
  if (exists($r_types->{'discourse'})) {
    set_display_discourse_arrows(1);
    set_show_discourse_arrow_type(1);
    set_show_discourse_arrow_comment(1);
    set_show_discourse_arrow_connector(1);
    set_show_discourse_arrow_range(1);
    set_show_discourse_node_comment(1);
  }

  set_display_complement_arrows(1);

  set_highlight_one_bridging_source('');

  # initialization of colors:
  set_color_bridging('#00ccff'); # light blue color
  set_color_coref_text(CustomColor('arrow_textual'));
  set_color_coref_gram(CustomColor('arrow_grammatical'));
  set_color_discourse('#ff710c'); # orange color
  set_color_discourse_pdtb3('#ff30dd'); # pink color

  set_underline_same_t_lemmas(1);

  set_paragraph_separator("\n");

  set_hash_ref_print_in_italics({}); # a hash of t_lemmas that should be printed in italics

} # initialize_file_related_resources

=item precompute_file_related_resources()

  After a file is opened (or reloaded), certain data structures need to be precomputed.
  This function initializes the data structures and creates a cycle over all nodes in all trees.
  It takes a hash reference as an argument - the keys of the hash define which
  types of resources need to be precomputed:
  'bridging', 'coref_text', 'discourse'

=cut

sub precompute_file_related_resources {

  my ($r_types) = @_;

  my $display_bridging_arrows = get_display_bridging_arrows();
  my $display_coref_text_arrows = get_display_coref_text_arrows();
  my $display_discourse_arrows = get_display_discourse_arrows();

  if ($display_bridging_arrows or $display_discourse_arrows) { # if a precomputation is needed

    # initialization of data structures
    if ($display_bridging_arrows && exists($r_types->{'bridging'})) {
      FileUserData('selected_source_bridging_and_coref_text',0);
      FileUserData('bridging_anaphors',{});
      # keys = node ids; values = references to arrays of nodes a bridging arrows point from to the given node
      FileUserData('list_of_bridging_and_coref_text_sources',{});
      # keys = sources of bridging arrows; value = 1 for each (existing) source
    }
    if ($display_coref_text_arrows && exists($r_types->{'coref_text'})) {
      FileUserData('selected_source_bridging_and_coref_text',0);
      FileUserData('coref_text_anaphors',{});
      FileUserData('list_of_bridging_and_coref_text_sources',{});
      # keys = sources of coref_text arrows; value = 1 for each (existing) source
    }
    if ($display_discourse_arrows && exists($r_types->{'discourse'})) {
      FileUserData('selected_source_discourse',0);
      FileUserData('groups_representative_nodes',{});
      # keys = groups ids; values = representative nodes
      FileUserData('list_of_discourse_sources',{});
      # keys = sources of discourse arrows; value = 1 for each (existing) source
      FileUserData('a_nodes_to_t_nodes',{});
      # keys = a-node ids; values = respective t-node ids separated by '__'; used for setting connectives as much on the t-layer as possible
    }

    # a cycle over all trees and nodes in the trees
    foreach my $root (GetTrees()) {
      foreach my $node (GetNodes($root)) {
        if ($display_bridging_arrows && exists($r_types->{'bridging'})) {
          create_lists_of_anaphors($node);
          create_list_of_bridging_and_coref_text_sources($node);
        }
        if ($display_coref_text_arrows && exists($r_types->{'coref_text'})) {
          create_lists_of_coref_text_anaphors($node);
#          create_list_of_bridging_and_coref_text_sources($node);
        }
        if ($display_discourse_arrows && exists($r_types->{'discourse'})) {
          create_list_of_groups($node);
          create_list_of_discourse_sources($node);
          add_to_a_nodes_to_t_nodes_hash($node);
        }
      }
    }

    # post-processing
    #if ($display_bridging_arrows && defined($r_types->{'bridging'})) {
    #  my $ref_list_of_bridging_sources = FileUserData('list_of_bridging_sources');
    #  # keys = sources of bridging arrows; value = 1 for each (existing) source
    #  my @colors_bridging_various_sources = ('#55cc00', '#99ddbb', '#bbff11', '#ffddaa');
    #  #my @colors_bridging_various_sources = ('#00ccff', '#11ddff', '#22eeff', '#33ddff');
    #  my $order = 0;
    #  my $number_of_colors = scalar(@colors_bridging_various_sources);
    #  foreach my $source (keys %$ref_list_of_bridging_sources) { # set a custom color for each bridging source
    #    CustomColor('arrow_bridging_' . $source, $colors_bridging_various_sources[$order % $number_of_colors]);
    #    print STDERR "Setting custom color: arrow_bridging_" . $source . " - " . $colors_bridging_various_sources[$order % $number_of_colors] . "\n";
    #    $order++;
    #  }
    #}
  }

  return;
} # precompute_file_related_resources



sub is_precomputed_file_related_resources_bridging {
  if (defined(FileUserData('bridging_anaphors')) && defined(FileUserData('list_of_bridging_sources'))) {
    # print STDERR "precomputed_bridging: 1\n";
    return 1;
  }
  else {
    # print STDERR "precomputed_bridging: 0\n";
    return 0;
  }
} # is_precomputed_file_related_resources_bridging

sub is_precomputed_file_related_resources_coref_text {
  if (defined(FileUserData('coref_text_anaphors')) && defined(FileUserData('list_of_coref_text_sources'))) {
    # print STDERR "precomputed_coref_text: 1\n";
    return 1;
  }
  else {
    # print STDERR "precomputed_coref_text: 0\n";
    return 0;
  }
} # is_precomputed_file_related_resources_coref_text

sub is_precomputed_file_related_resources_discourse {
  if (defined(FileUserData('groups_representative_nodes')) && defined(FileUserData('list_of_discourse_sources'))) {
    # print STDERR "precomputed_discourse: 1\n";
    return 1;
  }
  else {
    # print STDERR "precomputed_discourse: 0\n";
    return 0;
  }
} # is_precomputed_file_related_resources_discourse


sub free_file_related_resources_bridging {
  FileUserData('bridging_anaphors',undef);
  FileUserData('list_of_bridging_sources',undef);
} # free_file_related_resources_bridging

sub free_file_related_resources_coref_text {
  FileUserData('coref_text_anaphors',undef);
  FileUserData('list_of_coref_text_sources',undef);
} # free_file_related_resources_coref_text

sub free_file_related_resources_discourse {
  FileUserData('groups_representative_nodes',undef);
  FileUserData('list_of_discourse_sources',undef);
} # free_file_related_resources_discourse


=item add_to_a_nodes_to_t_nodes_hash

  When setting a connective to a discourse arrow, I need to check if some of the remembered a-nodes can be replaced by their respective t-node counterparts.
  To be able to effectively check it, I create here (node after node) a hash with a-node ids as keys and respective t-node ids (separated by '__' if multiple) as values.

=cut

sub add_to_a_nodes_to_t_nodes_hash {
  my ($t_node) = @_;
  if (!defined($t_node)) {
    return;
  }
  my $ph_a_t = FileUserData('a_nodes_to_t_nodes');
  # keys = a-node ids; values = respective t-node ids separated by '__'; used for setting connectives as much on the t-layer as possible
  my @anals = get_analytical_counterparts_ids_from_node($t_node);
  my $t_node_id = $t_node->attr('id');
  foreach my $a_node_id (@anals) {
    if (defined($a_node_id) and $a_node_id) {
      # print STDERR "a_node_id: '$a_node_id'\n";
      $a_node_id =~ s/^a#//;
      if (defined($$ph_a_t{$a_node_id})) {
        $$ph_a_t{$a_node_id} .= '__' . $t_node_id;
        # print STDERR "Multiple t-nodes for $a_node_id\n";
      }
      else {
        # print STDERR "$a_node_id -> $t_node_id\n";
        $$ph_a_t{$a_node_id} = $t_node_id;
      }
    }
  }
}

=item create_lists_of_anaphors

  I need for each node to create a list of nodes a bridging arrow goes from to the given node; later on, when bridging
  arrows are created and deleted, the list must be kept up-to-date; it is used in get_value_line_hook to colorize
  some words
  The function is called for each node from the function precompute_file_related_resources, which is called once after a file is opened (or reloaded)
  The hash is kept in the file object to allow more opened files at the same time.

=cut

sub create_lists_of_anaphors {
  my ($node) = @_;
  my $ref_bridging_anaphors = FileUserData('bridging_anaphors');
  # keys = node ids; values = references to arrays of nodes a bridging arrows point from to the given node
  foreach my $coref (ListV($node->attr('bridging'))) { # take all bridging arrows going from the node
    my $target_id = $coref->{'target-node.rf'} || $coref->{'target_node.rf'};
    push @{$ref_bridging_anaphors->{$target_id}}, $node;
  }
  return;
} # create_lists_of_anaphors


=item create_lists_of_coref_text_anaphors

  I need for each node to create a list of nodes a coref_text arrow goes from to the given node; later on, when coref_text
  arrows are created and deleted, the list must be kept up-to-date; it is used in get_value_line_hook to colorize
  some words
  The function is called for each node from the function precompute_file_related_resources, which is called once after a file is opened (or reloaded)
  The hash is kept in the file object to allow more opened files at the same time.

=cut

sub create_lists_of_coref_text_anaphors {
  my ($node) = @_;
  my $ref_coref_text_anaphors = FileUserData('coref_text_anaphors');
  # keys = node ids; values = references to arrays of nodes a coref_text arrows point from to the given node
  foreach my $coref (ListV($node->attr('coref_text'))) { # take all coref_text arrows going from the node
    my $target_id = $coref->{'target-node.rf'} || $coref->{'target_node.rf'};
    push @{$ref_coref_text_anaphors->{$target_id}}, $node;
  }
  return;
} # create_lists_of_coref_text_anaphors



=item create_list_of_bridging_and_coref_text_sources

  Collects sources from all bridging and coref_text arrows at the node.
  The function is called for each node from the function precompute_file_related_resources, which is called once after a file is opened (or reloaded)
  The hash is kept in the file object to allow more opened files at the same time.

=cut

sub create_list_of_bridging_and_coref_text_sources {
  my ($node) = @_;
  my $ref_bridging_and_coref_text_sources = FileUserData('list_of_bridging_and_coref_text_sources');
  # keys = sources of arrows; value = 1 for each (existing) source
  foreach my $coref (ListV($node->attr('bridging'))) { # take all bridging arrows going from the node
    my $source = $coref->{'src'};
    if ($source and length($source)) {
      if (!exists($$ref_bridging_and_coref_text_sources{$source})) {
        # print STDERR "nondeprel_common.mac: create_list_of_bridging_and_coref_text_sources: a bridging source found: '$source'\n";
        $$ref_bridging_and_coref_text_sources{$source} = 1;
      }
    }
  }
  foreach my $coref (ListV($node->attr('coref_text'))) { # take all coref_text arrows going from the node
    my $source = $coref->{'src'};
    if ($source and length($source)) {
      if (!exists($$ref_bridging_and_coref_text_sources{$source})) {
        # print STDERR "nondeprel_common.mac: create_list_of_bridging_and_coref_text_sources: a coref-text source found: '$source'\n";
        $$ref_bridging_and_coref_text_sources{$source} = 1;
      }
    }
  }
  # not necessary: FileUserData('list_of_bridging_and_coref_text_sources', $ref_bridging_and_coref_text_sources);
  return;
} # create_list_of_bridging_and_coref_text_sources



=item create_list_of_discourse_sources

  Collects discourse sources from all discourse arrows at the node.
  The function is called for each node from the function precompute_file_related_resources, which is called once after a file is opened (or reloaded)
  The hash is kept in the file object to allow more opened files at the same time.

=cut

sub create_list_of_discourse_sources {
  my ($node) = @_;
  my $ref_discourse_sources = FileUserData('list_of_discourse_sources');
  # keys = sources of discourse arrows; value = 1 for each (existing) source
  foreach my $coref (ListV($node->attr('discourse'))) { # take all discourse arrows going from the node
    my $source = $coref->{'src'};
    if (defined($source) and length($source)) {
      if (!exists($$ref_discourse_sources{$source})) {
        # print STDERR "nondeprel_common.mac: create_list_of_discourse_sources: a source found: '$source'\n";
        $$ref_discourse_sources{$source} = 1;
      }
    }
  }
  # not necessary: FileUserData('list_of_discourse_sources', $ref_discourse_sources);
  return;
} # create_list_of_discourse_sources



=item create_list_of_groups

  I need to create a hash of representative nodes of groups in the file; later on, when groups
  are created and deleted, the list must be kept up-to-date; it is used to draw discourse arrows
  The function is called for each node from the function precompute_file_related_resources, which is called once after a file is opened (or reloaded)
  The hash is kept in the file object to allow more opened files at the same time.

=cut

sub create_list_of_groups {
  my ($node) = @_;
  my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
  # keys = groups ids; values = representative nodes
  # It takes the node and compares its representativity with the contemporary representative node of the respective group.
  foreach my $group (ListV($node->attr('discourse_groups'))) { # take all discourse groups the node is member of
    my $group_id = $group->{'id'};
    my $prev_representative_node = $$ref_groups_representative_nodes{"$group_id"};
    if (!defined($prev_representative_node)) { # the first found node of the group
      $$ref_groups_representative_nodes{"$group_id"} = $node;
    }
    else { # there already is a contemporary representative node of the group
      if (compare_nodes_representativity($node, $prev_representative_node) == -1) { # the new node is more representative
        $$ref_groups_representative_nodes{"$group_id"} = $node;
      }
    }
  }
  return;
} # create_list_of_groups



=item compare_nodes_representativity($node1, $node2)

  Compares representativity of two nodes in order to choose a node for representing a group of nodes.
  It returns -1 if C<node1> is more representative than C<node2>,
  0 if they are equal,
  1 otherwise.
  Nodes from a tree with a lesser index in the file are more representative than nodes from a tree with a higher index.
  In the same tree, the representativity follows the depth-first-order ("shalower" nodes are more representative).

=cut

sub compare_nodes_representativity ($$) {
  my ($node1, $node2) = @_;
  if ($node1 eq $node2) {
    return 0;
  }
  my ($file1_name, $tree1_index, $file1) = LocateNode($node1);
  my ($file2_name, $tree2_index, $file2) = LocateNode($node2);
  if ($tree1_index != $tree2_index) {
    return ($tree1_index <=> $tree2_index);
  }
  # the nodes are from the same tree
  return (GetNodeIndex($node1) <=> GetNodeIndex($node2));
} # compare_nodes_representativity


=item get_group_representative_node($group_id)

  Returns a node that represents a group with the given id.

=cut

sub get_group_representative_node {
  my ($group_id) = @_;
  my $ph_groups_representative_nodes = FileUserData('groups_representative_nodes');
  # keys = groups ids; values = representative nodes
  if (!exists($$ph_groups_representative_nodes{$group_id})) {
    print STDERR "nondeprel_common.mac: get_group_representative_node: No representative node for group #$group_id!\n";
    return 0;
  }
  return $$ph_groups_representative_nodes{$group_id};
} # get_group_representative_node


my @stored_jumps = (); # an array for storing jumps to antecedents

=item store_jump($id_start, $id_target)

  It stores the jump from the node with id id_start to node with id id_target.
  If id_start does not equal the previously saved id_target, all previously stored
  jumps are removed.

=cut

sub store_jump {
  my ($id_start, $id_target)=@_;
  if (@stored_jumps) { # there is a previously stored jump (one or more)
    my $last_target_id = $stored_jumps[-1];
    if ($last_target_id ne $id_start) { # the chain of jumps has been interrupted
      @stored_jumps = (); # erase the previously stored jumps
    }
  }
  push(@stored_jumps, ($id_start, $id_target));
} # store_jump


=item jump_to_node_id($start_node_id, $target_node_id)

  Jumps from a start node to a target node (both given by their ids); the jumps are stored in a stack and it is possible to jump back

=cut

sub jump_to_node_id {
  my ($start_node_id, $target_node_id) = @_;
  GotoNodeById($target_node_id);
  store_jump($start_node_id, $target_node_id);
} # jump_to_node_id


=item jump_back_from_node()

  If the stack of stored jumps is not empty, it takes the top entry and (if the stored target
  node id equals the current node id) jumps back to the start node.

=cut

sub jump_back_from_node {
  #print "jump_back_from_node\n";
  if (@stored_jumps) { # there is a previously stored jump (one or more)
    my $last_target_id = $stored_jumps[-1];
    if ($this->attr('id') ne $last_target_id) { # the last jump was not to the current node
      return;
    }
    $last_target_id = pop(@stored_jumps);
    my $last_start_id = pop(@stored_jumps);
    GotoNodeById($last_start_id);
  }
} # jump_back_from_node


=item print_nodes_with_order

  Displays nodes in a given list - their t_lemma and deepord

=cut

sub print_nodes_with_order {
  my ($label, @nodes) = @_;
  print "$label\n";
  foreach my $node (@nodes) {
    my ($file_name, $tree_index, $file) = LocateNode($node);
    print $node->attr('t_lemma') . " $tree_index " . $node->attr('deepord') . "\n";
  }
}



# Asks the user for a source of a coref_text or bridging arrow and sets the source of the given arrow
# first argument - the node where the arrow starts
# second argument - the name of the attribute (bridging, coref_text, or discourse)
# third argument - the order of the arrow (there may be several arrows starting here; starting from 1)
# fourth argument - the default value can be taken either from the existing arrow or from FileUserData('annot_src'); the argument can be either 'arrow' or 'stored'
# If the fourth argument is 'stored' and the user enters a value, then the stored value is replaced by the new one. If the entered value is empty, value 'empty_source' is stored (to distinguish from the case when not set at all)
# Returns 1 if the value of the source has been changed
sub source_one_arrow {
  my ($node, $attribute, $position, $default_value_source) = @_;
  my $default_value;
  my $set_default_value = 0;

  my $orig_value = $node->attr($attribute . '/['.($position).']/src');
  if (!$orig_value) {
    $orig_value = '';
  }

  if ($default_value_source eq 'arrow') {
    $default_value = $orig_value;
  }
  else {
    $default_value = FileUserData('annot_src');
    if (!defined($default_value)) {
      $set_default_value = 1;
    }
  }

  if (!defined($default_value)) {
    $default_value = '';
  }

  my $new_value;
  if ($default_value_source eq 'arrow' or $set_default_value eq 1) {
    $new_value = dialog_edit_line("Edit the source of the $attribute arrow", $default_value, "Ok", "Cancel");
  }
  else {
    $new_value = $default_value;
    if ($new_value eq 'empty_source') {
      $new_value = '';
    }
  }

  if ($new_value) {
    $node->set_attr($attribute . '/['.($position).']/src', $new_value);
  }
  else {
    $node->set_attr($attribute . '/['.($position).']/src', undef);
    $new_value = '';
  }

  if ($orig_value ne $new_value or $set_default_value) {
    if (!$new_value) {
      $new_value = 'empty_source';
    }
    FileUserData('annot_src', $new_value);
  }

  if ($orig_value ne $new_value) {
    return 1;
  }
  return 0;
} # source_one_arrow



=item print_a_nodes_with_order

  Displays a-nodes in a given list - their lemma and ord

=cut

sub print_a_nodes_with_order {
  my ($label, @a_nodes) = @_;
  print "$label\n";
  foreach my $a_node (@a_nodes) {
    print $a_node->attr('m/lemma') . " " . $a_node->attr('ord') . "\n";
  }
}



=item is_unfolded_node($node)

  It returns 1 if the given node is one of the manually unfolded nodes.
  Otherwise returns 0.
  The set of manually unfolded nodes is file-specific.

=cut

sub is_unfolded_node {
  my ($node) = @_; # the node to be tested
  my $ref_unfolded_nodes = FileUserData('unfolded_nodes');
  my $index = Index($ref_unfolded_nodes,$node);
  # print STDERR "The node $node has index $index";
  if (defined($index) && $index>=0) { # the node is one of the unfolded nodes
    # print STDERR " - it is unfolded\n";
    return 1;
  }
  # print STDERR " - it is not unfolded\n";
  return 0;
} # is_unfolded_node



=item switch_unfold_actual_node()

  If the actual node is not manually unfolded, it is added to the set of manually unfolded nodes.
  If it is a manually unfolded node, it is removed from the set of manually unfolded nodes.
  The set of manually unfolded nodes is file-specific.

=cut

sub switch_unfold_actual_node {
  switch_unfold_node($this);
  return;
} # switch_unfold_actual_node



=item switch_unfold_node($node)

  If the given node is not manually unfolded, it is added to the set of manually unfolded nodes.
  If it is a manually unfolded node, it is removed from the set of manually unfolded nodes.
  The set of manually unfolded nodes is file-specific.

=cut

sub switch_unfold_node {
  my ($node) = @_;
  if (is_unfolded_node($node)) { # the node is already one of the unfolded nodes
    forget_unfolded_node($node);
    my $clause_head_2_all_clause_nodes = FileUserData('precomputed_clause_segmentation');
    my $saved_clause_head_2_all_clause_nodes = FileUserData('saved_precomputed_clause_segmentation');
    my $node_id_to_clause_head_id = FileUserData('precomputed_clause_head_id');
    if ($saved_clause_head_2_all_clause_nodes->{$node}) {
      foreach my $n (@{$saved_clause_head_2_all_clause_nodes->{$node}}) {
        #print STDERR "a node\n";
        $n->{'is_clause_head'}=0;
        undef($clause_head_2_all_clause_nodes->{$n});
        $node_id_to_clause_head_id->{$n->{id}}=$node->{id};
        $n->{clause_string} = '';
      }
      $clause_head_2_all_clause_nodes->{$node} = $saved_clause_head_2_all_clause_nodes->{$node};
      $node->{'is_clause_head'}=1;
      my @clause_nodes = @{$clause_head_2_all_clause_nodes->{$node}};
      my @tokens = map {$_->attr('m/form')}
                   sort {$a->{ord}<=>$b->{ord}} map {PML_T::GetANodes($_)} @clause_nodes;
      my $length = length(join('',@tokens));
      my $div = int ($length/18); #($length > 3*15) ? 3 : ($length>2*15) ? 2 : 1;
      $node->{clause_string} = join(' ',@tokens);
      $node->{clause_string} =~ s/(.{18,}?)\s/$1\n/g;
    }
  }
  else {
    my $ref_unfolded_nodes = FileUserData('unfolded_nodes');
    # print_nodes_with_order("so far unfolded nodes:", @$ref_unfolded_nodes);
    push(@$ref_unfolded_nodes, $node);
    FileUserData('unfolded_nodes', $ref_unfolded_nodes); # ??? proč tu musí být tenhle řádek ???
    # print_nodes_with_order("after adding another node:", @$ref_unfolded_nodes);
    my $clause_head_2_all_clause_nodes = FileUserData('precomputed_clause_segmentation');
    my $node_id_to_clause_head_id = FileUserData('precomputed_clause_head_id');
    foreach my $n (@{$clause_head_2_all_clause_nodes->{$node}}) {
      #print STDERR "a node\n";
      $clause_head_2_all_clause_nodes->{$n} = [$n];
      $n->{'is_clause_head'}=1;
      $node_id_to_clause_head_id->{$n->{id}}=$n->{id};
      $n->{clause_string} = $n->{'t_lemma'};
    }
  }
  return;
} # switch_unfold_node



=item forget_unfolded_node($node)

  The given node is removed from the set of unfolded nodes.
  The set of unfolded nodes is file-specific.

=cut

sub forget_unfolded_node {
  my ($node) = @_;
  my $ref_unfolded_nodes = FileUserData('unfolded_nodes');
  my $index = Index($ref_unfolded_nodes, $node);
  if (defined($index) && $index>=0) {
    splice(@$ref_unfolded_nodes,$index,1);
  }
  return;
} # forget_unfolded_node


=pod

item forget_all_unfolded_nodes

  The set of unfolded nodes is emptied.
  The set of unfolded nodes is file-specific.

cut

sub forget_all_unfolded_nodes {
  FileUserData('unfolded_nodes',[]);
  return;
} # forget_all_unfolded_nodes

=cut


=item remember_current_single_node()

  Remeberes the current single node using PML_T_Edit->RememberNode; the previously remembered node is forgotten.
  It is a different system of remembering a node than the system of remembering multiple nodes implemented in this extension.
  Used in the "bridging" extension.

=cut

sub remember_current_single_node {
  PML_T_Edit->RememberNode();
}


=item remember_single_node($node)

  Remeberes a given single node using PML_T_Edit->RememberNode; the previously remembered node is forgotten.
  It is a different system of remembering a node than the system of remembering multiple nodes implemented in this extension.
  Used in the "bridging" extension.

=cut

sub remember_single_node {
  my ($node) = @_;
  my $temp = $this;
  $this = $node;
  PML_T_Edit->RememberNode();
  $this = $temp;
}

=item forget_remembered_node()

  Forgets the node remembered by PML_T_Edit->RememberNode().
  It is a different system of remembering a node than the system of remembering multiple nodes implemented in this extension.
  Used in the "bridging" extension.

=cut

sub forget_remembered_node {
  PML_T_Edit->ForgetRemembered();
}


# The following system of remembering multiple nodes differs from the system that uses PML_T_Edit->RememberNode.

=item is_remembered_node($node)

  It returns 1 if the given node is one of the remembered nodes.
  Otherwise returns 0.
  The set of remembered nodes is file-specific.

=cut

sub is_remembered_node {
  my ($node) = @_; # the node to be tested
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  my $index = Index($ref_remembered_nodes,$node);
  # print STDERR "The node $node has index $index";
  if (defined($index) && $index>=0) { # the node is one of the remembered nodes
    # print STDERR " - it is remembered\n";
    return 1;
  }
  # print STDERR " - it is not remembered\n";
  return 0;
} # is_remembered_node



=item is_remembered_a_node($a_node)

  It returns 1 if the given a-node is one of the remembered a-nodes.
  Otherwise returns 0.
  The set of remembered a-nodes is file-specific.

=cut

sub is_remembered_a_node {
  my ($a_node) = @_; # the a-node to be tested
  my $ref_remembered_a_nodes = FileUserData('remembered_a_nodes');
  my $index = Index($ref_remembered_a_nodes,$a_node);
  # print STDERR "The a-node $a_node has index $index";
  if (defined($index) && $index>=0) { # the a-node is one of the remembered a-nodes
    # print STDERR " - it is remembered\n";
    return 1;
  }
  # print STDERR " - it is not remembered\n";
  return 0;
} # is_remembered_a_node



=item is_remembered_group($group_id)

  It returns 1 if the group with the given id is one of the remembered groups.
  Otherwise returns 0.
  The set of remembered groups is file-specific.

=cut

sub is_remembered_group {
  my ($group_id) = @_; # the group id to be tested
  my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
  my $index = Index($ref_remembered_groups_ids,$group_id);
  # print STDERR "The group with the id $group_id has index $index";
  if (defined($index) && $index>=0) { # the group is already one of the remembered groups
    # print STDERR " - it is already remembered\n";
    return 1;
  }
  # print STDERR " - it is not remembered\n";
  return 0;
} # is_remembered_group



=item switch_remember_actual_node_or_group()

  If a group is selected, the function works with the group; otherwise with a selected (~actual) node.
  If the actual node/group is not remembered, it is added to the set of remembered nodes/groups.
  If it is a remembered node/group, it is removed from the set of remembered nodes/groups.
  The set of remembered nodes/groups is file-specific.

=cut

sub switch_remember_actual_node_or_group {
  my $selected_group_id = FileUserData('clicked_group_id');
  if (defined($selected_group_id)) {
    switch_remember_group($selected_group_id);
  }
  else {
    switch_remember_node($this);
  }
  return;
} # switch_remember_actual_node_or_group




=item switch_remember_actual_node()

  If the actual node is not a remembered node, it is added to the set of remembered nodes.
  If it is a remembered node, it is removed from the set of remembered nodes.
  The set of remembered nodes is file-specific.

=cut

sub switch_remember_actual_node {
  switch_remember_node($this);
  return;
} # switch_remember_actual_node



=item switch_remember_node($node)

  If the given node is not a remembered node, it is added to the set of remembered nodes.
  If it is a remembered node, it is removed from the set of remembered nodes.
  The set of remembered nodes is file-specific.

=cut

sub switch_remember_node {
  my ($node) = @_;
  if (is_remembered_node($node)) { # the node is already one of the remembered nodes
    forget_node($node);
  }
  else {
    my $ref_remembered_nodes = FileUserData('remembered_nodes');
    # print_nodes_with_order("so far remembered nodes:", @$ref_remembered_nodes);
    push(@$ref_remembered_nodes, $node);
    FileUserData('remembered_nodes', $ref_remembered_nodes); # ??? proč tu musí být tenhle řádek ???
    # print_nodes_with_order("after adding another node:", @$ref_remembered_nodes);
  }
  return;
} # switch_remember_node



=item switch_remember_a_node($a_node)

  If the given a-node is not a remembered a-node, it is added to the set of remembered a-nodes.
  If it is a remembered a-node, it is removed from the set of remembered a-nodes.
  The set of remembered a-nodes is file-specific.

=cut

sub switch_remember_a_node {
  my ($a_node) = @_;
  if (is_remembered_a_node($a_node)) { # the a-node is already one of the remembered a-nodes
    forget_a_node($a_node);
  }
  else {
    my $ref_remembered_a_nodes = FileUserData('remembered_a_nodes');
    # print_a_nodes_with_order("so far remembered nodes:", @$ref_remembered_a_nodes);
    push(@$ref_remembered_a_nodes, $a_node);
    FileUserData('remembered_a_nodes', $ref_remembered_a_nodes); # ??? proč tu musí být tenhle řádek ???
    # print_a_nodes_with_order("after adding another node:", @$ref_remembered_a_nodes);
  }
  return;
} # switch_remember_a_node



=item switch_remember_group($group_id)

  If the group with the given id is not a remembered group, it is added to the set of remembered groups.
  If it is a remembered group, it is removed from the set of remembered groups.
  The set of remembered groups is file-specific.

=cut

sub switch_remember_group {
  my ($group_id) = @_;
  # print STDERR "Remembering/forgetting group id $group_id\n";
  if (is_remembered_group($group_id)) { # the group is already one of the remembered groups
    forget_group($group_id);
  }
  else {
    my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
    push(@$ref_remembered_groups_ids, $group_id);
    FileUserData('remembered_groups_ids', $ref_remembered_groups_ids); # ??? proč tu musí být tenhle řádek ???
  }
  # my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
  # print STDERR "Remembered group ids: @$ref_remembered_groups_ids\n";
  return;
} # switch_remember_group



=item switch_remember_subtree()

  For all nodes in the subtree of the actual node (including the actual node) do:
  If the node is not a remembered node, it is added to the set of remembered nodes.
  If it is a remembered node, it is removed from the set of remembered nodes.
  The set of remembered nodes is file-specific.

=cut

sub switch_remember_subtree {
  my @subtree_nodes = GetNodes($this);
  foreach my $node (@subtree_nodes) {
    switch_remember_node($node);
  }
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  # print_nodes_with_order("remembered nodes:", @$ref_remembered_nodes);
  return;
} # switch_remember_subtree



=item forget_node($node)

  The given node is removed from the set of remembered nodes.
  The set of remembered nodes is file-specific.

=cut

sub forget_node {
  my ($node) = @_;
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  my $index = Index($ref_remembered_nodes, $node);
  if (defined($index) && $index>=0) {
    splice(@$ref_remembered_nodes,$index,1);
  }
  return;
} # forget_node



=item forget_a_node($a_node)

  The given a-node is removed from the set of remembered a-nodes.
  The set of remembered a-nodes is file-specific.

=cut

sub forget_a_node {
  my ($a_node) = @_;
  my $ref_remembered_a_nodes = FileUserData('remembered_a_nodes');
  my $index = Index($ref_remembered_a_nodes, $a_node);
  if (defined($index) && $index>=0) {
    splice(@$ref_remembered_a_nodes,$index,1);
  }
  return;
} # forget_a_node



=item forget_group($group_id)

  Group with the given id is removed from the set of remembered groups.
  The set of remembered groups is file-specific.

=cut

sub forget_group {
  my ($group_id) = @_;
  my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
  my $index = Index($ref_remembered_groups_ids, $group_id);
  if (defined($index) && $index>=0) {
    splice(@$ref_remembered_groups_ids,$index,1);
  }
  return;
} # forget_group



=item forget_all_remembered_nodes

  The set of remembered nodes is emptied.
  The set of remembered nodes is file-specific.

=cut

sub forget_all_remembered_nodes {
  FileUserData('remembered_nodes',[]);
  FileUserData('remembered_a_nodes',[]);
  return;
} # forget_all_remembered_nodes



=item forget_all_remembered_nodes_and_groups

  The set of remembered nodes and groups is emptied.
  The set of remembered nodes and groups is file-specific.

=cut

sub forget_all_remembered_nodes_and_groups {
  FileUserData('remembered_nodes',[]);
  FileUserData('remembered_a_nodes',[]);
  FileUserData('remembered_groups_ids',[]);
  return;
} # forget_all_remembered_nodes_and_groups


=item is_pure_predecessor($predecessor, $successor)

  Returns 1 if $predecessor is a pure predecessor of $successor in the tree. Otherwise returns 0.
  If $predecessor equals $sucessor, also 0 is returned (that is the meaning of 'pure').

=cut

sub is_pure_predecessor {
  my ($predecessor, $successor) = @_;
  if ($predecessor eq $successor) {return 0}; # it is not pure predecessor - it is the same node
  while ($successor) {
    if ($successor eq $predecessor) {
      return 1;
    }
    $successor = $successor->parent();
  }
  return 0;
} # is_pure_predecessor


=item is_pure_predecessor_safer($predecessor, $successor)

  Returns 1 if $predecessor is a pure predecessor of $successor in the tree or it would be its predecessor
  if the predecessor was not coordinated. Only a simple algorithm is applied to take care of the coordination:
  If $predecessor has is_member=1, then its parent is taken as $predecessor instead of it. Only those $successors
  are taken into account that do not have is_member=1 at the last but one step on the way to $predecessor (it
  excludes subtrees of the other members of the coordination).
  Otherwise returns 0.
  If $predecessor equals $sucessor, also 0 is returned (that is the meaning of 'pure').

=cut

sub is_pure_predecessor_safer {
  my ($predecessor, $successor) = @_;
  if (defined($this->attr('is_member')) && $this->attr('is_member') eq 1) { # $predecessor is coordinated
    my $predecessor_parent = $predecessor->parent(); # it must exist because root cannot have is_member=1
    my $ismember = $successor->attr('is_member');
    $successor = $successor->parent();
    while ($successor) {
      if ($successor eq $predecessor) { # it really was in the subtree of $predecessor
        return 1;
      }
      if ($successor eq $predecessor_parent) {
        if (!$ismember) {
          return 1;
        }
        else {
          return 0;
        }
      }
      $ismember = $successor->attr('is_member');
      $successor = $successor->parent();
    }
    return 0;
  }
  else { # $predecessor is not coordinated
    $successor = $successor->parent();
    while ($successor) {
      if ($successor eq $predecessor) {
        return 1;
      }
      $successor = $successor->parent();
    }
  }
  return 0;
} # is_pure_predecessor_safer



=item compare_target_nodes_positions_deepord

  Compares positions according to the tree number and deepord of the target nodes of the given links.

=cut

# used in the stylesheets
sub compare_target_nodes_positions_deepord ($$) {
  my ($link1, $link2) = @_;
  my $id1 = $link1->{'target-node.rf'};
  my $id2 = $link2->{'target-node.rf'};
  if (!defined($id1)) {
    $id1 = $link1->{'target_node.rf'};
  }
  if (!defined($id2)) {
    $id2 = $link2->{'target_node.rf'};
  }
  if (!$id1) { # possible when there is no target_node.rf - like at the first member of the discourse 'list'
    return 1;
  }
  if (!$id2) { # possible when there is no target_node.rf - like at the first member of the discourse 'list'
    return -1;
  }
  my $node1 = PML::GetNodeByID($id1);
  my $node2 = PML::GetNodeByID($id2);
  return compare_nodes_positions_deepord($node1, $node2);
} # compare_target_nodes_positions_deepord



=item compare_nodes_positions_deepord

  Compares nodes positions according to the tree number and deepord

=cut

sub compare_nodes_positions_deepord ($$) {
  my ($node1, $node2) = @_;
  my ($a_file_name, $a_tree_index, $a_file) = LocateNode($node1);
  my ($b_file_name, $b_tree_index, $b_file) = LocateNode($node2);
  if ($a_tree_index < $b_tree_index) {
    return -1;
  }
  if ($a_tree_index > $b_tree_index) {
    return 1;
  }
  # the nodes are from the same tree, let us compare deepord
  return $node1->attr('deepord') <=> $node2->attr('deepord');
} # compare_nodes_positions_deepord


=item compare_nodes_positions_ord

  Compares nodes positions according to the tree number and ord.

=cut

sub compare_nodes_positions_ord ($$) {
  my ($node1, $node2) = @_;
  my ($a_file_name, $a_tree_index, $a_file) = LocateNode($node1);
  my ($b_file_name, $b_tree_index, $b_file) = LocateNode($node2);
  if ($a_tree_index < $b_tree_index) {
    return -1;
  }
  if ($a_tree_index > $b_tree_index) {
    return 1;
  }
  # the nodes are from the same tree, let us compare ord
  return get_node_lex_ord($node1) <=> get_node_lex_ord($node2);
} # compare_nodes_positions_ord



=item find_closest_node_in_coref_chain($start_node, $target_node)

  If there is a coreference (textual or grammatical) chain from a node to the target node, it finds the node
  in the chain that is closest to the start node (left from it) and returns it; otherwise, it returns the given target node
  This function takes node order into account; it only searches for anaphors that are between the given start end target nodes.
  The start node is a node where a coreference is meant to start
  The target node is a node where the coreference is originally ment to end
  The function searches for the first node in the chain of anaphor nodes (starting at the target node) but
  only between the start and target nodes.
  The order of the nodes is based on the surface order of their surface counterparts; if the nodes do not have
  a surface counterpart, deepord is used.

=cut

sub find_closest_node_in_coref_chain {
  my ($start, $target) = @_; # the start node and the target node
  # print "find_closest_node_in_coref_chain: start node id = $start->{'id'}, target node id = $target->{'id'}\n";
  my $actual_target = $target;
  while (my $node = find_coref_anaphor_with_restriction($start, $actual_target)) { # repeat searching for the previous node in the chain
    $actual_target = $node;
  }
  # print "find_first_node_in_coref_chain: new target node id = $actual_target->{'id'}\n";
  return $actual_target;
} # find_closest_node_in_coref_chain


=item find_coref_anaphor_with_restriction($start_node, $target_node)

  If there is a textual or grammatical coreference from a node to the given node, it returns it (only one of them, if there are several); otherwise, it returns null
  This function takes node order into account; it only searches for an anaphor that is between the given start end target node;
  The start node is a node where a coreference is meant to start
  The target node is a node where the coreference is originally ment to end
  The function searches for an anaphor node of the target node between the start and target nodes.
  The order of the nodes is based on the surface order of their surface counterparts; if the nodes do not have
  a surface counterpart, deepord is used.

=cut

sub find_coref_anaphor_with_restriction {
  my ($start, $target) = @_; # the start node and the target node
  my $target_id = $target->{id};
  my ($dummy1, $start_tree_number, $dummy2) = LocateNode($start);
  my ($dummy3, $target_tree_number, $dummy4) = LocateNode($target);
  my $start_node_ord = get_node_lex_ord($start);
  my $target_node_ord = get_node_lex_ord($target);
  # print "find_coref_anaphor: start tree number = $start_tree_number, target tree number = $target_tree_number\n";
  # print "find_coref_anaphor: start node ord = $start_node_ord, target node ord = $target_node_ord\n";

  my $tree_number = 0;
  foreach my $tree (GetTrees()) { # take all trees in the file
    $tree_number ++;
    next if (!between_numbers($tree_number, $start_tree_number, $target_tree_number)); # consider only trees lying between the trees of the start node and the target node
    foreach my $node (GetNodes($tree)) { # take all nodes in the trees
      my $node_ord = get_node_lex_ord($node);
      next if (!between_positions($tree_number, $start_tree_number, $target_tree_number, $node_ord, $start_node_ord, $target_node_ord)); # consider only nodes lying between the start node and the target node
      foreach my $coref (ListV($node->{'coref_text'})) { # take all textual coreferences going from the node
        my $coref_target_id = $coref->{'target-node.rf'} || $coref->{'target_node.rf'};
        if ($coref_target_id eq $target_id) { # there is a textual coreference from $node to $target
          return $node;
        }
      }
      foreach my $coref_id (ListV($node->{'coref_gram.rf'})) { # take all grammatical coreferences going from the node
        if ($coref_id eq $target_id) { # there is a grammatical coreference from $node to $target
          return $node;
        }
      }
    }
  }
  return 0;
} # find_coref_anaphor_with_restriction



=item get_node_lex_ord($node)

  Returns C<ord> of the lexical counterpart of the C<node>; if it does not have a lexical counterpart, it is called recursively
  on the parent node. Returns zero if called on an undefined value.

=cut

sub get_node_lex_ord {
  my ($node) = @_;
  if (!$node) {
    return 0;
  }
  my $node_lex_id = $node->attr('a/lex.rf');
  if ($node_lex_id) {
    my $a_node = PML_T::GetANodeByID($node_lex_id);
    if ($a_node) {
      my $node_lex_ord = $a_node->attr('ord');
      return $node_lex_ord;
    }
  }
  return get_node_lex_ord($node->parent);
} # get_node_lex_ord



=item between_numbers($tested_number, $number_1, $number_2)

  Returns 1 if $tested_number is between $number_1 and $number_2 (including the boundaries); otherwise returns 0

=cut

sub between_numbers {
  my ($tested_number, $number_1, $number_2) = @_;
  if ($number_2 <= $number_1) {
    if ($tested_number >= $number_2 && $tested_number <= $number_1) {
      return 1;
    }
  }
  else {
    if ($tested_number <= $number_2 && $tested_number >= $number_1) {
      return 1;
    }
  }
  return 0;
} # between_numbers


=item between_positions($tested_tree_number, $tree_1_number, $tree_2_number, $tested_node_number, $node_1_number, $node_2_number)

  Returns 1 if $tested_node_number is between $node_start and $node_target; otherwise returns 0.
  If the tested node number equals one of the border numbers, it is still considered between them.
  It works based on given order numbers, which may be deepord, ord, or anything else.

=cut

sub between_positions {
  my ($tested_tree_number, $tree_1_number, $tree_2_number, $tested_node_number, $node_1_number, $node_2_number) = @_;

  if ($tree_2_number < $tree_1_number) {
    if ($tested_tree_number < $tree_2_number) {
      return 0;
    }
    if ($tested_tree_number == $tree_2_number) {
      if ($tested_node_number < $node_2_number) {
        return 0;
      }
    }
    if ($tested_tree_number > $tree_1_number) {
      return 0;
    }
    if ($tested_tree_number == $tree_1_number) {
      if ($tested_node_number > $node_1_number) {
        return 0;
      }
    }
    return 1;
  }

  if ($tree_2_number > $tree_1_number) {
    if ($tested_tree_number > $tree_2_number) {
      return 0;
    }
    if ($tested_tree_number == $tree_2_number) {
      if ($tested_node_number > $node_2_number) {
        return 0;
      }
    }
    if ($tested_tree_number < $tree_1_number) {
      return 0;
    }
    if ($tested_tree_number == $tree_1_number) {
      if ($tested_node_number < $node_1_number) {
        return 0;
      }
    }
    return 1;
  }

  # now $tree_2_number == $tree_1_number
  if ($tested_tree_number != $tree_2_number) {
    return 0;
  }
  if ($node_2_number < $node_1_number) {
    if ($tested_node_number <= $node_2_number) {
      return 0;
    }
    if ($tested_node_number >= $node_1_number) {
      return 0;
    }
    return 1;
  }
  if ($node_2_number > $node_1_number) {
    if ($tested_node_number > $node_2_number) {
      return 0;
    }
    if ($tested_node_number < $node_1_number) {
      return 0;
    }
    return 1;
  }
  return 0; # $node_2_number == $node_1_number
} # between_positions



=item find_coref_anaphor($node)

  If there is a coreference (textual or grammatical) from a node to the given node,
  it returns it (only one of them, if there are several); otherwise, it returns null.
  It goes through all nodes in the file and tests if it is the anaphor.

=cut

sub find_coref_anaphor {
  my ($target) = @_; # the target node
  my $target_id = $target->{id};
  foreach my $tree (GetTrees()) { # take all trees in the file
    foreach my $node (GetNodes($tree)) { # take all nodes in the trees
      foreach my $coref (ListV($node->{'coref_text'})) { # take all textual coreferences going from the node
        my $coref_target_id = $coref->{'target-node.rf'} || $coref->{'target_node.rf'};
        if ($coref_target_id eq $target_id) { # there is a textual coreference from $node to $target
	        return $node;
        }
	    }
      foreach my $coref_id (ListV($node->{'coref_gram.rf'})) { # take all grammatical coreferences going from the node
        if ($coref_id eq $target_id) { # there is a grammatical coreference from $node to $target
	        return $node;
        }
      }
    }
  }
  return 0;
} # find_coref_anaphor


=item find_coref_text_anaphor($node)

  If there is a textual coreference from a node to the given node,
  it returns it (only one of them, if there are several); otherwise, it returns null.
  It goes through all nodes in the file and tests if it is the anaphor.

=cut

sub find_coref_text_anaphor {
  my ($target) = @_; # the target node
  my $target_id = $target->{id};
  foreach my $tree (GetTrees()) { # take all trees in the file
    foreach my $node (GetNodes($tree)) { # take all nodes in the trees
      foreach my $coref (ListV($node->{'coref_text'})) { # take all textual coreferences going from the node
        my $coref_target_id = $coref->{'target-node.rf'} || $coref->{'target_node.rf'};
        if ($coref_target_id eq $target_id) { # there is a textual coreference from $node to $target
	        return $node;
        }
	    }
    }
  }
  return 0;
} # find_coref_text_anaphor


=item find_coref_gram_anaphor($node)

  If there is a grammatical coreference from a node to the given node,
  it returns it (only one of them, if there are several); otherwise, it returns null.
  It goes through all nodes in the file and tests if it is the anaphor.

=cut

sub find_coref_gram_anaphor {
  my ($target) = @_; # the target node
  my $target_id = $target->{id};
  foreach my $tree (GetTrees()) { # take all trees in the file
    foreach my $node (GetNodes($tree)) { # take all nodes in the trees
      foreach my $coref_id (ListV($node->{'coref_gram.rf'})) { # take all grammatical coreferences going from the node
        if ($coref_id eq $target_id) { # there is a grammatical coreference from $node to $target
	        return $node;
        }
      }
    }
  }
  return 0;
} # find_coref_gram_anaphor



=item connected_with_coref_chain($start_node, $target_node)

  Returns 1 if there is a coreferential (textual or grammatical) chain from
  $start_node to $target_node (length 0 permited); otherwise returns 0.

=cut

sub connected_with_coref_chain {
  my ($start_node, $target_node) = @_;
  if ($start_node eq $target_node) {
    return 1;
  }
  my @coreferential_successors = get_list_coref($start_node,0);
  my $index = Index(\@coreferential_successors, $target_node);
  if (defined($index) && $index>=0) {
    return 1;
  }
  return 0;
} # connected_with_coref_chain



# written by Petr Pajas to make sure that a click on a node in a context tree changes the
# actual tree and the actual sentence

# previously, there was this implementation of the hook:
#     my $tw = GUI()->{framegroup}{valueLine}; # text widget
#     main::update_value_line(GUI()->{framegroup});

sub current_node_change_hook {
  my ($node)=@_;
  my $r=$node->root;

  # print STDERR "current_node_change_hook\n";
  # a node was selected, therefore unselect the selected group (if a group was selected and the selected node is not its representative node)
  my $clicked_group_id = FileUserData('clicked_group_id');
  if (defined($clicked_group_id)) {
    my $representative_node = get_group_representative_node($clicked_group_id);
    if ($representative_node ne $node) { # the representative node of the selected group is not equal to the current node
      # print STDERR "current_node_change_hook: forgetting selection of a group...\n";
      FileUserData('clicked_group_id', undef);
      FileUserData('clicked_group_number', undef);
    }
  }

  if ($r == $root) { # the same tree

    # store the node's current position in the window
    my $c = $grp->treeView->canvas;
    my ($x,$y) = map $grp->treeView->get_node_pinfo($node,$_), qw(XPOS YPOS); # coordinates of the selected node
    my ($xv,$yv)=(
      $c->xviewCoord($x), # translate to window position
      $c->yviewCoord($y)
    );

    $this = $node;
    # Redraw();
    # since we do not want to call Redraw (which is slow), we need to redraw the sentences:
    main::update_value_line(GUI()->{framegroup});

    # adjust the view so that the node appears on the exact same place
    ($x,$y)=map $grp->treeView->get_node_pinfo($node,$_), qw(XPOS YPOS);
    $c->xviewCoord($x,$xv); # restore window position
    $c->yviewCoord($y,$yv);

    return;
  }

  # the clicked node is not from the same tree
  my @trees=GetTrees();
  for my $i (0..$#trees) {
    if ($trees[$i]==$r) {
      # store the node's current position in the window
      my $c = $grp->treeView->canvas;
      my ($x,$y) = map $grp->treeView->get_node_pinfo($node,$_), qw(XPOS YPOS); # coordinates of the selected node
      my ($xv,$yv)=(
        $c->xviewCoord($x), # translate to window position
        $c->yviewCoord($y)
      );

      TredMacro::GotoTree($i+1);
      $this=$node;
      Redraw();

      # adjust the view so that the node appears on the exact same place
      ($x,$y)=map $grp->treeView->get_node_pinfo($node,$_), qw(XPOS YPOS);
      $c->xviewCoord($x,$xv); # restore window position
      $c->yviewCoord($y,$yv);
      return;
    }
  }

} # current_node_change_hook



my $pa_colors=["#CF9", "#FDA", "#9FF", "#FAF", "#AFA", "#AAF", "#FAA"];

my $ref_array_groups_sorted;

sub after_redraw_hook {

  PML_T::after_redraw_hook(); # cleans up after DrawCorefArrows

  # print STDERR "after_redraw_hook\n";

  if (CurrentFile() && get_display_discourse_arrows()) {

    return if !defined $root; # no warnings when using Tred's "reload current file" button

    my %groups;
    #for my $node ($root,$root->descendants) {
    for my $node (GetDisplayedNodes()) {
      my @node_groups = ListV($node->attr('discourse_groups'));
      foreach my $node_group (@node_groups) {
        my $group = $node_group->{'id'};
        if (defined $group) {
          push (@{$groups{$group}}, $node);
        }
      }
    }

    my @groups_ids = keys %groups;
    if (@groups_ids) { # there are groups on the screen

      my @array_groups_sorted_ids = sort {$a<=>$b} @groups_ids;
      my @a_colors;
      my $ord=0;
      my $number_of_colors=scalar(@$pa_colors);
      foreach my $group_id (@array_groups_sorted_ids) { # define colors for the displayed groups based on their ids
        $a_colors[$ord]=$$pa_colors[$group_id % $number_of_colors];
        $ord++;
      }
      my $ref_array_groups_sorted = [ map { $groups{$_} } @array_groups_sorted_ids ];
      # save the displayed groups ids for subsequent identification of a group clicked on:
      FileUserData('displayed_groups_sorted_ids', \@array_groups_sorted_ids);
      # let us change the color of the selected group (if any is selected)
      my $clicked_group_number = FileUserData('clicked_group_number');
      if (defined($clicked_group_number)) { # if a group has been clicked on
        $a_colors[$clicked_group_number-1] = "yellow"; # set special color for the group
      }
      # let us change the color of the remembered groups
      my $pa_remembered_groups_ids = FileUserData('remembered_groups_ids');
      foreach my $i (0..(scalar(@array_groups_sorted_ids)-1)) {
        my $group_id = $array_groups_sorted_ids[$i];
        my $index = Index($pa_remembered_groups_ids,$group_id);
        if (defined($index) && $index>=0) {
          # print STDERR "Changing color for group id=$group_id, number=$index\n";
          $a_colors[$i] = "red"; # set special color for the group;
        }
      }
      my $pa_stipples = TrEd::NodeGroups::dense_stipples($grp);
      TrEd::NodeGroups::draw_groups(
          $grp,
          $ref_array_groups_sorted,
          {
              colors  => \@a_colors,
              stipples => $pa_stipples,
              x_shift => 0,
          }
      );
      eval { $grp->treeView->realcanvas->raise('point','group_line'); }; # to allow clicking on nodes in groups
    }

    # to allow clicking on the groups:

    my $canvas = $grp->treeView->realcanvas;
    # unless we bound Button1 click on group before, do it now:
    unless ($canvas->bind('group_line','<1>')) {
      $canvas->bind('group_line', '<1>', MacroCallback('group_clicked'));
    }
  # different bindings can be added for <Shift-1>, <Control-1>,
  # <2>, etc...
  } # groups

  return;
} # after_redraw_hook



sub group_clicked {
  # print STDERR "group_clicked\n";
  my $canvas = $grp->treeView->realcanvas;
  # print "User clicked on a group with the following tags:", join(',',$canvas->gettags('current')),"\n";

  my @tags = $canvas->gettags('current');
  my @tag = grep(/group_no_/,@tags);
  if (@tag != 1) {
    print STDERR "Error in the function group_clicked - non or multiple group numbers!\n";
    print STDERR "First group number: " . $tag[0];
    return;
  }

  my $group_number = $tag[0];
  $group_number =~ s/group_no_//;
  # print "group number = $group_number\n";
  my $group_array_index = $group_number - 1;
  my $ref_array_groups_sorted_ids = FileUserData('displayed_groups_sorted_ids');
  my $clicked_group_id = $$ref_array_groups_sorted_ids[$group_array_index];
  # print "group id = $clicked_group_id\n";
  FileUserData('clicked_group_id', $clicked_group_id);
  FileUserData('clicked_group_number', $group_number);

  my $clicked_group_representative_node = get_group_representative_node($clicked_group_id);

  my ($file_name, $tree_index, $file) = LocateNode($clicked_group_representative_node);

  TredMacro::GotoTree($tree_index);
  $this=$clicked_group_representative_node;

  ChangingFile(0);
  # $Redraw='none';
} # group_clicked


sub switch_hiding_src {
  my $hide = ((FileUserData('switch_hiding_src') or 0) + 1) % 2;
  FileUserData('switch_hiding_src',$hide);
  # print STDERR "Switch hiding src: $hide\n";
}

sub get_hiding_src {
  # print STDERR "get_hiding_src: " . FileUserData('switch_hiding_src') . "\n";
  my $hide = FileUserData('switch_hiding_src');
  if (!defined($hide)) {
    $hide = 0;
  }
  return $hide;
}



# -------------------------------------------------
# support functions for scripts
# -------------------------------------------------


=item get_analytical_counterparts_ids_from_id

  Given an id of a t-node, it returns the array of a-nodes ids that are the analytical counterparts of the t-node.

=cut

sub get_analytical_counterparts_ids_from_id {
  my ($t_node_id) = @_;
  my $t_node = PML::GetNodeByID($t_node_id);
  return get_analytical_counterparts_ids_from_node($t_node);
}

=item get_analytical_counterparts_ids_from_node

  Given a t-node, it returns the array of a-nodes ids that are the analytical counterparts of the t-node.

=cut

sub get_analytical_counterparts_ids_from_node {
  my ($t_node) = @_;
  my @all_rf = ();
  if (defined($t_node)) {
    my $lex_rf = $t_node->attr('a/lex.rf');
    my @auxs_rf = ListV($t_node->attr('a/aux.rf'));
    push (@all_rf, $lex_rf);
    push (@all_rf, @auxs_rf);
  }
  return @all_rf;
}

=item get_sentence

  Given a t-node, it returns the surface representation of the sentence the t-node belongs to.

=cut

sub get_sentence {
  my ($t_node) = @_;
  my $sentence = "";
  if (defined($t_node)) {
    $sentence = PML_T::GetSentenceString($t_node->root);
  }
  return $sentence;
}

=item is_member_of_array

  Given a scalar and an array, it checks whether the scalar is a member of the array.
  Returns 1 if it is, otherwise returns 0.

=cut

sub is_member_of_array {
  my ($m, @ar) = @_;
  foreach my $a (@ar) {
    # print STDERR "is_member_of_array: checking $m against $a\n";
    if ($m eq $a) {
      return 1;
    }
  }
  return 0;
}

=item is_predecessor

  Given two nodes, it checks whether the first one is a predecessor in the tree of the second one.
  Returns 1 if it is, otherwise returns 0.

=cut

sub is_predecessor {
  my ($pred, $succ) = @_;
  if ($succ eq $pred) {
    return 1;
  }
  while ($succ = $succ->parent) {
    if ($succ eq $pred) {
      return 1;
    }
  }
  return 0;
}


=item get_e_descendants

  Given a t-node, it returns its effective descendants (incl. the node).

=cut

sub get_e_descendants {
  my ($t_root) = @_;
  my @e_descendants = ($t_root);
  my @e_children = PML_T::GetEChildren($t_root);
  foreach my $e_child (@e_children) {
    push (@e_descendants, GetENodes($e_child));
  }
  return @e_descendants;
}

=item is_finite_verb

  Given a t-node, it checks whether it is a finite verb or not. It searches for a finite verb among all analytical counterparts of the t-node (neurcitek, prechodnik a pricesti trpne tu za finitni nepocitame).
  Returns 1 if it is, otherwise returns 0.

=cut

sub is_finite_verb { # vrati 1, pokud mezi vsemi analytickymi protejsky najde finitni sloveso (neurcitek, prechodnik a pricesti trpne tu za finitni nepocitame); jinak vrati 0
  my ($t_node) = @_;
  # print STDERR "is_finite_verb: node " . $t_node->attr('id') . " (" . $t_node->attr('t_lemma') . ")\n";
  my @anals = get_analytical_counterparts_ids_from_node($t_node);
  foreach my $a_node_id (@anals) {
    my $a_node = PML_T::GetANodeByID($a_node_id);
    if ($a_node) {
      my $tag = $a_node->attr('m/tag');
      if ($tag and $tag =~ /^V[Bipqt]/) {
        return 1;
      }
    }
  }
  return 0;
}

=item switch

  Given references to two variables, it switches the contents of the variables.

=cut

sub switch {
  my ($ref_1, $ref_2) = @_;
  my $temp = $$ref_1;
  $$ref_1 = $$ref_2;
  $$ref_2 = $temp;
}


=item jump_to_next_lemma

  Finds the next node with the same t_lemma and changes the current node to it

=cut

sub jump_to_next_lemma {
  my $t_lemma = $this->attr('t_lemma');
  # first, search in the actual tree
  my $next_node = get_next_node_with_t_lemma($root, $this->attr('deepord'), $t_lemma);
  if ($next_node) {
    $this = $next_node;
  }
  else { # second, search in the following trees
    my $tree_number = CurrentTreeNumber();
    my @trees = GetTrees();
    my $last_tree_index = scalar(@trees)-1;
    for (my $t = $tree_number+1; $t<=$last_tree_index; $t++) {
      $next_node = get_next_node_with_t_lemma($trees[$t], 0, $t_lemma);
      if ($next_node) {
        TredMacro::GotoTree($t + 1);
        $this=$next_node;
        last;
      }
    }
  }
}

=item jump_to_previous_lemma

  Finds the previous node with the same t_lemma and changes the current node to it

=cut

sub jump_to_previous_lemma {
  my $t_lemma = $this->attr('t_lemma');
  # first, search in the actual tree
  my $previous_node = get_previous_node_with_t_lemma($root, $this->attr('deepord'), $t_lemma);
  if ($previous_node) {
    $this = $previous_node;
  }
  else { # second, search in the pevious trees
    my $tree_number = CurrentTreeNumber();
    my @trees = GetTrees();
    for (my $t = $tree_number-1; $t>=0; $t--) {
      $previous_node = get_previous_node_with_t_lemma($trees[$t], 1000, $t_lemma);
      if ($previous_node) {
        TredMacro::GotoTree($t + 1);
        $this=$previous_node;
        last;
      }
    }
  }
}

# Returns the first node with the same t_lemma in the deepord order in the given tree, starting at deepord=start+1
sub get_next_node_with_t_lemma {
  my ($r, $start, $t_lemma) = @_;
  my @nodes = sort {$a->attr('deepord') <=> $b->attr('deepord')} grep {$_->attr('deepord') > $start} GetNodes($r);
  foreach my $node (@nodes) {
    if ($node->attr('t_lemma') && $t_lemma eq $node->attr('t_lemma')) {
      return $node;
    }
  }
  return undef;
}

# Returns the first node with the same t_lemma in the reverse deepord order in the given tree, starting at deepord=start-1
sub get_previous_node_with_t_lemma {
  my ($r, $start, $t_lemma) = @_;
  my @nodes = sort {$b->attr('deepord') <=> $a->attr('deepord')} grep {$_->attr('deepord') < $start} GetNodes($r);
  foreach my $node (@nodes) {
    if ($node->attr('t_lemma') && $t_lemma eq $node->attr('t_lemma')) {
      return $node;
    }
  }
  return undef;
}



1;
} # package

=item Changelog since 20090410

20090410: Created.
20090420: Many functions moved here from bridging.mac and discourse.mac.
20090422: An empty line can now separate paragraps in the neighboring sentences.
20090429: Corrected an error in node_style_hook - grammatical and complement arrows now work.
20090511: A new function compare_nodes_positions_ord compares nodes according to their surface order.
20090513: A click on a node in a context tree selects the new actual tree and sentence (current_node_change_hook, written by Petr Pajas).
          Function set_hash_ref_print_in_italics($hash_ref) allows setting t_lemmas that should
          be displayd in italics in the sentences.
20090521: Groups of nodes can be displayed.
20090609: File-specific and extension-specific (bridging, discourse) data are stored using FileUserData.
20090619: Arrows from various sources (attr. src) can be displayed separately.
20090819: Individual folded nodes can be unfolded and folded again (function switch_unfold_node).
20090826: Connectors can be set and displayed (a popup hint when hovering over an arrow).
          Arrows that have the same target are all visible now (have different trajectories).
20090827: Hints of discourse arrows, bridging arrows and coref-text arrows have been added/enriched.
20090828: Speed-ups in clicking on nodes in the same tree. A GUI fix - trees do not jump so much on the screen.
20091012: Function between_positions has been changed: The order of the tested node can be equal to one of the border nodes and still is considered to by between them.
20091019: Color in the sentences of the words connected with textual coreference can be different from the color of the arrows.
20091215: Analytical nodes can be remembered (by Ctrl+clicking on a word in the sentences) in order to be then set as connectors.
20091216: The current node does not change when analytical nodes are remembered (by Ctrl+clicking on a word in the sentences).
20091221: A possibility to enable/disable remembering multiple nodes and remembering single words has been added.
20100120: Nodes without analytical counterparts (like #Neg) use their t_lemma in the surface form of the connector.
20100216: Ongoing transition to the new discourse schema.
20100219: First version working with the new discourse schema.
20100614: Words that correspond to the nodes in the subtree of the selected node are highlited in the sentences.
20100617: Coordination is taken into account in highliting subtree nodes in the sentences.
20100917: If a group is selected (clicked on), only words that belong to the group are highlighted in the sentences (not the whole subtree of the representative node).
20101126: Function get_surface_connector changed so that it works well for connectives from more than one tree.
20110621: Words in the sentences are hilighted according to the selected source.
20120320: If a generated node (typically #PersPron) that is a son of a non-generated node is selected, analytical counterparts of its father are highlighted in the sentence.
20120321: Function source_one_arrow moved here.
20120322: Fix in value_line_click_hook - now a single click on a word in sentences once again selects the word and node, even in the same sentence
20120423: Support for displaying the translated sentence (for PEDT data) in get_value_line_hook
20120727: Added some support functions often used in scripts
20120802: Words that have no t-counterpart can be highlighted in sentences (remembered) and used as connectors.
20130205: Words that form connectives of discourse arrows starting at the current node are highlighted in the sentences.

=cut

