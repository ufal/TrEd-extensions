# -*- cperl -*-

# Makras for TrEd for annotating bridging anaphora and textual coreference links
# Initial bridging support by Zdenek Zabokrtsky, zabokrtsky at ufal.mff.cuni.cz
# Initial support for textual coreference added by Mirek Tynovsky
# Subsequent cleanup by Petr Pajas, pajas at ufal.mff.cuni.cz
# Further changes by Jiri Mirovsky (with much help from Petr Pajas), mirovsky at ufal.mff.cuni.cz

{

package PML_T_Bridging;
BEGIN { import NonDepRel_Common; }
#binding-context PML_T_Bridging

#include <contrib/support/unbind_edit.inc>

#bind PML_T->AnalyticalTree to Ctrl+A menu Display corresponding analytical tree

#bind remember_current_single_node to space
#bind forget_remembered_node to f

#bind switch_display_bridging_arrows to Ctrl+b menu Switch displaying bridging arrows
#bind switch_display_coref_text_arrows to Ctrl+t menu Switch displaying text-coref arrows
#bind switch_display_coref_gram_arrows to Ctrl+g menu Switch displaying gram-coref arrows
#bind switch_display_discourse_arrows to Ctrl+d menu Switch displaying discourse arrows
#bind select_bridging_and_coref_text_source to s menu Select source
#bind switch_hiding_src to S menu Switch hiding source
#bind Toggle3rdLine to Ctrl+a menu Toggle displaying ontologic information (PEDT)
#bind jump_to_next_lemma to Ctrl+Up menu Next same t_lemma
#bind jump_to_previous_lemma to Ctrl+Down menu Previous same t_lemma
#bind toggle_exoph to e menu Toggle exophora
#bind toggle_segm to s menu Toggle coref to segment
#bind PML_T_Edit->AddNode to Insert menu Insert New Node
#bind PML_T_Edit->DeleteNode to Delete menu Delete Node
#bind PML_T_Edit->RotateMember to m menu Change is_member

#use vars qw($this $root $grp);
use strict;
use warnings;
no warnings qw(redefine);

my $neigboring_sentences_before = 20;
my $neigboring_sentences_after = 20;

my $neigboring_trees_before = 2;
my $neigboring_trees_after = 0;

my $selected_arrow_index = 0;

unshift @TredMacro::AUTO_CONTEXT_GUESSING, sub {
  my ($hook)=@_;
  my $resuming = ($hook eq 'file_resumed_hook');
  my $current = CurrentContext();
  if ( (FileMetaData('schema-url') || '') =~ /tdata_25_discourse_schema\.xml/ ) {
    SetCurrentStylesheet('PML_T_25_Bridging') if $resuming;
    return 'PML_T_Bridging';
  }
  if ( (FileMetaData('schema-url') || '') =~ /tdata_25_schema_bridging\.xml/ ) {
    SetCurrentStylesheet('PML_T_25_Bridging') if $resuming;
    return 'PML_T_Bridging';
  }
  if ( (FileMetaData('schema-url') || '') =~ /tdata_schema_bridging\.xml/ ) {
    SetCurrentStylesheet('PML_T_Bridging') if $resuming;
    return 'PML_T_Bridging';
  }
  if ( (FileMetaData('schema-url') || '') =~ /tdata_eng_schema\.xml/ ) {
    SetCurrentStylesheet('PML_T_Bridging') if $resuming;
    return 'PML_T_Bridging';
  }
  return;
};

sub file_opened_hook {
  return unless CurrentFile();
  print STDERR "file opened hook\n";
  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1});
} # file_opened_hook

sub file_reloaded_hook {
  return unless CurrentFile();
  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1});
} # file_reloaded_hook

sub switch_context_hook {
  NonDepRel_Common::switch_context_hook(@_); # do what NonDepRel_Common context wants to do...
  PML_T::CreateStylesheets();
  set_paragraph_separator("\n");
  EnableMinorMode('Show_Neighboring_Sentences');
  SetMinorModeData('Show_Neighboring_Sentences', 'context_before', $neigboring_sentences_before);
  SetMinorModeData('Show_Neighboring_Sentences', 'context_after', $neigboring_sentences_after);
  # DisableMinorMode('Show_Neighboring_Trees'); # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  as JP wished !!!!!!!!!!!!!!!!!!!!!!!!!!!+
  SetMinorModeData('Show_Neighboring_Trees', 'context_before', $neigboring_trees_before);
  SetMinorModeData('Show_Neighboring_Trees', 'context_after', $neigboring_trees_after);
  set_display_coref_gram_arrows(1);
  set_display_coref_text_arrows(1);
  set_display_bridging_arrows(1);
  set_display_complement_arrows(1);
  set_display_discourse_arrows(0);
  set_show_discourse_arrow_type(0);
  set_show_discourse_arrow_comment(0);
  set_show_discourse_node_comment(0);
  set_show_bridging_arrow_type(1);
  set_show_coref_text_arrow_type(1);
  set_mode_remember_nodes('SINGLE');
  set_enable_remember_words(0);
  set_color_coref_text_line('#81bd0d'); # sort of green color instead of dark blue in the sentences - easier to spot
  set_hash_ref_print_in_italics({ "zdejší" => 1, "místní" => 1, "tamní" => 1});
  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1});
  if (GUI()) {
    SetCurrentStylesheet('PML_T_25_Bridging');
    Redraw();
  }

=item
  
  if (GUI()) {
    if ( (FileMetaData('schema-url') || '') =~ /tdata_25_discourse_schema\.xml/ ) {
      SetCurrentStylesheet('PML_T_25_Bridging');
    }
    if ( (FileMetaData('schema-url') || '') =~ /tdata_25_schema_bridging\.xml/ ) {
      SetCurrentStylesheet('PML_T_25_Bridging');
    }
    if ( (FileMetaData('schema-url') || '') =~ /tdata_schema_bridging\.xml/ ) {
      SetCurrentStylesheet('PML_T_Bridging');
    }
    if ( (FileMetaData('schema-url') || '') =~ /tdata_eng_schema\.xml/ ) {
      SetCurrentStylesheet('PML_T_Bridging');
    }
    Redraw();
  }
  
=cut  
  
  return;
}

#bind init_bridging_schema to i menu Init bridging attributes
sub init_bridging_schema {
  return unless CurrentFile();
  if (FileMetaData('schema-url')!~/tdata_25_schema_bridging\.xml/) {
    FileMetaData('schema-url','tdata_25_schema_bridging.xml'); # set schema
    CurrentFile()->notSaved(1); # make sure TrEd asks to save the file (or we could Save() it here)
    ReloadCurrentFile(); # reload the file with the new schema
  }
  ChangingFile(0);
}


#bind switch_displaying_context_trees to u menu Switch displaying context trees
sub switch_displaying_context_trees {
  if (IsMinorModeEnabled('Show_Neighboring_Trees')) {
    DisableMinorMode('Show_Neighboring_Trees');
  }
  else {
    EnableMinorMode('Show_Neighboring_Trees');
  }
} # switch_displaying_context_trees

#bind toggle_displaying_context_sentences to E menu Toggle displaying context sentences
sub toggle_displaying_context_sentences {
  my $display = ((FileUserData('toggle_context_sentences') or 0) + 1) % 4;
  FileUserData('toggle_context_sentences',$display);
  print STDERR "toggle_context_sentences: $display\n";
  if ($display eq 0) {
    DisableMinorMode('Show_Neighboring_Sentences');
  }
  elsif ($display eq 1) {
    EnableMinorMode('Show_Neighboring_Sentences');
    SetMinorModeData('Show_Neighboring_Sentences', 'context_before', 5);
    SetMinorModeData('Show_Neighboring_Sentences', 'context_after', 5);
  }
  elsif ($display eq 2) {
    EnableMinorMode('Show_Neighboring_Sentences');
    SetMinorModeData('Show_Neighboring_Sentences', 'context_before', 20);
    SetMinorModeData('Show_Neighboring_Sentences', 'context_after', 20);
  }
  else {
    EnableMinorMode('Show_Neighboring_Sentences');
    SetMinorModeData('Show_Neighboring_Sentences', 'context_before', 100);
    SetMinorModeData('Show_Neighboring_Sentences', 'context_after', 100);
  }
} # toggle_displaying_context_sentences


#bind toggle_displaying_translation to n menu Toggle displaying translation
sub toggle_displaying_translation {
  my $display = ((FileUserData('toggle_translation') or 0) + 1) % 3;
  FileUserData('toggle_translation',$display);
  print STDERR "toggle_translation: $display\n";
} # toggle_displaying_translation


#bind toggle_highlighting_coref_words to p menu Toggle highlighting coref words
sub toggle_highlighting_coref_words {
  my $display = ((FileUserData('toggle_highlighting_coref_words') or 0) + 1) % 2;
  FileUserData('toggle_highlighting_coref_words',$display);
  print STDERR "toggle_highlighting_coref_words: $display\n";
} # toggle_highlighting_coref_words


#bind jump_back_from_node to z menu Jump back from antecedent

#bind jump_to_the_antecedent_of_the_first_arrow to a menu Jump to the antecedent (1st arrow)
sub jump_to_the_antecedent_of_the_first_arrow {
  print "jump_to_the_antecedent_of_the_first_arrow\n";
  my $original_node_id = $this->attr('id');
  my @antecedents = map(($_->{'target-node.rf'} or $_->{'target_node.rf'}), ListV($this->{bridging}));
  push (@antecedents, map(($_->{'target-node.rf'} or $_->{'target_node.rf'}), ListV($this->{coref_text})));

  if (@antecedents) {
    my $first_antecedent_id = $antecedents[0];
    # print "jump_to_the_antecedent_of_the_first_arrow: antecedent id = $first_antecedent_id\n";
    jump_to_node_id($original_node_id, $first_antecedent_id);
  }
}

#bind jump_to_the_antecedent_of_the_second_arrow to q menu Jump to the antecedent (2nd arrow)
sub jump_to_the_antecedent_of_the_second_arrow {
  print "jump_to_the_antecedent_of_the_second_arrow\n";
  my $original_node_id = $this->attr('id');
  my @antecedents = map(($_->{'target-node.rf'} or $_->{'target_node.rf'}), ListV($this->{bridging}));
  push (@antecedents, map(($_->{'target-node.rf'} or $_->{'target_node.rf'}), ListV($this->{coref_text})));

  if (@antecedents && scalar(@antecedents)>=2) {
    my $second_antecedent_id = $antecedents[1];
    # print "jump_to_the_antecedent_of_the_second_arrow: antecedent id = $second_antecedent_id\n";
    jump_to_node_id($original_node_id, $second_antecedent_id);
  }
}

=item something for JP

# The following function is a copy from nondeprel_common.mac; this copy offers a default value JP (as JP is the only annotator for bridging anaphora now)
# ----------------------
# Asks the user for a source of a coref_text or bridging arrow and sets the source of the given arrow
# first argument - the node where the arrow starts
# second argument - the name of the attribute (bridging, coref_text, or discourse)
# third argument - the order of the arrow (there may be several arrows starting here; starting from 1)
# fourth argument - the default value can be taken either from the existing arrow or from FileUserData('annot_src'); the argument can be either 'arrow' or 'stored'
# If the fourth argument is 'stored' and the user enters a value, then the stored value is replaced by the new one. If the entered value is empty, value 'empty_source' is stored (to distinguish from the case when not set at all)
# Returns 1 if the value of the source has been changed
sub source_one_arrow {
  my ($node, $attribute, $position, $default_value_source) = @_;
  my $default_value;
  my $set_default_value = 0;

  my $orig_value = $node->attr($attribute . '/['.($position).']/src');
  if (!$orig_value) {
    $orig_value = '';
  }

  if ($default_value_source eq 'arrow') {
    $default_value = $orig_value;
  }
  else {
    $default_value = FileUserData('annot_src');
    if (!defined($default_value)) {
      $set_default_value = 1;
    }
  }

  if (!defined($default_value)) {
    $default_value = '';
  }

  my $new_value;
  if ($default_value_source eq 'arrow') {
    $new_value = dialog_edit_line("Edit the source of the $attribute arrow", $default_value, "Ok", "Cancel");
  }
  elsif ($set_default_value eq 1) {
    $new_value = dialog_edit_line("Edit the source of the $attribute arrow", "JP", "Ok", "Cancel"); # this is the difference from the original version of the function
  }
  else {
    $new_value = $default_value;
    if ($new_value eq 'empty_source') {
      $new_value = '';
    }
  }

  if ($new_value) {
    $node->set_attr($attribute . '/['.($position).']/src', $new_value);
  }
  else {
    $node->set_attr($attribute . '/['.($position).']/src', undef);
    $new_value = '';
  }

  if ($orig_value ne $new_value or $set_default_value) {
    if (!$new_value) {
      $new_value = 'empty_source';
    }
    FileUserData('annot_src', $new_value);
  }

  if ($orig_value ne $new_value) {
    return 1;
  }
  return 0;
} # source_one_arrow

=cut

#bind add_bridging_arrow to b menu Add bridging arrow
sub add_bridging_arrow {
  #print "add_bridging_arrow\n";
  if($PML_T_Edit::remember and $PML_T_Edit::remember->parent and $this->parent) {
    # if there is a textual coreference from a node to the target node, find the first node in the chain and point to it instead to the target node:
    my $first_node_in_chain = find_closest_node_in_coref_chain($this, $PML_T_Edit::remember);
    my $target_node_id = $first_node_in_chain->attr('id');
    AddToList($this,'bridging', {'target-node.rf' => $target_node_id, 'target_node.rf' => $target_node_id});
    my @arrows = ListV($this->{bridging});
    my $position = @arrows; # the position of the added arrow
    my $ok;
    if ( (FileMetaData('schema-url') || '') =~ /tdata_eng_schema\.xml/ ) { # annotation of the English part of PCEDT
      $this->set_attr('bridging/['.($position).']/informal-type','SUB_SET');
      $this->set_attr('bridging/['.($position).']/type','SUB_SET');
    }
    elsif ( (FileMetaData('schema-url') || '') =~ /tanot_(coref_)?schema\.xml/ ) { # annotation of PDTSC or the Czech part of PCEDT
      $this->set_attr('bridging/['.($position).']/informal-type','SUB_SET');
      $this->set_attr('bridging/['.($position).']/type','SUB_SET');
    }
    else {
      $ok=type_one_bridging_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
      if (!$ok) { # cancel - remove the added arrow
        @{$this->{bridging}} = map {$this->{bridging}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{bridging}});
        return;
      }
    }
    $ok=source_one_arrow($this, 'bridging', $position, 'stored'); # take the stored value or ask the user for the source and set it at the arrow given by $position
    add_to_bridging_anaphors($target_node_id, $this);
    # forget_remembered_node();
    ChangingFile(1);
  }
}


#bind add_coref_gram_arrow to g menu Add gram-coref arrow
sub add_coref_gram_arrow {
  #print "add_coref_gram_arrow\n";
  if($PML_T_Edit::remember and $PML_T_Edit::remember->parent and $this->parent){
    # if there is a textual coreference from a node to the target node, find the first node in the chain and point to it instead to the target node:
    my $first_node_in_chain = find_closest_node_in_coref_chain($this, $PML_T_Edit::remember);
    # now I need to check if I am not in the middle of an existing coreference chain (to be used later)
    my $anaphora_node = find_coref_anaphor($first_node_in_chain);
    # let us add the coreference arrow now
    AddToList($this,'coref_gram.rf', $first_node_in_chain->{'id'});
    # PML_T_Edit->ForgetRemembered();
    # now let us re-create the coreferential chain (if there was one) including the newly added node
    if ($anaphora_node) { # we may need to point from the anaphora node to the actually added node
      my ($dummy1, $anaphora_tree_number, $dummy2) = LocateNode($anaphora_node);
      my ($dummy3, $target_tree_number, $dummy4) = LocateNode($first_node_in_chain);
      my ($dummy5, $start_tree_number, $dummy6) = LocateNode($this);
      my $anaphora_node_ord = get_node_lex_ord($anaphora_node);
      my $start_node_ord = get_node_lex_ord($this);
      my $target_node_ord = get_node_lex_ord($first_node_in_chain);

      if (between_positions($start_tree_number, $anaphora_tree_number, $target_tree_number, $start_node_ord, $anaphora_node_ord, $target_node_ord)) {
        redirect_text_or_gram_coref_arrow($anaphora_node, $first_node_in_chain, $this->{id});
      }
    }
    ChangingFile(1);
  }
}


#bind add_coref_text_arrow to t menu Add text-coref arrow
sub add_coref_text_arrow {
  #print "add_coref_text_arrow\n";
  if($PML_T_Edit::remember and $PML_T_Edit::remember->parent and $this->parent){
    # if there is a textual coreference from a node to the target node, find the first node in the chain and point to it instead to the target node:
    my $first_node_in_chain = find_closest_node_in_coref_chain($this, $PML_T_Edit::remember);
    # now I need to check if I am not in the middle of an existing coreference chain (to be used later)
    my $anaphora_node = find_coref_anaphor($first_node_in_chain);
    # let us add the coreference arrow now
    AddToList($this,'coref_text', {'target-node.rf' => $first_node_in_chain->{'id'}, 'target_node.rf' => $first_node_in_chain->{'id'}});
    my $position = ListV($this->{coref_text}); # the position of the added arrow
    $this->set_attr('coref_text/['.($position).']/informal-type',"SPEC"); # the most common type
    $this->set_attr('coref_text/['.($position).']/type',"SPEC"); # the most common type
    my $ok;
    if ( (FileMetaData('schema-url') || '') =~ /tdata_eng_schema\.xml/ ) { # annotation of the English part of PCEDT
      $this->set_attr('coref_text/['.($position).']/informal-type','SPEC');
      $this->set_attr('coref_text/['.($position).']/type','SPEC');
    }
    elsif ( (FileMetaData('schema-url') || '') =~ /tanot_(coref_)?schema\.xml/ ) { # annotation of PDTSC or the Czech part of PCEDT
      $this->set_attr('coref_text/['.($position).']/informal-type','SPEC');
      $this->set_attr('coref_text/['.($position).']/type','SPEC');
    } 
    else {
      $ok=type_one_coref_text_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
      if (!$ok) { # cancel - remove the added arrow
        @{$this->{coref_text}} = map {$this->{coref_text}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{coref_text}});
        return;
      }
    }
    $ok=source_one_arrow($this, 'coref_text', $position, 'stored'); # take the stored value or ask the user for the source and set it at the arrow given by $position
    add_to_coref_text_anaphors($first_node_in_chain->attr('id'), $this);
    # PML_T_Edit->ForgetRemembered();
    # now let us re-create the coreferential chain (if there was one) including the newly added node
    if ($anaphora_node) { # we may need to point from the anaphora node to the actually added node
      my ($dummy1, $anaphora_tree_number, $dummy2) = LocateNode($anaphora_node);
      my ($dummy3, $target_tree_number, $dummy4) = LocateNode($first_node_in_chain);
      my ($dummy5, $start_tree_number, $dummy6) = LocateNode($this);
      my $anaphora_node_ord = get_node_lex_ord($anaphora_node);
      my $start_node_ord = get_node_lex_ord($this);
      my $target_node_ord = get_node_lex_ord($first_node_in_chain);

      if (between_positions($start_tree_number, $anaphora_tree_number, $target_tree_number, $start_node_ord, $anaphora_node_ord, $target_node_ord)) {
        redirect_text_or_gram_coref_arrow($anaphora_node, $first_node_in_chain, $this->{id});
      }
    }
    ChangingFile(1);
  }
}


#bind add_coref_text_chain to Ctrl+h menu Add text-coref chain
sub add_coref_text_chain {
  my $t_lemma = $this->attr('t_lemma');

  # ask for the type
  my $selected_type;
  my $not_canceled = ask_for_coref_text_type(\$selected_type, "");
  if (!$not_canceled) { # if canceled
    return;
  }

  my @trees = GetTrees();
  my @nodes_with_t_lemma = ();
  foreach my $root (@trees) {
    my @nodes = grep($_->attr('t_lemma') && $_->attr('t_lemma') eq $t_lemma,GetNodes($root));
    push (@nodes_with_t_lemma, @nodes);
  }
  # print_nodes_with_order("before sorting", @nodes_with_t_lemma);
  # sort the nodes with the same t_lemma according to the tree number and ord (if surface counterparts do not exist, then deepord)
  my @nodes_sorted = sort compare_nodes_positions_ord @nodes_with_t_lemma;
  # print_nodes_with_order("after sorting", @nodes_sorted);
  # now I have the nodes with the given lemma sorted; let us start adding the arrows
  my $size = @nodes_sorted - 1;
  for (my $i=0; $i<$size; $i++) {
    my $target = $nodes_sorted[$i];
    my $start = $nodes_sorted[$i+1];
    batch_add_coref_text_arrow($start, $target, $selected_type);
  }
  ChangingFile(1);
} # add_coref_text_chain


sub batch_add_coref_text_arrow {
  my ($start, $target, $type) = @_;
  if (connected_with_coref_chain($start, $target)) {
    return;
  }
  # if there is a textual coreference from a node to the target node, find the first node in the chain and point to it instead of to the target node:
  my $first_node_in_chain = find_closest_node_in_coref_chain($start, $target);
  # now I need to check if I am not in the middle of an existing coreference chain (to be used later)
  my $anaphora_node = find_coref_anaphor($first_node_in_chain);
  # let us add the coreference arrow now
  AddToList($start,'coref_text', {'target-node.rf' => $first_node_in_chain->{'id'}, 'target_node.rf' => $first_node_in_chain->{'id'}});
  my $position = ListV($start->{coref_text}); # the position of the added arrow
  $start->set_attr('coref_text/['.($position).']/informal-type',$type); # the most common type
  $start->set_attr('coref_text/['.($position).']/type',$type); # the most common type
  my $ok=source_one_arrow($start, 'coref_text', $position, 'stored'); # take the stored value or ask the user for the source and set it at the arrow given by $position
  #type_one_coref_text_arrow($start, $position); # ask the user for the type and set it at the arrow given by $position
  #PML_T_Edit->ForgetRemembered();
  # now let us re-create the coreferential chain (if there was one) including the newly added node
  add_to_coref_text_anaphors($first_node_in_chain->{'id'}, $start);
  if ($anaphora_node) { # we may need to point from the anaphora node to the actually added node
    my ($dummy1, $anaphora_tree_number, $dummy2) = LocateNode($anaphora_node);
    my ($dummy3, $target_tree_number, $dummy4) = LocateNode($first_node_in_chain);
    my ($dummy5, $start_tree_number, $dummy6) = LocateNode($start);
    my $anaphora_node_ord = get_node_lex_ord($anaphora_node);
    my $start_node_ord = get_node_lex_ord($start);
    my $target_node_ord = get_node_lex_ord($first_node_in_chain);
    if (between_positions($start_tree_number, $anaphora_tree_number, $target_tree_number, $start_node_ord, $anaphora_node_ord, $target_node_ord)) {
      redirect_text_or_gram_coref_arrow($anaphora_node, $first_node_in_chain, $this->{id});
    }
  }
  ChangingFile(1);
}

sub toggle_exoph {
  if ($this->attr('coref_special') and $this->attr('coref_special') eq 'exoph') {
    $this->set_attr('coref_special',undef);
  }
  else {
    $this->set_attr('coref_special','exoph');
  }
  ChangingFile(1);
} # toggle_exoph

sub toggle_segm {
  if ($this->attr('coref_special') and $this->attr('coref_special') eq 'segm') {
    $this->set_attr('coref_special',undef);
  }
  else {
    $this->set_attr('coref_special','segm');
  }
  ChangingFile(1);
} # toggle_segm


#bind add_coref_special_arrow to v menu Add special coref arrow
sub add_coref_special_arrow {
  #print "add_coref_special_arrow\n";
  my $prev_value = $this->attr('coref_special');
  if (!defined($prev_value)) {
    $prev_value = "";
  }
  my $pa_possible_types = ['', 'exoph', 'segm'];
  my @selection = ($prev_value);
  ListQuery("Enter a special link",'browse',$pa_possible_types,\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_value = $selection[0];
  # print "Selected value: $selected_value\n";
  $this->set_attr('coref_special',$selected_value);
  if ($prev_value ne $selected_value) {
    ChangingFile(1);
  }
} # add_coref_special_arrow



# Returns a list of bridging links and textual-coreferential links going from the given node
sub existing_links_bridging_and_coref_text {
  my ($node) = @_;
  my $i = 0;
  my @values;

  foreach my $link (ListV($node->{bridging})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target-node.rf'} or $link->{'target_node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    push @values, "BRIDGING: ($i) t_lemma=$node_tlemma  type=". ($link->{'informal-type'} or $link->{'type'});
  }

  foreach my $link (ListV($node->{coref_text})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target-node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    push @values, "TEXTUAL: ($i) t_lemma=$node_tlemma  type=". ($link->{'informal-type'} or $link->{'type'} or ' ');
  }

  return @values;
} # existing_links_bridging_and_coref_text


# Returns a list of bridging links and textual-coreferential links and grammatical-coreferential links going from the given node
sub existing_links_bridging_and_coref_text_and_gram {
  my ($node) = @_;
  my @values = existing_links_bridging_and_coref_text($node);
  my $i = scalar(@values);

  foreach my $gram_target (ListV($node->{'coref_gram.rf'})) {
    $i++;
    my $node = PML::GetNodeByID($gram_target);
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    push @values, "GRAMMATICAL: ($i) t_lemma=$node_tlemma";
  }

  return @values;
} # existing_links_bridging_and_coref_text_and_gram


# Returns a list of bridging links going from the current node
sub existing_links_bridging {
  my ($node) = @_;
  my $i;
  my @values;

  foreach my $link (ListV($node->{bridging})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target-node.rf'} or $link->{'target_node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    push @values, "($i) t_lemma=$node_tlemma  type=". ($link->{'informal-type'} or $link->{'type'});
  }
  return @values;
}

# Returns a list of textual-coreferential links going from the current node
sub existing_links_coref_text {
  my ($node) = @_;
  my $i;
  my @values;

  foreach my $link (ListV($node->{coref_text})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target-node.rf'} or $link->{'target_node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    push @values, "($i) t_lemma=$node_tlemma  type=". ($link->{'informal-type'} or $link->{'type'});
  }
  return @values;
}


# Returns a list of possible types of the bridging link
sub possible_types_bridging {
  my $type = PML::Schema()->find_type_by_path('!bridging-link.type/informal-type');
  if (!$type) {
    $type = PML::Schema()->find_type_by_path('!bridging_link.type/informal-type');
  }
  if (!$type) {
    $type = PML::Schema()->find_type_by_path('!t-bridging-link.type/informal-type');
  }
  if (!$type) {
    $type = PML::Schema()->find_type_by_path('!t-bridging-link.type/type');
  }
  if (!$type) {
    $type = PML::Schema()->find_type_by_path('!t-bridging-type.type');
  }
  my @values = $type->get_values();
  # ("CONTRAST","SUB_SET","SET_SUB","PART_WHOLE","WHOLE_PART","FUNCT_P","P_FUNCT","REST");
  unshift(@values,("")); # ("","CONTRAST","SUB_SET","SET_SUB","PART_WHOLE","WHOLE_PART","FUNCT_P","P_FUNCT","REST");
  return @values;
} # possible_types_bridging

# Returns a list of possible types of the textual coreference
sub possible_types_coref_text {
  # my @values = PML::Schema()->find_type_by_path('!coref_text-link.type/informal-type')->get_values();
  # ("NR","SYN","ER");
  # unshift(@values,("")); # ("","NR","SYN","ER");
  my @values = ("SPEC", "GEN");
  return @values;
} # possible_types_coref_text


#bind remove_bridging_or_coreferential_arrow to x menu Remove bridging or coreferential arrow
sub remove_bridging_or_coreferential_arrow {
  # print "remove_bridging_or_coreferential_arrow\n";

  my @arrows_bridging = ListV($this->{'bridging'});
  my @arrows_coref_text = ListV($this->{'coref_text'});
  my @arrows_coref_gram = ListV($this->{'coref_gram.rf'});

  my $orig_target_id = 0;

  if (@arrows_bridging == 0 && @arrows_coref_text == 0 && @arrows_coref_gram == 0) {
    print "No bridging or coreferential arrow to be removed!\n";
  }

  elsif (@arrows_bridging + @arrows_coref_text + @arrows_coref_gram == 1) {

    if (@arrows_bridging == 1) {
      my $target_node_id = $arrows_bridging[0]->{'target-node.rf'} || $arrows_bridging[0]->{'target_node.rf'};
      $this->{'bridging'}=List();
      remove_from_bridging_anaphors($target_node_id, $this);
    }
    elsif (@arrows_coref_text == 1) {
	  $orig_target_id = $arrows_coref_text[0]->{'target-node.rf'} || $arrows_coref_text[0]->{'target_node.rf'};
      $this->{'coref_text'}=List();
      remove_from_coref_text_anaphors($orig_target_id, $this);
    }
    elsif (@arrows_coref_gram == 1) {
	  $orig_target_id = $arrows_coref_gram[0];
      $this->{'coref_gram.rf'}=List();
    }

    ChangingFile(1);
    # print "The (only one) bridging or coreferential arrow has been removed!\n";
  }

  else {
    my @selection;
    ListQuery("Link to remove",'browse',[existing_links_bridging_and_coref_text_and_gram($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # my $total = existing_links_bridging_and_coref_text_and_gram($this);
    # print STDERR "The selected position is $position (out of $total)\n";
    # print STDERR "There are " . scalar(@arrows_bridging) . " bridging arrows.\n";
    # print STDERR "There are " . scalar(@arrows_coref_text) . " coref_text arrows.\n";
    # print STDERR "There are " . scalar(@arrows_coref_gram) . " coref_gram arrows.\n";

    if ($position <= @arrows_bridging) { # the selected arrow is from the first part of the list - a bridging arrow
        my $target_node_id = $arrows_bridging[$position-1]->{'target-node.rf'} || $arrows_bridging[$position-1]->{'target_node.rf'};
        @{$this->{bridging}} = map {$this->{bridging}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{bridging}});
        remove_from_bridging_anaphors($target_node_id, $this);
        # print "A bridging arrow ($position) has been removed\n";
    }
    elsif ($position <= (@arrows_bridging + @arrows_coref_text)) { # the selected arrow is from the second part of the list - a textual coreference
        $position -= @arrows_bridging;
        $orig_target_id = $arrows_coref_text[$position]->{'target-node.rf'} || $arrows_coref_text[$position]->{'target_node.rf'};
        @{$this->{coref_text}} = map {$this->{coref_text}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{coref_text}});
        remove_from_coref_text_anaphors($orig_target_id, $this);
        # print "A text-coref arrow ($position) has been removed\n";
    }
    else { # the selected arrow is from the third part of the list - a grammatical coreference
        $position -= (@arrows_bridging + @arrows_coref_text);
        $orig_target_id = $arrows_coref_gram[$position];
        @{$this->{'coref_gram.rf'}} = map {$this->{'coref_gram.rf'}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{'coref_gram.rf'}});
        # print "A gram-coref arrow ($position) has been removed\n";
    }
    ChangingFile(1);
  }
  # now, if a coreference was removed and another textual coreference goes to this node, let us ask the user
  # if it should be connected (thus, the actual node would be removed from the chain and the chain remains interconnected)
  if ($orig_target_id) { # a textual coreference was removed
    my $anaphora_node = find_coref_text_anaphor($this);
    if ($anaphora_node) { # if there is an anaphora
      my $anaphora_id = $anaphora_node->{id};
      my $anaphora_tlemma = $anaphora_node->{t_lemma};
      my $orig_target_tlemma = PML::GetNodeByID($orig_target_id)->{t_lemma};
      my $target_1_label = "the actual node: t_lemma = '" . $this->{t_lemma} . "', id = '" . $this->{id} . "'";
      my $target_2_label = "the target of the removed arrow: t_lemma = '" . $orig_target_tlemma . "', id = '" . $orig_target_id . "'";
      my @selection = ($target_1_label);
      my $title = "Re-connect the chain? Choose the target node of the anaphora with t_lemma = '" . $anaphora_tlemma . "', id = '" . $anaphora_id . "'";
      my @new_target_list = ($target_1_label, $target_2_label);
      ListQuery($title,'browse',[@new_target_list],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
      my $selected_type = $selection[0];
      if ($selected_type eq $target_2_label) { # the link needs to be changed
        redirect_text_coref_arrow($anaphora_node, $this, $orig_target_id);
      }
    }
  }
} # remove_bridging_or_coreferential_arrow

sub redirect_text_coref_arrow {
  my ($start_node, $orig_target_node, $new_target_id) = @_;
  my @start_arrows_coref_text = ListV($start_node->{coref_text});
  my $position = 1;
  foreach my $arrow (@start_arrows_coref_text) { # find the text-coreferential arrow going to the orig target node
    if (($arrow->{'target-node.rf'} or $arrow->{'target_node.rf'}) eq $orig_target_node->{id}) {
      $start_node->set_attr('coref_text/['.($position).']/target-node.rf',$new_target_id);
      $start_node->set_attr('coref_text/['.($position).']/target_node.rf',$new_target_id);
      remove_from_coref_text_anaphors($orig_target_node->attr('id'), $start_node);
      add_to_coref_text_anaphors($new_target_id, $start_node);
      ChangingFile(1);
    }
    $position++;
  }
} # redirect_text_coref_arrow

sub redirect_text_or_gram_coref_arrow {
  my ($start_node, $orig_target_node, $new_target_id) = @_;
  my @start_arrows_coref_text = ListV($start_node->{coref_text});
  my $position = 1;
  foreach my $arrow (@start_arrows_coref_text) { # find the text-coreferential arrow going to the orig target node
    if (($arrow->{'target-node.rf'} or $arrow->{'target_node.rf'}) eq $orig_target_node->{id}) {
      $start_node->set_attr('coref_text/['.($position).']/target-node.rf',$new_target_id);
      $start_node->set_attr('coref_text/['.($position).']/target_node.rf',$new_target_id);
      remove_from_coref_text_anaphors($orig_target_node->attr('id'), $start_node);
      add_to_coref_text_anaphors($new_target_id, $start_node);
      ChangingFile(1);
      return;
    }
    $position++;
  }
  # if there was no textual coreference going to the orig target node, let us try the grammatical coreference
  #my @start_arrows_coref_gram = ListV($start_node->{'coref_gram.rf'});
  #$position = 1;
  #foreach my $arrow_id (@start_arrows_coref_gram) { # find the gram-coreferential arrow going to the orig target node
  #  if ($arrow_id eq $orig_target_node->{id}) {
  #    $start_node->set_attr('coref_gram.rf/['.($position).']',$new_target_id);
  #    ChangingFile(1);
  #    return;
  #  }
  #  $position++;
  #}
} # redirect_text_or_gram_coref_arrow

# Asks the user for the type of the bridging arrow and sets the type of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several bridging arrows starting here; starting from 1)
sub type_one_bridging_arrow {
  my ($node, $position) = @_;
  my $prev_type = $this->attr('bridging/['.($position).']/informal-type') or $this->attr('bridging/['.($position).']/type');
  my @selection = ($prev_type);
  ListQuery("Type of the link",'browse',[possible_types_bridging()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_type = $selection[0];
  # print "Selected type: $selected_type\n";
  $this->set_attr('bridging/['.($position).']/informal-type',$selected_type);
  $this->set_attr('bridging/['.($position).']/type',$selected_type);
  return 1;
}

# Asks the user for the type of the text arrow and sets the type of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several text arrows starting here; starting from 1)
sub type_one_coref_text_arrow {
  my ($node, $position) = @_;
  my $prev_type = $this->attr('coref_text/['.($position).']/informal-type') or $this->attr('coref_text/['.($position).']/type');
  my $selected_type;
  my $not_canceled = ask_for_coref_text_type(\$selected_type, $prev_type);
  if (!$not_canceled) { # if canceled
    return 0;
  }
  # print "Selected type: $selected_type\n";
  $this->set_attr('coref_text/['.($position).']/informal-type',$selected_type);
  $this->set_attr('coref_text/['.($position).']/type',$selected_type);
  return 1;
}

# Asks the user for the type of the text arrow
# first argument - a reference to a scalar where the selected value will be put to
# second argument - the default value (it will be highlighted in the selection window)
# returns 1 if the user selected a value
# returns 0 if the user pressed "Cancel"
sub ask_for_coref_text_type {
  my ($ref_ret_value, $default) = @_;
  my @selection = ($default);
  ListQuery("Type of the link",'browse',[possible_types_coref_text()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  $$ref_ret_value = $selection[0];
  return 1;
} # ask_for_coref_text_type


#bind type_bridging_or_coref_text_arrow to r menu (Re-)type bridging or text-coref arrow
sub type_bridging_or_coref_text_arrow {
  print "type_bridging_or_coref_text_arrow\n";

  my @arrows_bridging = ListV($this->{bridging});
  my @arrows_coref_text = ListV($this->{coref_text});

  my $changed = 0;

  if (@arrows_bridging == 0 && @arrows_coref_text == 0) {
    print "No bridging or text-coref arrow to be (re-)typed!\n";
  }

  elsif (@arrows_bridging + @arrows_coref_text == 1) {

    if (@arrows_bridging == 1) {
      $changed = type_one_bridging_arrow($this, 1); # ask the user for the type and set it at the first (the only one) arrow
    }
    elsif (@arrows_coref_text == 1) {
      $changed = type_one_coref_text_arrow($this, 1); # ask the user for the type and set it at the first (the only one) arrow
    }
    if ($changed) {
      ChangingFile(1);
      print "The (only one) bridging or text-coref arrow has been (re-)typed!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to (re-)type",'browse',[existing_links_bridging_and_coref_text($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_bridging_and_coref_text($this);
    if ($position <= @arrows_bridging) { # the selected arrow is from the first part of the list - a bridging arrow
      print "(Re-)typing the bridging arrow at position $position\n";
      $changed = type_one_bridging_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
      if ($changed) {
        print "A bridging arrow ($position) was (re-)typed\n";
      }
    }
    else { # the selected arrow is from the second part of the list - a textual coreference
      $position -= @arrows_bridging;
      print "(Re-)typing the text-coref arrow at position $position\n";
      $changed = type_one_coref_text_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
      if ($changed) {
        print "A text-coref arrow ($position) was (re-)typed\n";
      }
    }
    ChangingFile(1);
  }
} # type_bridging_or_coref_text_arrow


#bind comment_an_arrow to M menu Comment an arrow
sub comment_an_arrow {
  # print STDERR "comment_an_arrow\n";

  my @arrows_bridging = ListV($this->{bridging});
  my @arrows_coref_text = ListV($this->{coref_text});

  my $changed = 0;

  if (@arrows_bridging == 0 && @arrows_coref_text == 0) {
    print STDERR "No bridging or text-coref arrow to be commented!\n";
  }

  elsif (@arrows_bridging + @arrows_coref_text == 1) {

    if (@arrows_bridging == 1) {
      $changed = comment_one_arrow($this, 'bridging', 1); # ask the user for the comment and set it at the first (the only one) arrow
    }
    elsif (@arrows_coref_text == 1) {
      $changed = comment_one_arrow($this, 'coref_text', 1); # ask the user for the comment and set it at the first (the only one) arrow
    }
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) bridging or text-coref arrow has been commented!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to comment",'browse',[existing_links_bridging_and_coref_text($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_bridging_and_coref_text($this);
    if ($position <= @arrows_bridging) { # the selected arrow is from the first part of the list - a bridging arrow
      # print STDERR "Commenting the bridging arrow at position $position\n";
      $changed = comment_one_arrow($this, 'bridging', $position); # ask the user for the comment and set it at the arrow given by $position
      if ($changed) {
        # print STDERR "A bridging arrow ($position) has been commented\n";
        ChangingFile(1);
      }
    }
    else { # the selected arrow is from the second part of the list - a textual coreference
      $position -= @arrows_bridging;
      # print STDERR "Commenting the text-coref arrow at position $position\n";
      $changed = comment_one_arrow($this, 'coref_text', $position); # ask the user for the comment and set it at the arrow given by $position
      if ($changed) {
        # print STDERR "A text-coref arrow ($position) has been commented\n";
        ChangingFile(1);
      }
    }
  }
} # comment_an_arrow


# Asks the user for a comment of a coref_text or bridging arrow and sets the source of the given arrow
# first argument - the node where the arrow starts
# second argument - the name of the attribute (bridging or coref_text)
# third argument - the order of the arrow (there may be several arrows starting here; starting from 1)
sub comment_one_arrow {
  my ($node, $attribute, $position) = @_;
  my @list=possible_types_comment();
  my $unstructured_label = 'unstructured multi-line';
  unshift(@list, ($unstructured_label));
  my $dialog=[$list[0]];
  ListQuery('Select a comment type', 'browse', \@list, $dialog) or return;
  my $comment_name = $dialog->[0];
  if ($comment_name eq $unstructured_label) { # the unstructured comment was selected
    my $old_value = $node->attr($attribute . '/['.($position).']/comment');
    my $new_value = dialog_edit_text_area ("Edit the comment of the $attribute arrow", $old_value, "Ok", "Cancel");
    if ($new_value) {
      $node->set_attr($attribute . '/['.($position).']/comment', $new_value);
    }
    else {
      $node->set_attr($attribute . '/['.($position).']/comment', undef);
    }
    return 1;
  }
  else { # a structured comment was selected
    my $text = QueryString('Enter a comment text', 'Comment:');
    return 0 unless defined $text;
    my %comment = (name=>$comment_name, comment=>$text);
    AddToList($node, $attribute . '/['.($position).']/str_comment', \%comment);
    return 1;
  }
}

#bind edit_node_comment to Alt+c menu Edit a node comment
sub edit_node_comment {
  ChangingFile(EditAttribute($this, 'anaph_str_comment'));
} # edit_node_comment

#bind add_node_comment to c menu Add a node comment
sub add_node_comment {
  my @list=possible_types_comment();
  my $dialog=[$list[0]];
  ListQuery('Select a comment type', 'browse', \@list, $dialog) or return;
  my $text = QueryString('Enter a comment text', 'Comment:');
  return unless defined $text;
  my %comment = (name=>$dialog->[0], comment=>$text);
  AddToList($this, 'anaph_str_comment', \%comment);
} # add_node_comment

# Returns a list of possible types of a comment
sub possible_types_comment {
  my $type = PML::Schema()->find_type_by_path('!anaph_str_comment.type/name');
  my @values = $type->get_values();
  # unshift(@values,(""));
  return @values;
} # possible_types_comment



#bind source_an_arrow to o menu Set source of an arrow
sub source_an_arrow {
  # print STDERR "source_an_arrow\n";

  my @arrows_bridging = ListV($this->{bridging});
  my @arrows_coref_text = ListV($this->{coref_text});

  my $changed = 0;

  if (@arrows_bridging == 0 && @arrows_coref_text == 0) {
    print "No bridging or text-coref arrow to be set source of!\n";
  }

  elsif (@arrows_bridging + @arrows_coref_text == 1) {

    if (@arrows_bridging == 1) {
      $changed = source_one_arrow($this, 'bridging', 1, 'arrow'); # ask the user for the source and set it at the first (the only one) arrow
    }
    elsif (@arrows_coref_text == 1) {
      $changed = source_one_arrow($this, 'coref_text', 1, 'arrow'); # ask the user for the source and set it at the first (the only one) arrow
    }
    if ($changed) {
      ChangingFile(1);
      # print "The (only one) bridging or text-coref arrow has been set source of!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to set source of",'browse',[existing_links_bridging_and_coref_text($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_bridging_and_coref_text($this);
    if ($position <= @arrows_bridging) { # the selected arrow is from the first part of the list - a bridging arrow
      # print STDERR "Setting source of the bridging arrow at position $position\n";
      $changed = source_one_arrow($this, 'bridging', $position, 'arrow'); # ask the user for the source and set it at the arrow given by $position
      if ($changed) {
        # print STDERR "A bridging arrow ($position) has been set source of\n";
        ChangingFile(1);
      }
    }
    else { # the selected arrow is from the second part of the list - a textual coreference
      $position -= @arrows_bridging;
      # print STDERR "Setting source of the text-coref arrow at position $position\n";
      $changed = source_one_arrow($this, 'coref_text', $position, 'arrow'); # ask the user for the source and set it at the arrow given by $position
      if ($changed) {
        # print STDERR "A text-coref arrow ($position) has been set source of\n";
        ChangingFile(1);
      }
    }
  }
} # source_an_arrow



=item add_to_bridging_anaphors

  It adds a node to the list of bridging anaphors of a target node given by its id.
  The lists are stored in a hash according to the target node id.
  The hash is kept in the file object to allow more opened files at the same time

=cut

sub add_to_bridging_anaphors {
  my ($target_node_id, $anaphor) = @_;
  my $ref_bridging_anaphors = FileUserData('bridging_anaphors');
  my $ref_node_anaphors = $ref_bridging_anaphors->{$target_node_id};
  # I do not test if its already there; several bridging arrows between two nodes are allowed
  # but I must test if there is an array at all
  if (! defined($ref_node_anaphors)) {
    $ref_node_anaphors = []; # (create an empty anonymous array and return a pointer to it)
    $ref_bridging_anaphors->{$target_node_id} = $ref_node_anaphors;
  }
  push (@$ref_node_anaphors, $anaphor);
  # print_nodes_with_order("br. anaphors of node " . $target_node_id, @$ref_node_anaphors);
} # add_to_bridging_anaphors


=item remove_from_bridging_anaphors

  It removes a node from the list of bridging anaphors of a target node given by its id.
  The lists are stored in a hash according to the target node id.
  The hash is kept in the file object to allow more opened files at the same time

=cut

sub remove_from_bridging_anaphors {
  my ($target_node_id, $anaphor) = @_;
  my $ref_bridging_anaphors = FileUserData('bridging_anaphors');
  my $ref_node_anaphors = $ref_bridging_anaphors->{$target_node_id};
  # Several bridging arrows between two nodes are allowed; I find the first one and remove it
  my $index = Index($ref_node_anaphors, $anaphor);
  if (defined($index) && $index>=0) {
    splice(@$ref_node_anaphors, $index, 1);
  }
} # remove_from_bridging_anaphors


=item add_to_coref_text_anaphors

  It adds a node to the list of coref_text anaphors of a target node given by its id.
  The lists are stored in a hash according to the target node id.
  The hash is kept in the file object to allow more opened files at the same time

=cut

sub add_to_coref_text_anaphors {
  my ($target_node_id, $anaphor) = @_;
  my $ref_coref_text_anaphors = FileUserData('coref_text_anaphors');
  my $ref_node_anaphors = $ref_coref_text_anaphors->{$target_node_id};
  # I do not test if its already there; several coref_text arrows between two nodes are technically allowed (e.g. parallel annotations)
  # but I must test if there is an array at all
  if (! defined($ref_node_anaphors)) {
    $ref_node_anaphors = []; # (create an empty anonymous array and return a pointer to it)
    $ref_coref_text_anaphors->{$target_node_id} = $ref_node_anaphors;
  }
  push (@$ref_node_anaphors, $anaphor);
  # print_nodes_with_order("coref_text anaphors of node " . $target_node_id, @$ref_node_anaphors);
} # add_to_coref_text_anaphors


=item remove_from_coref_text_anaphors

  It removes a node from the list of coref_text anaphors of a target node given by its id.
  The lists are stored in a hash according to the target node id.
  The hash is kept in the file object to allow more opened files at the same time

=cut

sub remove_from_coref_text_anaphors {
  my ($target_node_id, $anaphor) = @_;
  my $ref_coref_text_anaphors = FileUserData('coref_text_anaphors');
  my $ref_node_anaphors = $ref_coref_text_anaphors->{$target_node_id};
  # Several coref_text arrows between two nodes are allowed (e.g. parallel annotations); I find the first one and remove it
  my $index = Index($ref_node_anaphors, $anaphor);
  if (defined($index) && $index>=0) {
    splice(@$ref_node_anaphors, $index, 1);
  }
  # print_nodes_with_order("coref_text anaphors of node " . $target_node_id, @$ref_node_anaphors);
} # remove_from_coref_text_anaphors


=item node_click_hook

  With a modifier, it does not select the node but remembers the node and creates an arrow to it (depending on the modifier).
  This is an overwriting of the function defined in nondeprel_common.mac!

=cut

sub node_click_hook {
  my ($node,$modifier,$xevent)=@_;
  # print STDERR "Modifier: $modifier\n";
  my $changed = 0;
  if ($modifier =~ /^Shift/) {
    remember_single_node($node);
    add_bridging_arrow();
    $changed = 1;
  }
  elsif ($modifier =~ /^Control/) {
    remember_single_node($node);
    add_coref_text_arrow();
    $changed = 1;
  }
  if ($changed) {
     Redraw();
     # main::update_value_line(GUI()->{framegroup});
  }

} # node_click_hook

sub node_release_hook {
  if ( (FileMetaData('schema-url') || '') =~ /tanot_(coref_)?schema\.xml/ ) { # annotation of PDTSC or the Czech part of PCEDT
    return('stop'); # do not allow to change the tree structure
  }
}

sub enable_edit_node_hook {
  if ( (FileMetaData('schema-url') || '') =~ /tanot_(coref_)?schema\.xml/ ) { # annotation of PDTSC or the Czech part of PCEDT
    return('stop');
  }
}

sub enable_attr_hook {
  if ( (FileMetaData('schema-url') || '') =~ /tanot_(coref_)?schema\.xml/ ) { # annotation of PDTSC or the Czech part of PCEDT
    return('stop');
  }
}



sub Toggle3rdLine { # toggles displaying the ontological information (PEDT data)
  my $display = ((FileUserData('toggle_third_line') or 0) + 1) % 4;
  FileUserData('toggle_third_line',$display);
  print STDERR "Toggle3rdLine: $display\n";
}
sub get_toggle_third_line {
  return FileUserData('toggle_third_line');
}


1;

} # package

=item Changelog since 20081203

20081203: Automatic displaying a dialog for selecting a type of a newly created textual coreference has been re-introduced
20090223: A jump to the first antecedent and back can be made now
20090223: "SYN" and "ER" are no longer offered as possible values for the textual coreference (but they stayed in the schema)
20090313: "ANAF" has been added to the possible values of the bridging anaphora (added to the schema)
20090313: Ctrl+t makes a chain of textual coreferences from all nodes in the file with t_lemma equal to $this
20090313: Words in the sentences that belong to nodes that are "bridging neigbours" of a coreferential chain that goes through
          the active node are displayed in light blue now. Apart from that, bridging coreferential chains are no longer
          displayed in sentences.
20090327: When a bridging arrow is created, point to the first node in text-coreferential chain instead (just like for the
          textual coreference.
20090409: O(n) version of the function create_lists_of_anaphoras instead of the original O(n^2) (sent to me by Petr Pajas)
          The hash for keeping the anaphoras was moved from the macro to FileUserData('bridging_anaphoras') to allow multiple files opened at once
          Clicking on cancel now cancels the creation of an arrow
20090417: Function node_style_hook removed; using the function from the common extension nondeprel_common.mac instead
20090421: Many functions moved to nondeprel_common.mac
20090423: Ctrl+t now creates coreferential chain of nodes with the same t_lemma correctly - it does no longer double already
          existing links.
20090429: Automatic displaying of context trees enabled.
20090511: Fixed a bug in removing bridging arrows.
          Coref-text chain is added in accordance with the surface order.
20090513: Words zdejší, místní, tamní are displayed in italics in the sentences.
          "c" switches on/off displaying of context trees.
20091019: Special coreference can be added and changed using a makro (add_coref_special_arrow)
20091214: The analytical tree can be displayed - the function PML_T->AnalyticalTree has been bound to Ctrl+A.
20100203: An arrow can be added by clicking on the target node while pressing a modifier (Ctrl or Shift).
          Before a coreference chain is created (Ctrl+c), the user is asked for the type of the arrows.
20100521: Support for attaching comments to arrows.
20101029: Grammatical coreference arrows can be created and removed.
20110617: Possible values of text-coref have been changed. Jumping to the antecedent of the second arrow at a node has been added.
20120305: Added support for PDT 2.5
20120321: Support for adding and changing source of the arrows; the last entered value is used for subsequent newly created arrows as well.
20120423: Better support for English data from PEDT

But: Unable to keep this changelog entirely up-to-date...

=cut

