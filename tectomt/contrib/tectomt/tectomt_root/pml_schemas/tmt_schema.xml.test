<?xml version="1.0" encoding="utf-8"?>

<pml_schema xmlns="http://ufal.mff.cuni.cz/pdt/pml/schema/" version="1.1">
  <description>Data for TMT (Tecto Machine Translation)</description>

  <!-- Each document contains "meta-attributes" common for the whole
 document (such as the source text to be translated) and a list of
 tree bundles related to the individual sentences. -->


  <root name="tmt_document">
    <structure>
      <member name="meta" required="1" type="meta.type"/>
      <member name="bundles" role="#TREES" required="1">
        <list ordered="1" type="bundle.type"/>
      </member>
    </structure>
  </root>


  <!-- Metainfo (info about the whole document) -->
  <type name="meta.type">
    <structure>
       <member name="english_source_text"><cdata format="any"/></member>
    </structure>
  </type>



  <type name="bundle.type" >
    <structure role="#NODE" name="bundle-root">
      <member as_attribute="1" name="id" role="#ID" required="1"><cdata format="ID"/></member>
      <member name="english_source_sentence"><cdata format="any"/></member>
      <member name="czech_source_sentence"><cdata format="any"/></member>
      <member name="trees">
        <structure>

          <member name="EnglishP" type="english_p_nonterminal.type"   role="#NODE"  />
          <member name="EnglishM" type="english_m_root.type" role="#NODE" /> 
          <member name="EnglishA" type="a-root.type" role="#NODE" /> 
          <member name="EnglishT" type="t-root.type" role="#NODE" /> 
          <member name="CzechT" type="t-root.type" role="#NODE" />

          <member name="MTCzechT" type="t-root.type" role="#NODE" />
          <member name="CzechM" type="czech_m_root.type" role="#NODE" />
          <member name="CzechA" type="a-root.type" role="#NODE" /> 
          
        </structure>
      </member>
    </structure>
  </type>


<type name="english_p_nonterminal.type">
  <structure role="#NODE">
    <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>
    <member name="is_head" ><cdata format="any"/></member>
    <member name="is_collins_head" ><cdata format="any"/></member>
    <member name="phrase" type="english_p_phrase.type"  />
    <member name="functions">
      <list type="english_p_function.type" ordered="1"/>
    </member>
    <member name="coindex"><cdata format="any"/></member>
    <member name="children" role="#CHILDNODES">
      <sequence role="#CHILDNODES">
        <element name="nonterminal" type="english_p_nonterminal.type"/>
        <element name="terminal" type="english_p_terminal.type"/>
      </sequence>
    </member>
 </structure>
</type>

<type name="english_p_terminal.type">
     <structure role="#NODE">
        <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>
        <member name="is_head" ><cdata format="any"/></member>
        <member name="is_collins_head" ><cdata format="any"/></member>
        <member name="coindex"><cdata format="any"/></member>
        <member name="form"><cdata format="any"/></member>
        <member name="lemma"><cdata format="any"/></member>
        <member name="tag" type="english_p_postag.type"/> 
<!--        <member name="m.rf" role="#KNIT" type="m-node.type"/> -->
    </structure>
</type>

  <type name="english_p_phrase.type">
    <choice>
      <value>S</value>
      <value>SBAR</value>
      <value>SBARQ</value>
      <value>SINV</value>
      <value>SQ</value>
      <value>ADJP</value>
      <value>ADVP</value>
      <value>CONJP</value>
      <value>FRAG</value>
      <value>INTJ</value>
      <value>LST</value>
      <value>NAC</value>
      <value>NP</value>
      <value>NX</value>
      <value>PP</value>
      <value>PRN</value>
      <value>PRT</value>
      <value>QP</value>
      <value>RRC</value>
      <value>UCP</value>
      <value>VP</value>
      <value>WHADJP</value>
      <value>WHADVP</value>
      <value>WHNP</value>
      <value>WHPP</value>
      <value>X</value>

      <value>TOP</value> <!-- added because of the collins parser -->
      <value>NPB</value> <!-- added because of the collins parser -->
    </choice>
  </type>

  <type name="english_p_function.type">
    <choice>
      <value>ADV</value>
      <value>NOM</value>
      <value>DTV</value>
      <value>LGS</value>
      <value>PRD</value>
      <value>PUT</value>
      <value>SBJ</value>
      <value>TPC</value>
      <value>VOC</value>
      <value>BNF</value>
      <value>DIR</value>
      <value>EXT</value>
      <value>LOC</value>
      <value>MNR</value>
      <value>PRP</value>
      <value>TMP</value>
      <value>CLR</value>
      <value>CLF</value>
      <value>HLN</value>
      <value>TTL</value>
    </choice>
  </type>

  <type name="english_p_postag.type">
    <choice>
      <value>CC</value>
      <value>CD</value>
      <value>DT</value>
      <value>EX</value>
      <value>FW</value>
      <value>IN</value>
      <value>JJ</value>
      <value>JJR</value>
      <value>JJS</value>
      <value>LS</value>
      <value>MD</value>
      <value>NN</value>
      <value>NNS</value>
      <value>NNP</value>
      <value>NNPS</value>
      <value>PDT</value>
      <value>POS</value>
      <value>PRP</value>
      <value>PRP$</value>
      <value>RB</value>
      <value>RBR</value>
      <value>RBS</value>
      <value>RP</value>
      <value>SYM</value>
      <value>TO</value>
      <value>UH</value>
      <value>VB</value>
      <value>VBD</value>
      <value>VBG</value>
      <value>VBN</value>
      <value>VBP</value>
      <value>VBZ</value>
      <value>WDT</value>
      <value>WP</value>
      <value>WP$</value>
      <value>WPS</value>
      <value>WRB</value>
      <value>-NONE-</value>
      <value>-LRB-</value>
      <value>-RRB-</value>
      <value>-LSB-</value>
      <value>-RSB-</value>
      <value>-LCB-</value>
      <value>-RCB-</value>
      <value>,</value>
      <value>.</value>
      <value>:</value>
      <value>$</value>
      <value>``</value>
      <value>''</value>
      <value>#</value>
    </choice>
  </type>




 <!--  English a-layer representation -->

  <type name="a-root.type">
    <structure role="#NODE" name="a-root">
      <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>
      <member name="ptree.rf"> <!-- pridano na navrh Jirky -->
         <cdata format="PMLREF"/>
      </member>
      <member name="s.rf"><cdata format="PMLREF"/></member>
      <member name="afun"><constant>AuxS</constant></member>
      <member name="ord" role="#ORDER" required="1"><cdata format="nonNegativeInteger"/></member>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>
    </structure>
  </type>

  <type name="a-node.type">
    <structure role="#NODE" name="a-node">
      <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>
<!--      <member name="m.rf" role="#KNIT" type="m-node.type"/> -->
      <member name="m" type="m-node.type"/>
      <member name="afun" type="afun.type" />
      <member name="is_member" type="bool.type"/>
      <member type="bool.type" name="is_parenthesis_root"/>
      <member name="ord" role="#ORDER" required="1"><cdata format="nonNegativeInteger"/></member>
      <member name="children" role="#CHILDNODES">
        <list type="a-node.type" ordered="1"/>
      </member>
      <member name="p" type="a-p.type"/>  <!-- pridano na navrh Jirky -->
    </structure>
  </type>

  <type name="a-p.type"> <!-- pridano na navrh Jirky -->
    <structure>
       <member name="terminal.rf">
         <cdata format="PMLREF"/>
       </member>
       <member name="nonterminals.rf">
          <list ordered="0">
             <cdata format="PMLREF"/>
          </list>
       </member>
    </structure>
  </type>

  <type name="afun.type">
    <choice>
      <value>Pred</value>
      <value>Pnom</value>
      <value>AuxV</value>
      <value>Sb</value>
      <value>Obj</value>
      <value>Atr</value>
      <value>Adv</value>
      <value>AtrAdv</value>
      <value>AdvAtr</value>
      <value>Coord</value>
      <value>AtrObj</value>
      <value>ObjAtr</value>
      <value>AtrAtr</value>
      <value>AuxT</value>
      <value>AuxR</value>
      <value>AuxP</value>
      <value>Apos</value>
      <value>ExD</value>
      <value>AuxC</value>
      <value>Atv</value>
      <value>AtvV</value>
      <value>AuxO</value>
      <value>AuxZ</value>
      <value>AuxY</value>
      <value>AuxG</value>
      <value>AuxK</value>
      <value>AuxX</value>
    </choice>
  </type>


 <!--  English m-layer representation -->


  <type name="english_m_root.type">
    <structure role="#NODE" name="m-root">
      <member name="children" role="#CHILDNODES">
        <list type="m-node.type" ordered="1"/>
      </member>
    </structure>
   </type>

  <type name="m-node.type">
    <structure name="m-node" role="#NODE">
      <member name="id" as_attribute="1" role="#ID" required="0"><cdata format="ID"/></member>
<!--      <member name="src.rf"><cdata format="PMLREF"/></member>
      <member name="w.rf">
        <list ordered="1" role="#KNIT" type="w-node.type"/>
      </member> -->
      <member name="form_change">
        <choice>
          <value>ctcd</value>
          <value>spell</value>
          <value>insert</value>
          <value>num_normalization</value>
        </choice>
      </member>
      <member name="form"><cdata format="any"/></member>
      <member name="lemma"><cdata format="any"/></member>
      <member name="tag"><cdata format="any"/></member>
    </structure>
  </type>

<!--
  <type name="w-node.type">
    <structure name="w-node">
      <member name="id" as_attribute="1" role="#ID" required="1"><cdata format="ID"/></member>
      <member name="token" required="1"><cdata format="any"/></member>
      <member name="no_space_after" type="bool.type"/>
    </structure>
  </type>
-->



  <!-- Root of the English (source-language) m-layer representation -->

<!--

  <type name="english_m_root.type">
    <structure role="#NODE" name="english_m_root">
      <member name="id" role="#ID" as_attribute="1" required="1"><cdata format="ID"/></member>
      <member name="children" role="#CHILDNODES">
        <list type="english_m_node.type" ordered="1"/>
      </member>
    </structure>
  </type>

-->


  <!-- Tokens of the English (source-language) m-layer representation -->

<!--
  <import type="m-node.type" schema="mdata_schema.xml" />
  <adapt name="english_m_node.type" source="m-node.type"/>
-->


<!--     <structure>
     <member name="vlkojesterka" required="1"><cdata
     format="any"/></member>
     </structure>
  </adapt> -->




 <!--  English t-layer representation -->

  <type name="t-root.type">
    <structure role="#NODE" name="t-root">
      <member as_attribute="1" name="id" role="#ID" required="1">
        <cdata format="ID"/>
      </member>
      <member name="atree.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="nodetype">
        <constant>root</constant>
      </member>
      <member name="deepord" role="#ORDER" required="0">
        <cdata format="nonNegativeInteger"/>
      </member>
      <member name="children" role="#CHILDNODES">
        <list ordered="1" type="t-node.type"/>
      </member>
    </structure>
  </type>

  <type name="t-node.type">
    <structure role="#NODE" name="t-node">
      <member as_attribute="1" name="id" role="#ID" required="1">
        <cdata format="ID"/>
      </member>
      <member name="a" type="t-a.type"/>
      <member name="compl.rf">
        <list ordered="0">
          <cdata format="PMLREF"/>
        </list>
      </member>
      <member name="coref_text.rf">
        <list ordered="0">
          <cdata format="PMLREF"/>
        </list>
      </member>
      <member name="coref_gram.rf">
        <list ordered="0">
          <cdata format="PMLREF"/>
        </list>
      </member>
      <member name="coref_special" type="coref_special.type"/>
      <member name="val_frame.rf">
        <alt>
          <cdata format="PMLREF"/>
        </alt>
      </member>
      <member name="nodetype"  type="t-nodetype.type"/>
      <member name="is_generated" type="bool.type"/>
      <member name="t_lemma" >
        <cdata format="any"/>
      </member>
      <member name="functor" >
        <alt type="func.type"/>
      </member>
      <member name="subfunctor" type="t-subfunctor.type"/>
      <member name="is_member" type="bool.type"/>
      <member name="is_name_of_person" type="bool.type"/>
      <member name="quot">
        <list ordered="0">
          <structure>
            <member name="type"  type="t-type.type"/>
            <member name="set_id" >
              <cdata format="any"/>
            </member>
          </structure>
        </list>
      </member>
      <member name="is_dsp_root" type="bool.type"/>
      <member name="sentmod" type="t-sentmod.type"/>
      <member name="gram" type="t-gram.type"/>
      <member name="tfa" type="t-tfa.type"/>
      <member name="is_parenthesis" type="bool.type"/>
      <member name="is_state" type="bool.type"/>
      <member name="is_name" type="bool.type"/>
      <member name="is_passive" type="bool.type"/>
      <member name="is_infin" type="bool.type"/>
      <member name="is_clause_head" type="bool.type"/>
      <member name="deepord" role="#ORDER" >
        <cdata format="nonNegativeInteger"/>
      </member>
      <member name="children" role="#CHILDNODES">
        <list ordered="1" type="t-node.type"/>
      </member>
      <member name="formeme" >
        <cdata format="any"/>
      </member>

    </structure>
  </type>

  <type name="t-tfa.type">
    <choice>
      <value>t</value>
      <value>f</value>
      <value>c</value>
    </choice>
  </type>

  <type name="t-gram.type">
    <structure>
      <member name="sempos"  type="t-sempos.type"/>
      <member name="gender" type="t-gender.type"/>
      <member name="number" type="t-number.type"/>
      <member name="degcmp" type="t-degcmp.type"/>
      <member name="verbmod" type="t-verbmod.type"/>
      <member name="deontmod" type="t-deontmod.type"/>
      <member name="tense" type="t-tense.type"/>
      <member name="aspect" type="t-aspect.type"/>
      <member name="resultative" type="t-resultative.type"/>
      <member name="dispmod" type="t-dispmod.type"/>
      <member name="iterativeness" type="t-iterativeness.type"/>
      <member name="indeftype" type="t-indeftype.type"/>
      <member name="person" type="t-person.type"/>
      <member name="numertype" type="t-numertype.type"/>
      <member name="politeness" type="t-politeness.type"/>
      <member name="negation" type="t-negation.type"/>
    </structure>
  </type>

  <type name="t-negation.type">
    <choice>
      <value>neg0</value>
      <value>neg1</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-politeness.type">
    <choice>
      <value>polite</value>
      <value>basic</value>
      <value>inher</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-numertype.type">
    <choice>
      <value>basic</value>
      <value>set</value>
      <value>kind</value>
      <value>ord</value>
      <value>frac</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-person.type">
    <choice>
      <value>1</value>
      <value>2</value>
      <value>3</value>
      <value>inher</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-indeftype.type">
    <choice>
      <value>relat</value>
      <value>indef1</value>
      <value>indef2</value>
      <value>indef3</value>
      <value>indef4</value>
      <value>indef5</value>
      <value>indef6</value>
      <value>inter</value>
      <value>negat</value>
      <value>total1</value>
      <value>total2</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-iterativeness.type">
    <choice>
      <value>it1</value>
      <value>it0</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-dispmod.type">
    <choice>
      <value>disp1</value>
      <value>disp0</value>
      <value>nr</value>
      <value>nil</value>
    </choice>
  </type>

  <type name="t-resultative.type">
    <choice>
      <value>res1</value>
      <value>res0</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-aspect.type">
    <choice>
      <value>proc</value>
      <value>cpl</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-tense.type">
    <choice>
      <value>sim</value>
      <value>ant</value>
      <value>post</value>
      <value>nr</value>
      <value>nil</value>
    </choice>
  </type>

  <type name="t-deontmod.type">
    <choice>
      <value>deb</value>
      <value>hrt</value>
      <value>vol</value>
      <value>poss</value>
      <value>perm</value>
      <value>fac</value>
      <value>decl</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-verbmod.type">
    <choice>
      <value>ind</value>
      <value>imp</value>
      <value>cdn</value>
      <value>nr</value>
      <value>nil</value>
    </choice>
  </type>

  <type name="t-degcmp.type">
    <choice>
      <value>pos</value>
      <value>comp</value>
      <value>acomp</value>
      <value>sup</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-number.type">
    <choice>
      <value>sg</value>
      <value>pl</value>
      <value>inher</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-gender.type">
    <choice>
      <value>anim</value>
      <value>inan</value>
      <value>fem</value>
      <value>neut</value>
      <value>inher</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-sempos.type">
    <choice>
      <value>n.denot</value>
      <value>n.denot.neg</value>
      <value>n.pron.def.demon</value>
      <value>n.pron.def.pers</value>
      <value>n.pron.indef</value>
      <value>n.quant.def</value>
      <value>adj.denot</value>
      <value>adj.pron.def.demon</value>
      <value>adj.pron.indef</value>
      <value>adj.quant.def</value>
      <value>adj.quant.indef</value>
      <value>adj.quant.grad</value>
      <value>adv.denot.grad.nneg</value>
      <value>adv.denot.ngrad.nneg</value>
      <value>adv.denot.grad.neg</value>
      <value>adv.denot.ngrad.neg</value>
      <value>adv.pron.def</value>
      <value>adv.pron.indef</value>
      <value>v</value>
    </choice>
  </type>

  <type name="t-sentmod.type">
    <choice>
      <value>enunc</value>
      <value>excl</value>
      <value>desid</value>
      <value>imper</value>
      <value>inter</value>
    </choice>
  </type>

  <type name="t-type.type">
    <choice>
      <value>citation</value>
      <value>dsp</value>
      <value>meta</value>
      <value>other</value>
      <value>title</value>
    </choice>
  </type>

  <type name="t-subfunctor.type">
    <choice>
      <value>above</value>
      <value>abstr</value>
      <value>across</value>
      <value>after</value>
      <value>agst</value>
      <value>along</value>
      <value>approx</value>
      <value>around</value>
      <value>basic</value>
      <value>before</value>
      <value>begin</value>
      <value>behind</value>
      <value>below</value>
      <value>betw</value>
      <value>circ</value>
      <value>elsew</value>
      <value>end</value>
      <value>ext</value>
      <value>flow</value>
      <value>front</value>
      <value>incl</value>
      <value>in</value>
      <value>less</value>
      <value>mid</value>
      <value>more</value>
      <value>near</value>
      <value>opp</value>
      <value>target</value>
      <value>than</value>
      <value>to</value>
      <value>wout</value>
      <value>wrt</value>
      <value>nr</value>
    </choice>
  </type>

  <type name="t-nodetype.type">
    <choice>
      <value>atom</value>
      <value>coap</value>
      <value>complex</value>
      <value>dphr</value>
      <value>fphr</value>
      <value>list</value>
      <value>qcomplex</value>
    </choice>
  </type>

  <type name="t-a.type">
    <structure>
      <member name="lex.rf">
        <cdata format="PMLREF"/>
      </member>
      <member name="aux.rf">
        <list ordered="0">
          <cdata format="PMLREF"/>
        </list>
      </member>
    </structure>
  </type>

  <type name="coref_special.type">
    <choice>
      <value>segm</value>
      <value>exoph</value>
    </choice>
  </type>

  <type name="func.type">
    <choice>
      <value>ACT</value>
      <value>AUTH</value>
      <value>PAT</value>
      <value>ADDR</value>
      <value>EFF</value>
      <value>ORIG</value>
      <value>ACMP</value>
      <value>ADVS</value>
      <value>AIM</value>
      <value>APP</value>
      <value>APPS</value>
      <value>ATT</value>
      <value>BEN</value>
      <value>CAUS</value>
      <value>CNCS</value>
      <value>CM</value>
      <value>COMPL</value>
      <value>CONJ</value>
      <value>COND</value>
      <value>CONFR</value>
      <value>CONTRA</value>
      <value>CONTRD</value>
      <value>CPHR</value>
      <value>CPR</value>
      <value>CRIT</value>
      <value>CSQ</value>
      <value>DENOM</value>
      <value>DIFF</value>
      <value>DIR1</value>
      <value>DIR2</value>
      <value>DIR3</value>
      <value>DISJ</value>
      <value>DPHR</value>
      <value>EXT</value>
      <value>FPHR</value>
      <value>GRAD</value>
      <value>HER</value>
      <value>ID</value>
      <value>INTF</value>
      <value>INTT</value>
      <value>LOC</value>
      <value>MANN</value>
      <value>MAT</value>
      <value>MEANS</value>
      <value>MOD</value>
      <value>OPER</value>
      <value>PAR</value>
      <value>PARTL</value>
      <value>PREC</value>
      <value>PRED</value>
      <value>REAS</value>
      <value>REG</value>
      <value>RESL</value>
      <value>RESTR</value>
      <value>RHEM</value>
      <value>RSTR</value>
      <value>SUBS</value>
      <value>TFHL</value>
      <value>TFRWH</value>
      <value>THL</value>
      <value>THO</value>
      <value>TOWH</value>
      <value>TPAR</value>
      <value>TSIN</value>
      <value>TTILL</value>
      <value>TWHEN</value>
      <value>VOCAT</value>

      <value>DESCR</value>
      <value>???</value>

    </choice>
  </type>



  <type name="bool.type">
    <choice>
      <value>0</value>
      <value>1</value>
    </choice>
  </type>


<!-- ######################################3 -->

  <type name="czech_m_root.type">
    <structure role="#NODE" name="m-root">
      <member name="children" role="#CHILDNODES">
        <list type="m-node.type" ordered="1"/>
      </member>
    </structure>
   </type>


</pml_schema>

