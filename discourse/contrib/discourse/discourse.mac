# -*- cperl -*-

# Makras for TrEd for annotating discourse relations
# Jiri Mirovsky, Petr Pajas, Zdenek Zabokrtsky, surname at ufal.mff.cuni.cz

{

package PML_T_Discourse;
BEGIN { import NonDepRel_Common; import TredMacro; }
#binding-context PML_T_Discourse

#include <contrib/support/unbind_edit.inc>

#bind PML_T->AnalyticalTree to Ctrl+A menu Display corresponding analytical tree

#bind switch_remember_actual_node_or_group to space menu Remember/forget node or group
#bind switch_unfold_actual_node to u menu Unfold/Fold node
#bind forget_all_remembered_nodes_and_groups to f menu Forget remembered nodes and groups
#bind switch_remember_subtree to Ctrl+space menu Remember/forget subtree
#bind select_discourse_source to s menu Select source
#bind switch_hiding_src to H menu Switch hiding source

use strict;
use warnings;
no warnings qw(redefine);

use vars qw($this $root $grp);

my $neigboring_sentences_before;
my $neigboring_sentences_after;

my $neigboring_trees_before;
my $neigboring_trees_after;

my $predefined_mode = 3; # 1 = pure bridging, 2 = pure discourse, 3 = full discourse

my $selected_arrow_index = 0;

unshift @TredMacro::AUTO_CONTEXT_GUESSING, sub {
  my ($hook)=@_;
  my $resuming = ($hook eq 'file_resumed_hook');
  my $current = CurrentContext();
  if ( (FileMetaData('schema-url') || '') =~ /tdata_25_discourse_schema\.xml/ ) {
    SetCurrentStylesheet('PML_T_25_Discourse') if $resuming;
    return 'PML_T_Discourse';
  }
  if ( (FileMetaData('schema-url') || '') =~ /tdata_discourse_schema\.xml/ ) {
    SetCurrentStylesheet('PML_T_Discourse') if $resuming;
    return 'PML_T_Discourse';
  }
  return;
};

sub file_opened_hook {
  return unless CurrentFile();
  print STDERR "file opened hook\n";
  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  switch_to_predefined_mode($predefined_mode);
} # file_opened_hook

sub file_reloaded_hook {
  return unless CurrentFile();
  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  switch_to_predefined_mode($predefined_mode);
} # file_reloaded_hook

sub switch_context_hook {
  NonDepRel_Common::switch_context_hook(@_); # do what NonDepRel_Common context wants to do...
  PML_T::CreateStylesheets();
  set_paragraph_separator("\n");
  forget_all_remembered_nodes_and_groups();

  precompute_clause_segmentation(); # PP+ZZ

  initialize_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  precompute_file_related_resources({'bridging' => 1, 'coref_text' => 1, 'discourse' => 1});
  switch_to_predefined_mode($predefined_mode);
  if (GUI()) {
    SetCurrentStylesheet('PML_T_Discourse');
    Redraw();
  }

=item
  
  # set correct stylesheet when entering this annotation mode
  if (is_discourse_25_file()) {
    # print STDERR "Is discourse 25 file.\n";
    SetCurrentStylesheet('PML_T_25_Discourse');
  }
  elsif (is_discourse_20_file()) {
    SetCurrentStylesheet('PML_T_Discourse');
  }
  if (GUI()) {
    # print STDERR "Redrawing.\n";
    Redraw();
  }

=cut

  return;
} # switch_context_hook


sub is_discourse_20_file {
  if ((FileMetaData('schema-url') || '') =~ /tdata_discourse_schema\.xml/) {
    # print "Schema: " . PML::SchemaName() . "\n"; 
    return 1;
  }
  return 0;
  # return (((PML::SchemaName()||'') =~ 'tdata_discourse_schema') ? 1 : 0);
}

sub is_discourse_25_file {
  if ((FileMetaData('schema-url') || '') =~ /tdata_25_discourse_schema\.xml/) {
    # print "Schema: " . PML::SchemaName() . "\n"; 
    return 1;
  }
  return 0;
  # return (((PML::SchemaName()||'') =~ 'tdata_25_discourse_schema') ? 1 : 0);
}


sub macros_reloaded_hook {
  NonDepRel_Common::macros_reloaded_hook(@_); # do what NonDepRel_Common context wants to do...
  switch_to_predefined_mode($predefined_mode);
  FileUserData('precomputed_clause_segmentation',undef);
  precompute_clause_segmentation(); # PP+ZZ
}

#bind init_discourse_schema to i menu Init discourse attributes
sub init_discourse_schema {
  return unless CurrentFile();
  if (FileMetaData('schema-url')!~/tdata_25_discourse_schema\.xml/) {
    FileMetaData('schema-url','tdata_25_discourse_schema.xml'); # set schema
    CurrentFile()->notSaved(1); # make sure TrEd asks to save the file (or we could Save() it here)
    ReloadCurrentFile(); # reload the file with the new schema
  }
  ChangingFile(0);
}


my %pdtb3_short = (
      "Comparison.Concession.Arg1-as-denier" => "Conc.Arg1asDenier",
      "Comparison.Concession.Arg2-as-denier" => "Conc.Arg2asDenier",
      "Comparison.Concession+SpeechAct.Arg2-as-denier+SpeechAct" => "Cons+SA.Arg2asDen",
      "Comparison.Contrast" => "Contrast",
      "Comparison.Similarity" => "Similarity",
      "Contingency.Cause.Reason" => "Cause.Reason",
      "Contingency.Cause.Result" => "Cause.Result",
      "Contingency.Cause+Belief.Reason+Belief" => "Cause+B.Reason+B",
      "Contingency.Cause+Belief.Result+Belief" => "Cause+B.Result+B",
      "Contingency.Cause+SpeechAct.Reason+SpeechAct" => "Cause+SA.Reason+SA",
      "Contingency.Cause+SpeechAct.Result+SpeechAct" => "Cause+SA.Result+SA",
      "Contingency.Negative-cause.NegResult" => "NegCause.NegResult",
      "Contingency.Condition.Arg1-as-cond" => "Cond.Arg1asCond",
      "Contingency.Condition.Arg2-as-cond" => "Cond.Arg2asCond",
      "Contingency.Condition+SpeechAct" => "Cond+SA",
      "Contingency.Negative-condition.Arg1-as-negCond" => "NegCond.Arg1asNegCond",
      "Contingency.Negative-condition.Arg2-as-negCond" => "NegCond.Arg2asNegCond",
      "Contingency.Negative-condition+SpeechAct" => "NegCond+SA",
      "Contingency.Purpose.Arg1-as-goal" => "Purp.Arg1asGoal",
      "Contingency.Purpose.Arg2-as-goal" => "Purp.Arg2asGoal",
      "Expansion.Conjunction" => "Conjunction",
      "Expansion.Disjunction" => "Disjunction",
      "Expansion.Equivalence" => "Equivalence",
      "Expansion.Exception.Arg1-as-excpt" => "Except.Arg1asExcpt",
      "Expansion.Exception.Arg2-as-excpt" => "Except.Arg2asExcpt",
      "Expansion.Instantiation.Arg1-as-instance" => "Inst.Arg1asInst",
      "Expansion.Instantiation.Arg2-as-instance" => "Inst.Arg2asInst",
      "Expansion.Level-of-detail.Arg1-as-detail" => "Level.Arg1asDetail",
      "Expansion.Level-of-detail.Arg2-as-detail" => "Level.Arg2asDetail",
      "Expansion.Manner.Arg1-as-manner" => "Manner.Arg1asManner",
      "Expansion.Manner.Arg2-as-manner" => "Manner.Arg2asManner",
      "Expansion.Substitution.Arg1-as-subst" => "Subst.Arg1asSubst",
      "Expansion.Substitution.Arg2-as-subst" => "Subst.Arg2asSubst",
      "Temporal.Asynchronous.Precedence" => "Asynch.Prec",
      "Temporal.Asynchronous.Succession" => "Asynch.Succ",
      "Temporal.Synchronous" => "Synchronous",
      "IGNORE" => "IGNORE",
);

sub shorten_PDTB3_sense {
  my $sense = shift;
  my $short = $pdtb3_short{$sense};
  if (!$short) {
    $short = $sense;
  }
  return $short;
}


# Transformation table from a PDTB sense to the most likely Prague discourse type
my %sense2type = (
     'Comparison.Concession.Arg1-as-denier' => 'opp',
     'Comparison.Concession.Arg2-as-denier' => 'opp',
     # symmetric
     'Comparison.Concession+SpeechAct.Arg2-as-denier+SpeechAct' => 'f_opp',
     # symmetric
     'Comparison.Contrast' => 'confr',
     # symmetric
     'Comparison.Similarity' => 'conj',
     # explicat arrow goes from the argument to the claim
       # Contingency.Cause This tag is used when the situations described in Arg1 and Arg2 are causally influenced but are not in a conditional relation. The label Contingency.Cause.Reason is used when Arg2 gives the reason, explanation or justification, while Arg1 gives its effect
     'Contingency.Cause+Belief.Reason+Belief' => 'explicat',
     'Contingency.Cause+Belief.Result+Belief' => 'f_reason', # f_reason here comes from PDiT frequencies
     # reason arrow goes from the reason to the result
     'Contingency.Cause.Reason' => 'reason',
     'Contingency.Cause.Result' => 'reason',
     'Contingency.Cause+SpeechAct.Reason+SpeechAct' => 'f_reason',
     'Contingency.Cause+SpeechAct.Result+SpeechAct' => 'f_reason',
     # cond arrow goes from the condition to the result of condition
     # f_cond arrow goes from the pragmatic condition to the result of pragmatic condition
       # Contingency.Condition This tag is used when one argument presents a situation as unrealized (the antecedent), which (when realized) would lead to the situation described by the other arg (the consequent). There are distinct senses for interpreting the arguments in terms of their semantics or the speech acts they convey. The default is their semantics. The label Contingency.Condition.Arg1-as-cond is used when Arg1 describes the antecedent and Arg2, the consequent.
     'Contingency.Condition.Arg1-as-cond' => 'cond',
     'Contingency.Condition.Arg2-as-cond' => 'cond',
       # Pozor, v PDTB3 nepoužívají u Condition+SpeechAct příponu Arg2-as-cond a předpokládají, že se to rozumí samo sebou!
     'Contingency.Condition+SpeechAct' => 'f_cond',
     'Contingency.Negative-cause.NegResult' => 'reason',
     'Contingency.Negative-condition.Arg1-as-negCond' => 'cond',
     'Contingency.Negative-condition.Arg2-as-negCond' => 'cond',
     # purp arrow goes from the motivation (goal) to the action
       # Contingency.Purpose This tag is used when one argument presents an action that an AGENT undertakes with the purpose of the GOAL conveyed by the other argument being achieved. Usually (but not always), the agent undertaking the action is the same agent aiming to achieve the goal. The label Contingency.Purpose.Arg1-as-goal is used when Arg1 describes the goal and Arg2 describes the action undertaken to achieve it.
     'Contingency.Purpose.Arg1-as-goal' => 'purp',
     'Contingency.Purpose.Arg2-as-goal' => 'purp',
     # symmetric
     'Expansion.Conjunction' => 'conj',
     # symmetric
     'Expansion.Disjunction' => 'disjalt',
     # symmetric
     'Expansion.Equivalence' => 'equiv',
     # restr arrow goes from the exception to the general statement                          
       # Expansion.Exception This tag is used when one argument evokes a set of circumstances in which the described situation holds, and the other argument indicates one or more instances where it doesn’t. The label Expansion.Exception.Arg1-as-excpt is used when Arg1 indicates the exception(s).
     'Expansion.Exception.Arg1-as-excpt' => 'restr',
     'Expansion.Exception.Arg2-as-excpt' => 'restr',
     # exempl (instantiation) arrow goes from the example to the general statement                          
       # Expansion.Instantiation This tag is used when one argument describes a situation as holding in a set of circumstances, while the other argument describes one or more of those circumstances. The label Expansion.Instantiation.Arg1-as-instance is used when Arg1 provides one or more instances of the circumstances described by Arg2.
     'Expansion.Instantiation.Arg1-as-instance' => 'exempl',
     'Expansion.Instantiation.Arg2-as-instance' => 'exempl',
     # gener arrow goes from the less specific to the more specific (always to the left)
     # spec arrow goes from the more specific to the less specific (always to the left)
     'Expansion.Level-of-detail.Arg1-as-detail' => 'gener',
     'Expansion.Level-of-detail.Arg2-as-detail' => 'spec',
     # spec arrow goes from the more specific to the less specific (always to the left)
     'Expansion.Manner.Arg1-as-manner' => 'gener',
     'Expansion.Manner.Arg2-as-manner' => 'spec',
     # corr arrow goes from the correction to the claim
       # Expansion.Substitution This tag is used when arguments are presented as exclusive alternatives, with one being ruled out. The label Expansion.Substitution.Arg1-as-subst is used when Arg1 conveys the alternative which is left after the situation associated with Arg2 is ruled out
     'Expansion.Substitution.Arg1-as-subst' => 'corr',
     'Expansion.Substitution.Arg2-as-subst' => 'corr',
      # preced arrow goes from the preceding event to the later event
        # Temporal.Asynchronous This tag is used when one event is described as preceding the other. Temporal.Asynchronous.Precedence is used when the event described by Arg1 precedes that described by Arg2 (i.e., Arg1 << Arg2)
     'Temporal.Asynchronous.Precedence' => 'preced',
     'Temporal.Asynchronous.Succession' => 'preced',
     # symmetric
     'Temporal.Synchronous' => 'synchr'
);


#bind set_document_genre_by_query to z menu Set document genre
sub set_document_genre_by_query {
  return unless CurrentFile();
  # my $genre_from_document = FileMetaData('pml_root')->{meta}{genre};
  my $genre_from_document = get_document_genre();
  # print "Genre from document (FileMetaData('genre'): $genre_from_document\n";
  if (!defined($genre_from_document) or !$genre_from_document) {
    $genre_from_document = 'unset';
  }
  my @selection = ($genre_from_document);
  ListQuery("Genre of the document",'browse',[possible_document_genres()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_genre = $selection[0];
  # print "Selected type: $selected_genre\n";
  set_document_genre($selected_genre);
  CurrentFile()->notSaved(1); # make sure TrEd asks to save the file (or we could Save() it here)
  ChangingFile(1);
  return 1;
}

sub set_document_genre {
  my ($genre) = @_;
  $grp->{FSFile}->metaData('pml_root')->{meta}{genre} = $genre;  
}

sub get_document_genre {
  my $genre = $grp->{FSFile}->metaData('pml_root')->{meta}{genre};
  return $genre;
}

sub set_document_attr {
  my ($attr, $value) = @_;
  $grp->{FSFile}->metaData('pml_root')->{meta}{"$attr"} = $value;  
}

sub get_document_attr {
  my ($attr) = @_;
  my $value = $grp->{FSFile}->metaData('pml_root')->{meta}{"$attr"};
  return $value;
}

sub switch_to_predefined_mode {
  my $mode = @_;
  if ($predefined_mode == 1) {
    switch_to_predefined_mode_pure_bridging();
  }
  elsif ($predefined_mode == 2) {
    switch_to_predefined_mode_pure_discourse();
  }
  else {
    switch_to_predefined_mode_full_discourse();
  }
}

#bind switch_to_predefined_mode_pure_bridging to Alt+b menu Switch to pure bridging mode
sub switch_to_predefined_mode_pure_bridging {
  $predefined_mode = 1;
  $neigboring_sentences_before = 20;
  $neigboring_sentences_after = 20;
  #$neigboring_trees_before = 2;
  #$neigboring_trees_after = 1;
  set_display_bridging_arrows(1);
  set_display_coref_text_arrows(1);
  set_display_coref_gram_arrows(1);
  set_display_discourse_arrows(0);
  set_show_discourse_arrow_type(0);
  set_show_discourse_arrow_comment(0);
  set_show_discourse_arrow_connector(0);
  set_show_discourse_arrow_range(0);
  set_show_discourse_node_comment(0);
  set_underline_same_t_lemmas(1);
  set_mode_remember_nodes('SINGLE');
  set_enable_remember_words(0);
  EnableMinorMode('Show_Neighboring_Sentences');
  # TrEd::MinorMode::Show_Neighboring_Sentences::configure($neigboring_sentences_before, $neigboring_sentences_after);
  SetMinorModeData('Show_Neighboring_Sentences', 'context_before', $neigboring_sentences_before);
  SetMinorModeData('Show_Neighboring_Sentences', 'context_after', $neigboring_sentences_after);
  EnableMinorMode('Show_Neighboring_Trees');
  SetMinorModeData('Show_Neighboring_Trees', 'context_before', $neigboring_trees_before);
  SetMinorModeData('Show_Neighboring_Trees', 'context_after', $neigboring_trees_after);
  #Show_Neighboring_Trees::configure($neigboring_trees_before, $neigboring_trees_after); # context before, after
}

#bind switch_to_predefined_mode_pure_discourse to Alt+d menu Switch to pure discourse mode
sub switch_to_predefined_mode_pure_discourse {
  $predefined_mode = 2;
  $neigboring_sentences_before = 6;
  $neigboring_sentences_after = 6;
  $neigboring_trees_before = 6;
  $neigboring_trees_after = 6;
  set_display_bridging_arrows(0);
  set_display_coref_text_arrows(0);
  set_display_coref_gram_arrows(0);
  set_display_discourse_arrows(1);
  set_show_discourse_arrow_type(1);
  set_show_discourse_arrow_comment(1);
  set_show_discourse_arrow_connector(1);
  set_show_discourse_arrow_range(1);
  set_show_discourse_node_comment(1);
  set_underline_same_t_lemmas(0);
  set_mode_remember_nodes('MULTI');
  set_enable_remember_words(1);
  EnableMinorMode('Show_Neighboring_Sentences');
  # TrEd::MinorMode::Show_Neighboring_Sentences::configure($neigboring_sentences_before, $neigboring_sentences_after); # context before, after
  SetMinorModeData('Show_Neighboring_Sentences', 'context_before', $neigboring_sentences_before);
  SetMinorModeData('Show_Neighboring_Sentences', 'context_after', $neigboring_sentences_after);
  EnableMinorMode('Show_Neighboring_Trees');
  SetMinorModeData('Show_Neighboring_Trees', 'context_before', $neigboring_trees_before);
  SetMinorModeData('Show_Neighboring_Trees', 'context_after', $neigboring_trees_after);
  # TrEd::MinorMode::Show_Neighboring_Trees::configure($neigboring_trees_before, $neigboring_trees_after); # context before, after
}

#bind switch_to_predefined_mode_full_discourse to Alt+f menu Switch to full discourse mode
sub switch_to_predefined_mode_full_discourse {
  $predefined_mode = 3;
  $neigboring_sentences_before = 6;
  $neigboring_sentences_after = 6;
  $neigboring_trees_before = 6;
  $neigboring_trees_after = 6;
  set_display_bridging_arrows(1);
  set_display_coref_text_arrows(1);
  set_display_coref_gram_arrows(1);
  set_display_discourse_arrows(1);
  set_show_discourse_arrow_type(1);
  set_show_discourse_arrow_comment(1);
  set_show_discourse_arrow_connector(1);
  set_show_discourse_arrow_range(1);
  set_show_discourse_node_comment(1);
  set_underline_same_t_lemmas(1);
  set_mode_remember_nodes('MULTI');
  set_enable_remember_words(1);
  EnableMinorMode('Show_Neighboring_Sentences');
  # TrEd::MinorMode::Show_Neighboring_Sentences::configure($neigboring_sentences_before, $neigboring_sentences_after); # context before, after
  SetMinorModeData('Show_Neighboring_Sentences', 'context_before', $neigboring_sentences_before);
  SetMinorModeData('Show_Neighboring_Sentences', 'context_after', $neigboring_sentences_after);
  EnableMinorMode('Show_Neighboring_Trees');
  SetMinorModeData('Show_Neighboring_Trees', 'context_before', $neigboring_trees_before);
  SetMinorModeData('Show_Neighboring_Trees', 'context_after', $neigboring_trees_after);
  # TrEd::MinorMode::Show_Neighboring_Trees::configure($neigboring_trees_before, $neigboring_trees_after); # context before, after
}

#bind switch_display_bridging_arrows to Ctrl+b menu Switch displaying bridging arrows

#bind switch_display_coref_text_arrows to Ctrl+t menu Switch displaying text-coref arrows

#bind switch_display_coref_gram_arrows to Ctrl+r menu Switch displaying gram-coref arrows

#bind switch_display_discourse_arrows to Ctrl+d menu Switch displaying discourse arrows


=item set_attribute_discourse_special()

  Sets the value of the attribute discourse_special of the current node.

=cut

#bind set_attribute_discourse_special to h menu Set discourse_special
sub set_attribute_discourse_special {
  my $prev_value = $this->attr('discourse_special');
  $prev_value = 'undef' if (!defined($prev_value));
  my @selection = ($prev_value);
  ListQuery("Value of discourse_special",'browse',[possible_values_discourse_special()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_value = $selection[0];
  # print "Selected value: $selected_value\n";
  if ($prev_value ne $selected_value) {
    if ($selected_value eq 'undef') {
      $this->set_attr('discourse_special',undef);
    }
    else {
      $this->set_attr('discourse_special',$selected_value);
    }
    ChangingFile(1);
  }
} # set_attribute_discourse_special


=item set_attribute_discourse_feature()

  Sets the value of the attribute discourse_feature of the current node.

=cut

#bind set_attribute_discourse_feature to F menu Set discourse_feature
sub set_attribute_discourse_feature {
  my $prev_value = $this->attr('discourse_feature');
  $prev_value = 'undef' if (!defined($prev_value));
  my @selection = ($prev_value);
  ListQuery("Value of discourse_feature",'browse',[possible_values_discourse_feature()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_value = $selection[0];
  # print "Selected value: $selected_value\n";
  if ($prev_value ne $selected_value) {
    if ($selected_value eq 'undef') {
      $this->set_attr('discourse_feature',undef);
    }
    else {
      $this->set_attr('discourse_feature',$selected_value);
    }
    ChangingFile(1);
  }
} # set_attribute_discourse_feature


=item set_attribute_discourse_feature()

  Sets the value of the attribute discourse_feature of the current node.

=cut

#bind set_attribute_discourse_macrostructure to G menu Set discourse_macrostructure
sub set_attribute_discourse_macrostructure {
  my $prev_value = $this->attr('discourse_macrostructure');
  $prev_value = 'undef' if (!defined($prev_value));
  my @selection = ($prev_value);
  ListQuery("Value of discourse_macrostructure",'browse',[possible_values_discourse_macrostructure()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_value = $selection[0];
  # print "Selected value: $selected_value\n";
  if ($prev_value ne $selected_value) {
    if ($selected_value eq 'undef') {
      $this->set_attr('discourse_macrostructure',undef);
    }
    else {
      $this->set_attr('discourse_macrostructure',$selected_value);
    }
    ChangingFile(1);
  }
} # set_attribute_discourse_macrostructure


=item set_attribute_secondary_NP_type()

  Sets the value of the attribute secondary_NP_type of the current node.

=cut

#bind set_attribute_secondary_NP_type to j menu Set secondary_NP_type
sub set_attribute_secondary_NP_type {
  my $prev_value = $this->attr('secondary_NP_type');
  $prev_value = 'undef' if (!defined($prev_value));
  my @selection = ($prev_value);
  my @possible_values = possible_types_discourse();
  push (@possible_values, 'undef');
  ListQuery('Value of secondary_NP_type','browse',[@possible_values],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_value = $selection[0];
  # print "Selected value: $selected_value\n";
  if ($prev_value ne $selected_value) {
    if ($selected_value eq 'undef') {
      $this->set_attr('secondary_NP_type',undef);
    }
    else {
      $this->set_attr('secondary_NP_type',$selected_value);
    }
    ChangingFile(1);
  }
} # set_attribute_secondary_NP_type


=item switch_attribute_secondary_NP_negated()

  Switches the Boolean value of the attribute secondary_NP_negated of the current node.

=cut

#bind switch_attribute_secondary_NP_negated to k menu Switch secondary_NP_negated
sub switch_attribute_secondary_NP_negated {
  my $prev_value = $this->attr('secondary_NP_negated');
  if ($prev_value) {
    $this->set_attr('secondary_NP_negated', undef);
  }
  else {
    $this->set_attr('secondary_NP_negated', 1);
  }
  ChangingFile(1);
} # switch_attribute_secondary_NP_negated


=item switch_is_secondary()

  Changes the boolean value of the attribute is_secondary at a discourse arrow starting at the current node.

=cut

#bind switch_is_secondary to a menu Switch is_secondary
sub switch_is_secondary {
  # print "switch_is_secondary\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as secondary!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_is_secondary_one_discourse_arrow($this, 1); # switch is_secondary at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The is_secondary value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch is_secondary at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching is_secondary of the discourse arrow at position $position\n";
    switch_is_secondary_one_discourse_arrow($this, $position); # switch is_secondary at the arrow given by $position
    ChangingFile(1);
    # print STDERR "is_secondary has been switched at the discourse arrow at position $position\n";
  }
} # switch_is_secondary

# Switches the attribute is_secondary of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_is_secondary_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/is_secondary');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/is_secondary',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/is_secondary','1');
    return '1';
  }
} # switch_is_secondary_one_discourse_arrow


=item switch_is_NP()

  Changes the boolean value of the attribute is_NP at a discourse arrow starting at the current node.

=cut

#bind switch_is_NP to p menu Switch is_NP
sub switch_is_NP {
  # print "switch_is_NP\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as NP!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_is_NP_one_discourse_arrow($this, 1); # switch is_NP at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The is_NP value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch is_NP at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching is_NP of the discourse arrow at position $position\n";
    switch_is_NP_one_discourse_arrow($this, $position); # switch is_NP at the arrow given by $position
    ChangingFile(1);
    # print STDERR "is_NP has been switched at the discourse arrow at position $position\n";
  }
} # switch_is_NP

# Switches the attribute is_NP of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_is_NP_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/is_NP');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/is_NP',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/is_NP','1');
    return '1';
  }
} # switch_is_NP_one_discourse_arrow



=item switch_is_compositional()

  Changes the boolean value of the attribute is_compositional at a discourse arrow starting at the current node.

=cut

#bind switch_is_compositional to C menu Switch is_compositional
sub switch_is_compositional {
  # print "switch_is_compositional\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as compositional phrase!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_is_compositional_one_discourse_arrow($this, 1); # switch is_compositional at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The is_compositional value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch is_compositional at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching is_compositional of the discourse arrow at position $position\n";
    switch_is_compositional_one_discourse_arrow($this, $position); # switch is_compositional at the arrow given by $position
    ChangingFile(1);
    # print STDERR "is_compositional has been switched at the discourse arrow at position $position\n";
  }
} # switch_is_compositional

# Switches the attribute is_compositional of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_is_compositional_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/is_compositional');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/is_compositional',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/is_compositional','1');
    return '1';
  }
} # switch_is_compositional_one_discourse_arrow


=item switch_is_implicit()

  Changes the boolean value of the attribute is_implicit at a discourse arrow starting at the current node.

=cut

#bind switch_is_implicit to M menu Switch is_implicit
sub switch_is_implicit {
  # print "switch_is_implicit\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as implicit!\n";
  }

  elsif (@arrows_discourse == 1) {
    my $impl = switch_is_implicit_one_discourse_arrow($this, 1); # switch is_implicit at the first (the only one) arrow
    ChangingFile(1);
    if ($impl) {
      set_inserted_connective_for_one_arrow($this,1);
    }
    # print STDERR "The is_implicit value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch is_implicit at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching is_implicit of the discourse arrow at position $position\n";
    my $impl = switch_is_implicit_one_discourse_arrow($this, $position); # switch is_implicit at the arrow given by $position
    ChangingFile(1);
    if ($impl) {
      set_inserted_connective_for_one_arrow($this,$position);
    }
    # print STDERR "is_implicit has been switched at the discourse arrow at position $position\n";
  }
} # switch_is_implicit

# Switches the attribute is_implicit of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_is_implicit_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/is_implicit');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/is_implicit',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/is_implicit','1');
    return '1';
  }
} # switch_is_implicit_one_discourse_arrow


=item switch_is_negated()

  Changes the boolean value of the attribute is_negated at a discourse arrow starting at the current node.

=cut

#bind switch_is_negated to t menu Switch is_negated
sub switch_is_negated {
  # print "switch_is_negated\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as negated!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_is_negated_one_discourse_arrow($this, 1); # switch is_negated at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The is_negated value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch is_negated at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching is_negated of the discourse arrow at position $position\n";
    switch_is_negated_one_discourse_arrow($this, $position); # switch is_negated at the arrow given by $position
    ChangingFile(1);
    # print STDERR "is_negated has been switched at the discourse arrow at position $position\n";
  }
} # switch_is_negated

# Switches the attribute is_negated of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_is_negated_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/is_negated');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/is_negated',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/is_negated','1');
    return '1';
  }
} # switch_is_negated_one_discourse_arrow


#bind switch_missing_arg_appropriate to 5 menu Switch switch_missing_arg_appropriate
sub switch_missing_arg_appropriate {
  # print "switch_missing_arg_appropriate\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as missing_arg_appropriate!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_missing_arg_appropriate_one_discourse_arrow($this, 1); # switch missing_arg_appropriate at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The missing_arg_appropriate value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch missing_arg_appropriate at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching missing_arg_appropriate of the discourse arrow at position $position\n";
    switch_missing_arg_appropriate_one_discourse_arrow($this, $position); # switch missing_arg_appropriate at the arrow given by $position
    ChangingFile(1);
    # print STDERR "missing_arg_appropriate has been switched at the discourse arrow at position $position\n";
  }
} # switch_missing_arg_appropriate

# Switches the attribute missing_arg_appropriate of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_missing_arg_appropriate_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/missing_arg_appropriate');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/missing_arg_appropriate',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/missing_arg_appropriate','1');
    return '1';
  }
} # switch_missing_arg_appropriate

#bind switch_missing_arg_inappropriate to 6 menu Switch switch_missing_arg_inappropriate
sub switch_missing_arg_inappropriate {
  # print "switch_missing_arg_inappropriate\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (un)marked as missing_arg_inappropriate!\n";
  }

  elsif (@arrows_discourse == 1) {
    switch_missing_arg_inappropriate_one_discourse_arrow($this, 1); # switch missing_arg_inappropriate at the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The missing_arg_inappropriate value of the (only one) discourse arrow has been switched!\n";
  }

  else {
    my @selection;
    ListQuery("Link to switch missing_arg_inappropriate at",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # print STDERR "Switching missing_arg_inappropriate of the discourse arrow at position $position\n";
    switch_missing_arg_inappropriate_one_discourse_arrow($this, $position); # switch missing_arg_inappropriate at the arrow given by $position
    ChangingFile(1);
    # print STDERR "missing_arg_inappropriate has been switched at the discourse arrow at position $position\n";
  }
} # switch_missing_arg_inappropriate

# Switches the attribute missing_arg_inappropriate of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new value of the attribute
sub switch_missing_arg_inappropriate_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_value = $this->attr('discourse/['.($position).']/missing_arg_inappropriate');
  if ($prev_value) {
    $node->set_attr('discourse/['.($position).']/missing_arg_inappropriate',undef);
    return undef;
  }
  else {
    $node->set_attr('discourse/['.($position).']/missing_arg_inappropriate','1');
    return '1';
  }
} # switch_missing_arg_inappropriate




=item switch_attribute_is_list_entry()

  Changes the boolean value of the attribute is_list_entry of the current node.

# # bind switch_attribute_is_list_entry to l menu Switch attribute is_list_entry
sub switch_attribute_is_list_entry {
  my $is_list_entry = $this->attr('is_list_entry');
  if (defined($is_list_entry) and ($is_list_entry eq 1)) {
    $this->set_attr('is_list_entry',undef);
  }
  else {
    $this->set_attr('is_list_entry',1);
  }
} # switch_attribute_is_list_entry

=cut


#bind set_remembered_basic_connectors_to_actual_node to n menu Set the connective
sub set_remembered_basic_connectors_to_actual_node {
  set_remembered_connectors_to_actual_node(0);
}

#bind set_remembered_extended_connectors_to_actual_node to m menu Set the extended connective
sub set_remembered_extended_connectors_to_actual_node {
  set_remembered_connectors_to_actual_node(1);
}

=item set_remembered_connectors_to_actual_node()

  It sets remembered nodes as a connective to a discourse arrow at the actual node. If there are several arrows, the user is asked to choose.
  The value of $extended determines whether the attributes for the basic connective are used (in case of '0') or the attributes of the extended connective (in case of '1').

=cut

sub set_remembered_connectors_to_actual_node {
  my ($extended) = @_;
  my $pa_remembered_t_nodes = FileUserData('remembered_nodes'); # remembered t-nodes
  my $pa_remembered_a_nodes = FileUserData('remembered_a_nodes'); # remembered a-nodes

  if (!defined($pa_remembered_t_nodes)) {
    $pa_remembered_t_nodes = [];
  }
  if (!defined($pa_remembered_a_nodes)) {
    $pa_remembered_a_nodes = [];
  }

  check_layers_of_connectors($pa_remembered_t_nodes, $pa_remembered_a_nodes); # check if some of the a-connectors can be replaced by a respective t-node

  my @connectors_t_ids = ();
  my @connectors_a_ids = ();
  if ($pa_remembered_t_nodes && @$pa_remembered_t_nodes) {
    @connectors_t_ids = map {$_->attr('id')} @$pa_remembered_t_nodes;
  }
  if ($pa_remembered_a_nodes && @$pa_remembered_a_nodes) {
    @connectors_a_ids = map {'a#' . $_->attr('id')} @$pa_remembered_a_nodes;
  }

  if (@connectors_t_ids or @connectors_a_ids) {
    if (!@connectors_t_ids) {
      @connectors_t_ids = ();
    }
    if (!@connectors_a_ids) {
      @connectors_a_ids = ();
    }
    set_connectors($this, $extended, \@connectors_t_ids, \@connectors_a_ids);
  }
  else {
    print STDERR "No connectors have been selected (remembered). Connectors will be set to empty lists.\n";
    set_connectors($this, $extended, (), ());
  }
  forget_all_remembered_nodes();
} # set_remembered_connectors_to_actual_node


sub check_layers_of_connectors {
  my ($pa_t_nodes, $pa_a_nodes) = @_;
  # now I will check if some of the a-connectors can be replaced by a respective t-node
  my @orig_connectors_t = @$pa_t_nodes;
  my @orig_connectors_a = @$pa_a_nodes;

  if (!scalar(@orig_connectors_a)) { # nothing to do
    return;
  }

  my @orig_connectors_t_ids = map {$_->attr('id')} @orig_connectors_t;
  my @orig_connectors_a_ids = map {$_->attr('id')} @orig_connectors_a;

  my @connectors_a_from_t_ids = map {get_analytical_counterparts_ids_from_node($_)} @orig_connectors_t;
  my @connectors_all_a_ids = @orig_connectors_a_ids; # all analytical nodes represented by the a- and t-nodes of the connective
  push (@connectors_all_a_ids, @connectors_a_from_t_ids);

  my $ph_a_t = FileUserData('a_nodes_to_t_nodes');
  my $changed = 0;

  foreach my $connector_a_id (@orig_connectors_a_ids) {
    # print STDERR "Checking @" . $connector_a_id . "@\n";
    #my $a_node = PML_T::GetANodeByID($connector_a_id);
    #my $form = $a_node->attr('m/form');
    #print STDERR "Checking @" . $connector_a_id . "@ - @" . $form . "@ ...\n";
    my $short = $connector_a_id;
    $short =~ s/^a#//;
    my $connector_t_id = $$ph_a_t{$short};
    if (defined($connector_t_id)) { # the a-node has a tectogrammatical counterpart
      # print STDERR "Testing the t-counterpart $connector_t_id ...\n";
      if ($connector_t_id =~ /__/) { # more than one tectogrammatical counterpart, needs to be processed manually
        # print STDERR "More than one tectogrammatical counterpart - needs to be processed manually.\n";
        next; # unable to fix automatically
      }
      my @connector_t_a_ids = get_analytical_counterparts_ids_from_id($connector_t_id);
      my $replacable = 1; # let us be optimistic
      foreach my $connector_t_a_id (@connector_t_a_ids) {
        my $connector_t_a_id_short = $connector_t_a_id;
        $connector_t_a_id_short =~ s/^a#//;
        if (!is_member_of_array($connector_t_a_id_short, @connectors_all_a_ids)) { # t-node has analytical counterparts that are not a part of the connective; the a-node cannot be replaced by the t-node
          # print STDERR "Cannot be replaced.\n";
          $replacable = 0;
          last;
        }
      }
      if ($replacable) {
        # print STDERR "Replacing $connector_a_id (@" . PML_T::GetANodeByID($connector_a_id)->attr('m/form') . "@) by $connector_t_id (@" . join(' ', map {PML_T::GetANodeByID($_)->attr('m/form')} get_analytical_counterparts_ids_from_id($connector_t_id)) . "@)\n";
        my $connector_t = PML::GetNodeByID($connector_t_id);
        if (!is_member_of_array($connector_t, @$pa_t_nodes)) {
          push(@$pa_t_nodes, $connector_t);
        }
        foreach my $connector_t_a_id (@connector_t_a_ids) { # take all analytical counterparts of the t-node and remove them from the list of a-connectors
          my $connector_a = PML_T::GetANodeByID($connector_t_a_id);
          @$pa_a_nodes = grep {$_ ne $connector_a} @$pa_a_nodes; # get rid of the reference to the analytical layer
        }
      }
    }
    else {
      # print STDERR "The a-node @" . $connector_a_id . "@ does not have a t-counterpart\n";
    }
  }
}

=item set_connectors($node, \@connectors_t_ids, \@connectors_a_ids)

  It sets given connectors ids to a discourse arrow at the given node. If there are several arrows, the user is asked to choose.
  If $extended is set (to 1), extended connective is set; if it is zero, attributes for the basic connective are used

=cut

sub set_connectors {
  my ($node, $extended, $pa_connectors_t_ids, $pa_connectors_a_ids) = @_;
  # print "set_connectors\n";

  my @arrows_discourse = ListV($node->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to set connective to!\n";
  }

  elsif (@arrows_discourse == 1) {
    set_connectors_to_one_arrow($node, 1, $extended, $pa_connectors_t_ids, $pa_connectors_a_ids); # set the connective to the first (the only one) arrow
    ChangingFile(1);
    # print STDERR "The connectors have been set to the only one discourse arrow.\n";
  }

  else {
    my @selection;
    ListQuery("Link to set the connective to",'browse',[existing_links_discourse($node)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    #my $total = existing_links($node);
    # print STDERR "Setting connectors to the discourse arrow at position $position\n";
    set_connectors_to_one_arrow($node, $position, $extended, $pa_connectors_t_ids, $pa_connectors_a_ids); # sets the connectors to the arrow given by $position
    ChangingFile(1);
    # print STDERR "The connectors have been set to the discourse arrow at position $position.\n";
  }

} # set_connectors



=item set_connectors_to_one_arrow($node, $position, \@connectors_ids)

  Sets given connectors to a discourse arrow at the given position at the given node.
  The value of $extended says whether atributes for basic ('0') or extended ('1') connective are used.

=cut

sub set_connectors_to_one_arrow {
  my ($node, $position, $extended, $pa_connectors_t_ids, $pa_connectors_a_ids) = @_;
  if ($extended) {
    $node->set_attr('discourse/['.($position).']/t-connectors_ext.rf',List(@$pa_connectors_t_ids));
    $node->set_attr('discourse/['.($position).']/a-connectors_ext.rf',List(@$pa_connectors_a_ids));
  }
  else {
    $node->set_attr('discourse/['.($position).']/t-connectors.rf',List(@$pa_connectors_t_ids));
    $node->set_attr('discourse/['.($position).']/a-connectors.rf',List(@$pa_connectors_a_ids));
  }
  return;
} # set_connectives_to_one_arrow



#bind group_remembered_nodes to g menu Group nodes
sub group_remembered_nodes {
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  group_nodes($ref_remembered_nodes);
  return;
} # group_remembered_nodes



=item group_nodes($ref_array_nodes)

  Creates a new group with a new unique id out of the given nodes. It finds the representative node of the group and stores it in
  C<FileUserData('groups_representative_nodes')>.

=cut

sub group_nodes {
  my ($ref_nodes_array) = @_;
  my $number_of_nodes = @$ref_nodes_array;
  if (defined($number_of_nodes) && $number_of_nodes>0) {
    my $group_id = get_free_group_id();
    my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
    $$ref_groups_representative_nodes{"$group_id"} = $$ref_nodes_array[0]; # the first node in the array is the first candidate for the representative node
    foreach my $node (@$ref_nodes_array) {
      add_group_id_to_node($node,$group_id);
      if (compare_nodes_representativity($node, $$ref_groups_representative_nodes{"$group_id"}) == -1) { # the new node is more representative
        $$ref_groups_representative_nodes{"$group_id"} = $node;
      }
    }
  }
  forget_all_remembered_nodes();
  return;
} # group_nodes



=item ungroup_the_current_group()

  It ungroups the nodes of the group with the given id.

=cut

#bind ungroup_the_current_group to Ctrl+g menu Ungroup
sub ungroup_the_current_group {
  my $current_group_id = FileUserData('clicked_group_id');
  if (defined($current_group_id)) {
    ungroup($current_group_id);
  }
  return;
} # ungroup_the_current_group



=item ungroup($group_id)

  It ungroups the given group.

=cut

sub ungroup {
  my ($group_id) = @_;
  print "group id to ungroup: $group_id\n";
  foreach my $root (GetTrees()) {
    foreach my $node (GetNodes($root)) {
      remove_group_id_from_node($node, $group_id);
    }
  }
  my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
  undef($$ref_groups_representative_nodes{"$group_id"}); # undef the representative node
  FileUserData('clicked_group_id', undef);
  FileUserData('clicked_group_number', undef);

} # ungroup



=item get_free_group_id()

  Returns a free id for a new group of nodes. It returns the smallest available positive integer.

=cut

sub get_free_group_id {
  my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
  if (!defined($ref_groups_representative_nodes)) { # there are yet no groups
    #print "No groups yet\n";
    return 1;
  }
  my @keys = keys(%$ref_groups_representative_nodes);
  my $size = @keys;
  #print "There are already $size groups\n";
  foreach my $i (1..$size) {
    #print "Testing group number $i\n";
    if (!defined($$ref_groups_representative_nodes{"$i"})) {
      #print "It is free.\n";
      return $i;
    }
  }
  my $new_index = $size+1;
  # all indexes from 1 to $size have been taken
  #print "All numbers up to $size have been taken. Returning $new_index\n";
  return $new_index;
} # get_free_group_id



=item add_group_id_to_node($node, $id)

  It adds the node to the group, i.e. it adds the group id to the node's list of groups ids.

=cut

sub add_group_id_to_node {
  my ($node, $id) = @_;
  if (!is_member_of_group($node, $id)) {
    AddToList($node,'discourse_groups', {'id' => $id});
  }
  return;
} # add_group_id_to_node



=item remove_group_id_from_node($node, $id)

  It removes the node from the group, i.e. it removes the group id from the node's list of groups ids.

=cut

sub remove_group_id_from_node {
  my ($node, $id) = @_;
  my $id_order = is_member_of_group($node, $id);
  if ($id_order) {
    @{$node->{discourse_groups}} = map {$this->{discourse_groups}->[$_]} grep {$_ ne $id_order-1} (0..$#{$this->{discourse_groups}});
  }
  return;
} # remove_group_id_from_node



#bind add_discourse_arrow_discourse to d menu Add discourse arrow
sub add_discourse_arrow_discourse {
  add_discourse_arrow('discourse');
}

#bind add_discourse_arrow_list to l menu Add list arrow
sub add_discourse_arrow_list {
  add_discourse_arrow('list');
}

#bind add_discourse_arrow_entrel to E menu Add entrel arrow
sub add_discourse_arrow_entrel {
  add_discourse_arrow('entrel');
}

#bind add_discourse_arrow_question_answer to A menu Add question-answer arrow
sub add_discourse_arrow_question_answer {
  add_discourse_arrow('question-answer');
}

#bind add_discourse_arrow_without_target_discourse to D menu Add discourse arrow without target
sub add_discourse_arrow_without_target_discourse {
  add_discourse_arrow_without_target('discourse');
}

sub add_discourse_arrow { 
  my ($arrow_type) = @_;
  # print "add_discourse_arrow\n";
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  if (!defined($ref_remembered_nodes)) {
    $ref_remembered_nodes = [];
  }
  my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
  if (!defined($ref_remembered_groups_ids)) {
    $ref_remembered_groups_ids = [];
  }
  my @nodes_remembered = @$ref_remembered_nodes;
  my @groups_ids_remembered = @$ref_remembered_groups_ids;
  my $number_of_remembered_nodes_and_groups = scalar(@nodes_remembered) + scalar(@groups_ids_remembered);
  if ($number_of_remembered_nodes_and_groups == 0) { # there are no remembered nodes or groups
    return;
  }
  my $start_group_id = FileUserData('clicked_group_id');
  my $start_representative_node = get_representative_node($start_group_id);
  my $count = 0;
  my $type;
  # first, go over remembered nodes (as targets)
  foreach my $remembered_node (@nodes_remembered) {
    if ($remembered_node->parent and $this->parent){
      $count++;
      if ($start_group_id) { # the link starts at the actual group
        AddToList($start_representative_node,'discourse', {'target_node.rf' =>$remembered_node->{id},
                                                           'type' => $arrow_type,
                                                           'start_range' => 'group',
                                                           'start_group_id' => $start_group_id,
                                                           'target_range' => $arrow_type eq 'list' ? undef : '0'});
      }
      else { # the link starts at the actual node
        AddToList($this,'discourse', {'target_node.rf' =>$remembered_node->{id},
                                      'type' => $arrow_type,
                                      'start_range' => '0',
                                      'target_range' => $arrow_type eq 'list' ? undef : '0'});
      }
      my $position = ListV($this->{discourse}); # the position of the added arrow
      if ($arrow_type eq 'discourse') { # discourse_type is needed to be set
        if ($count == 1) {
          $type = type_one_discourse_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
          if (!$type) { # cancel - remove the added arrow and do not add any other
            @{$this->{discourse}} = map {$this->{discourse}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{discourse}});
            return;
          }
        }
        else { # for the other arrows, use the same value as for the first one
          $this->set_attr('discourse/['.($position).']/discourse_type', $type);
        }
      }
      my $ok=source_one_arrow($this, 'discourse', $position, 'stored'); # take the stored value or ask the user for the source and set it at the arrow given by $position
    }
  }
  # second, go over remembered groups (as targets)
  foreach my $remembered_group_id (@groups_ids_remembered) {
    my $remembered_node = get_representative_node($remembered_group_id);
    if($remembered_node->parent and $this->parent){
      $count++;
      if ($start_group_id) { # the link starts at the actual group
        AddToList($start_representative_node,'discourse', {'target_node.rf' =>$remembered_node->{id},
                                                           'type' => $arrow_type,
                                                           'start_range' => 'group',
                                                           'start_group_id' => $start_group_id,
                                                           'target_range' => 'group',
                                                           'target_group_id' => $remembered_group_id});
      }
      else { # the link starts at the actual node
        AddToList($this,'discourse', {'target_node.rf' =>$remembered_node->{id},
                                      'type' => $arrow_type,
                                      'start_range' => '0',
                                      'target_range' => 'group',
                                      'target_group_id' => $remembered_group_id});
      }
      my $position = ListV($this->{discourse}); # the position of the added arrow
      if ($arrow_type eq 'discourse') { # discourse_type is needed to be set
        if ($count == 1) {
          $type = type_one_discourse_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
          if (!$type) { # cancel - remove the added arrow and do not add any other
            @{$this->{discourse}} = map {$this->{discourse}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{discourse}});
            return;
          }
        }
        else { # for the other arrows, use the same value as for the first one
          $this->set_attr('discourse/['.($position).']/discourse_type', $type);
        }
      }
    }
  }
  forget_all_remembered_nodes_and_groups(); #PML_T_Edit->ForgetRemembered();
  ChangingFile(1);
} # add_discourse_arrow

sub add_discourse_arrow_without_target { 
  my ($arrow_type) = @_;
  # print "add_discourse_arrow_without_target\n";
  my $start_group_id = FileUserData('clicked_group_id');
  my $start_representative_node = get_representative_node($start_group_id);
  my $count = 0;
  my $type;
  # first, go over remembered nodes (as targets)
  if ($this->parent){
    $count++;
    if ($start_group_id) { # the link starts at the actual group
      AddToList($start_representative_node,'discourse', {'target_node.rf' => undef,
                                                          'type' => $arrow_type,
                                                          'start_range' => 'group',
                                                          'start_group_id' => $start_group_id,
                                                          'target_range' => undef });
    }
    else { # the link starts at the actual node
      AddToList($this,'discourse', {'target_node.rf' => undef,
                                    'type' => $arrow_type,
                                    'start_range' => '0',
                                    'target_range' => undef});
    }
    my $position = ListV($this->{discourse}); # the position of the added arrow
    if ($arrow_type eq 'discourse') { # discourse_type is needed to be set
      if ($count == 1) {
        $type = type_one_discourse_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
        if (!$type) { # cancel - remove the added arrow and do not add any other
          @{$this->{discourse}} = map {$this->{discourse}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{discourse}});
          return;
        }
      }
      else { # for the other arrows, use the same value as for the first one
        $this->set_attr('discourse/['.($position).']/discourse_type', $type);
      }
    }
    my $ok=source_one_arrow($this, 'discourse', $position, 'stored'); # take the stored value or ask the user for the source and set it at the arrow given by $position
  }
  ChangingFile(1);
} # add_discourse_arrow_without_target


sub add_defined_discourse_arrow {
  my ($start_node, $target_node, $type, $discourse_type, $start_range, $target_range, $start_group_id, $target_group_id, $comment, $src, $pa_connectors_t_ids, $pa_connectors_a_ids, $pa_connectors_t_ext_ids, $pa_connectors_a_ext_ids, $is_secondary, $is_negated, $sense_PDTB3, $sense_PDTB3_manual, $sense1B_PDTB3, $sense1B_PDTB3_manual) = @_;

  my $target_node_id;
  if ($target_node) {
    $target_node_id = $target_node->attr('id');
  }

  AddToList($start_node,'discourse', {'target_node.rf' => $target_node_id,
                                                'type' => $type,
                                      'discourse_type' => $discourse_type,
                                         'start_range' => $start_range,
                                      'start_group_id' => $start_group_id,
                                        'target_range' => $target_range,
                                     'target_group_id' => $target_group_id,
                                             'comment' => $comment,
                                                 'src' => $src,
                                     't-connectors.rf' => $pa_connectors_t_ids,
                                     'a-connectors.rf' => $pa_connectors_a_ids,
                                 't-connectors_ext.rf' => $pa_connectors_t_ext_ids,
                                 'a-connectors_ext.rf' => $pa_connectors_a_ext_ids,
                                        'is_secondary' => $is_secondary,
                                          'is_negated' => $is_negated,
                                         'sense_PDTB3' => $sense_PDTB3,
                                  'sense_PDTB3_manual' => $sense_PDTB3_manual,
                                       'sense1B_PDTB3' => $sense1B_PDTB3,
                                'sense1B_PDTB3_manual' => $sense1B_PDTB3_manual
                                       });
  return;
} # add_defined_discourse_arrow


# It creates arrows (of type 'list') between subsequent remembered nodes (and/or groups).

#bind create_list_chain to Ctrl+l menu Create list chain
sub create_list_chain {
  my $ref_remembered_nodes = FileUserData('remembered_nodes');
  if (!defined($ref_remembered_nodes)) {
    $ref_remembered_nodes = [];
  }
  my $ref_remembered_groups_ids = FileUserData('remembered_groups_ids');
  if (!defined($ref_remembered_groups_ids)) {
    $ref_remembered_groups_ids = [];
  }
  my $number_of_remembered_nodes_and_groups = scalar(@$ref_remembered_nodes) + scalar(@$ref_remembered_groups_ids);
  if ($number_of_remembered_nodes_and_groups == 0) { # there are no remembered nodes or groups
    return;
  }

  my $refha_groups_representative_nodes = FileUserData('groups_representative_nodes');
  my %ha_group_represented_by_node; # hash for retrieving represented groups
  my @ar_remebered_groups_representative_nodes = ();
  foreach my $group_id (@$ref_remembered_groups_ids) { # go through the remembered groups
    my $representative_node = $$refha_groups_representative_nodes{$group_id}; # retrieve the representative node
    push(@ar_remebered_groups_representative_nodes, $representative_node); # create the array of the representative nodes
    $ha_group_represented_by_node{$representative_node} = $group_id; # remember that the node represents the group
  }

  my @ar_nodes_remembered = @$ref_remembered_nodes; # take the remembered nodes
  push (@ar_nodes_remembered, @ar_remebered_groups_representative_nodes); # add the representative nodes of the remembered groups

  my @ar_nodes_remembered_sorted = sort { compare_nodes_positions_deepord($a, $b) } @ar_nodes_remembered;
  my $prev_node = undef;
  my $actual_node = undef;
  foreach my $next_node (@ar_nodes_remembered_sorted) { # go through the nodes - members of the 'list'
    # I need to know one node back - that's where the arrow will point to
    # and also one node forward - to determine the start_range of the arrow
    if ($actual_node) {
      my $start_group_id = $ha_group_represented_by_node{$actual_node};
      my $start_range;
      if ($start_group_id) {
        $start_range = 'group';
      }
      else {
        my ($a_file_name, $actual_node_tree_index, $a_file) = LocateNode($actual_node);
        my ($b_file_name, $next_node_tree_index, $b_file) = LocateNode($next_node);
        $start_range = $next_node_tree_index - $actual_node_tree_index;
        if ($start_range > 0) {
          $start_range--; # the next tree belongs to the next member
        }
      }
      add_defined_discourse_arrow($actual_node, $prev_node, 'list', undef, $start_range, undef, $start_group_id, undef, undef, undef, undef, undef, undef, undef);
    }
    $prev_node = $actual_node;
    $actual_node = $next_node;
  }
  # now handle the last node:
  my $start_range = 0;
  my $start_group_id = $ha_group_represented_by_node{$actual_node};
  if ($start_group_id) {
    $start_range = 'group';
  }
  add_defined_discourse_arrow($actual_node, $prev_node, 'list', undef, $start_range, undef, $start_group_id, undef, undef, undef, undef, undef, undef, undef);
  if ($start_range ne 'group') {
    my $position = ListV($actual_node->attr('discourse')); # the position of the added arrow
    range_discourse_arrow($actual_node, $position, 'start_range', 'Range of the last member of the list'); # ask the user for the start range and set it at the position
  }
  forget_all_remembered_nodes_and_groups();
  ChangingFile(1);
} # create_list_chain


sub is_list_entry {
  my ($node) = @_;
  my @discourse_arrows = ListV($node->attr('discourse'));
  foreach my $discourse_arrow (@discourse_arrows) {
    my $type = $discourse_arrow->{'type'};
    if ($type && $type eq 'list') {
      return 1;
    }
  }
  return 0;
}


=pod

item get_represented_group($node)

  If the given node is a representative node of a group, it returns the id of the group (the first such group).
  If not, it returns 0.

cut

sub get_represented_group {
  my ($node) = @_;
  my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
  foreach my $group_id (keys %$ref_groups_representative_nodes) {
    my $group_representative_node = $$ref_groups_representative_nodes{"$group_id"};
    if ($group_representative_node eq $node) {
      return $group_id;
    }
  }
  return 0;
} # get_represented_group

=cut


=item get_representative_node($group_id)

  It returns the representative node of the group with the given id. If there is no such group, undef is returned.

=cut

sub get_representative_node {
  my ($group_id) = @_;
  if (!defined($group_id)) {
    return undef;
  }
  my $ref_groups_representative_nodes = FileUserData('groups_representative_nodes');
  if (exists($$ref_groups_representative_nodes{"$group_id"})) {
    return $$ref_groups_representative_nodes{"$group_id"};
  }
  else {
    return undef;
  }
} # get_representative_node



# Returns a list of discourse links going from the current node
sub existing_links_discourse {
  my ($node) = @_;
  my $i;
  my @values;

  foreach my $link (ListV($node->{discourse})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target_node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    my $type = $link->{'type'} || '';
    my $discourse_type = $link->{'discourse_type'} || '';
    my $value = "($i) t_lemma=$node_tlemma  type=$type";
    if ($type eq 'discourse') {
      $value .= "  discourse_type=$discourse_type";
    }
    push(@values, $value);
  }
  return @values;
}


#bind reverse_a_discourse_arrow to v menu Reverse a discourse arrow
sub reverse_a_discourse_arrow {
  # print "reverese_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $orig_target_id = 0;

  if (@arrows_discourse == 0) {
    # print "No discourse arrow to be reversed!\n";
  }

  elsif (@arrows_discourse == 1) {
    my @a_aa = get_arrayed_discourse_arrow($this, $arrows_discourse[0]);
    my $new_start_node = PML::GetNodeByID($a_aa[1]);
    #add_defined_discourse_arrow($start_node, $target_node, $type, $discourse_type, $start_range, $target_range, $start_group_id, $target_group_id, $comment, $src, $pa_connectors_t_ids, $pa_connectors_a_ids);
    add_defined_discourse_arrow($new_start_node, $a_aa[0], $a_aa[2], $a_aa[3], $a_aa[5], $a_aa[4], $a_aa[7], $a_aa[6], $a_aa[8], $a_aa[9], $a_aa[10], $a_aa[11], $a_aa[12], $a_aa[13], $a_aa[14], $a_aa[15], $a_aa[16], $a_aa[17], $a_aa[18], $a_aa[19]);
    $this->{discourse}=List();
    $this=$new_start_node;
    ChangingFile(1);
    # print "The (only one) discourse arrow was reversed!\n";
  }

  else {
    my @selection;
    ListQuery("Link to reverse",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # my $total = existing_links($this);
    my $new_start_node = reverse_a_given_arrow($this, $position);
    $this=$new_start_node;
    # print "A discourse arrow ($position) was reversed\n";
    ChangingFile(1);
  }
} # reverse_a_discourse_arrow

sub reverse_a_given_arrow {
  my ($node, $position) = @_;
  my @arrows_discourse = ListV($node->{discourse});
  my @a_aa = get_arrayed_discourse_arrow($node, $arrows_discourse[$position-1]);
  my $new_start_node = PML::GetNodeByID($a_aa[1]);
  #add_defined_discourse_arrow($start_node, $target_node, $type, $discourse_type, $start_range, $target_range, $start_group_id, $target_group_id, $comment, $src, $pa_connectors_t_ids, $pa_connectors_a_ids);
  add_defined_discourse_arrow($new_start_node, $a_aa[0], $a_aa[2], $a_aa[3], $a_aa[5], $a_aa[4], $a_aa[7], $a_aa[6], $a_aa[8], $a_aa[9], $a_aa[10], $a_aa[11], $a_aa[12], $a_aa[13], $a_aa[14], $a_aa[15], $a_aa[16], $a_aa[17], $a_aa[18], $a_aa[19]);
  @{$node->{discourse}} = map {$node->{discourse}->[$_]} grep {$_ ne $position-1} (0..$#{$node->{discourse}});
  return $new_start_node;
}

sub get_arrayed_discourse_arrow {
  my ($start_node, $link) = @_;
  my @a_aa = ($start_node, $link->{'target_node.rf'}, $link->{'type'}, $link->{'discourse_type'},
              $link->{'start_range'}, $link->{'target_range'}, $link->{'start_group_id'}, $link->{'target_group_id'},
              $link->{'comment'}, $link->{'src'}, $link->{'t-connectors.rf'}, $link->{'a-connectors.rf'}, $link->{'t-connectors_ext.rf'}, $link->{'a-connectors_ext.rf'}, $link->{'is_secondary'}, $link->{'is_negated'}, $link->{'sense_PDTB3'}, $link->{'sense_PDTB3_manual'}, $link->{'sense1B_PDTB3'}, $link->{'sense1B_PDTB3_manual'} );
  return @a_aa;
} # get_arrayed_discourse_arrow


#bind remove_a_discourse_arrow to x menu Remove a discourse arrow
sub remove_a_discourse_arrow {
  # print "remove_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $orig_target_id = 0;

  if (@arrows_discourse == 0) {
    # print "No discourse arrow to be removed!\n";
  }

  elsif (@arrows_discourse == 1) {
    $this->{discourse}=List();
    ChangingFile(1);
    # print "The (only one) discourse arrow was removed!\n";
  }

  else {
    my @selection;
    ListQuery("Link to remove",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # my $total = existing_links($this);
    @{$this->{discourse}} = map {$this->{discourse}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{discourse}});
    # print "A discourse arrow ($position) was removed\n";
    ChangingFile(1);
  }
} # remove_a_discourse_arrow



#bind remove_a_PDTB3_arrow to X menu Remove a PDTB3 arrow
sub remove_a_PDTB3_arrow {
  # print "remove_a_PDTB3_arrow\n";

  my @arrows_pdtb3 = ListV($this->{'discourse-pdtb3'});

  my $orig_target_id = 0;

  if (@arrows_pdtb3 == 0) {
    # print "No PDTB3 arrow to be removed!\n";
  }

  elsif (@arrows_pdtb3 == 1) {
    $this->{'discourse-pdtb3'}=List();
    ChangingFile(1);
    # print "The (only one) PDTB3 arrow was removed!\n";
  }

  else {
    my @selection;
    ListQuery("Link to remove",'browse',[existing_links_PDTB3($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # my $total = existing_links($this);
    @{$this->{'discourse-pdtb3'}} = map {$this->{'discourse-pdtb3'}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{'discourse-pdtb3'}});
    # print "A PDTB3 arrow ($position) was removed\n";
    ChangingFile(1);
  }
} # remove_a_PDTB3_arrow


# Returns a list of PDTB3 links going from the current node
sub existing_links_PDTB3 {
  my ($node) = @_;
  my $i;
  my @values;

  foreach my $link (ListV($node->{'discourse-pdtb3'})) {
    $i++;
    my $node = PML::GetNodeByID($link->{'target_node.rf'});
    my $node_tlemma;
    if ($node) {
      $node_tlemma = $node->{t_lemma};
    }
    else {
      $node_tlemma = "???";
    }
    my $type = $link->{'type'} || '';
    my $sense = $link->{'sense1A'} || '';
    my $value = "($i) t_lemma=$node_tlemma  type=$type";
    if ($type =~ /^(Explicit|AltLex|AltLexC)$/) {
      $value .= " sense1A=$sense";
    }
    push(@values, $value);
  }
  return @values;
}


#bind transform_a_PDTB3_arrow to T menu PDTB3 arrow -> discourse arrow
sub transform_a_PDTB3_arrow {
  # print "transform_a_PDTB3_arrow\n";

  my @arrows_pdtb3 = ListV($this->{'discourse-pdtb3'});

  my $orig_target_id = 0;

  if (@arrows_pdtb3 == 0) {
    # print "No PDTB3 arrow to be transformed!\n";
  }

  elsif (@arrows_pdtb3 == 1) {
    transform_one_PDTB3_arrow($this, 1);
    $this->{'discourse-pdtb3'}=List();
    ChangingFile(1);
    # print "The (only one) PDTB3 arrow was transformed!\n";
  }

  else {
    my @selection;
    ListQuery("Link to transform",'browse',[existing_links_PDTB3($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    # my $total = existing_links($this);
    transform_one_PDTB3_arrow($this, $position);
    @{$this->{'discourse-pdtb3'}} = map {$this->{'discourse-pdtb3'}->[$_]} grep {$_ ne $position-1} (0..$#{$this->{'discourse-pdtb3'}});
    # print "A PDTB3 arrow ($position) was transformed\n";
    ChangingFile(1);
  }
} # transform_a_PDTB3_arrow


# Transforms one PDTB3 arrow to a discourse arrow
sub transform_one_PDTB3_arrow {
  my ($node, $position) = @_;
  my $sense1A = $node->attr('discourse-pdtb3/['.($position).']/sense1A');
  my $sense1B = $node->attr('discourse-pdtb3/['.($position).']/sense1B');
  my $discourse_type = $sense2type{$sense1A};
  my $a_connectors = $node->attr('discourse-pdtb3/['.($position).']/a-nodes.rf');
  my $target_node_rf = $node->attr('discourse-pdtb3/['.($position).']/target_node.rf');
  my $pdtb3_type = $node->attr('discourse-pdtb3/['.($position).']/type');
  my $type;
  my $is_secondary;
  my $is_implicit;
  if ($pdtb3_type =~ /^(Explicit|AltLex|AltLexC|Implicit)$/) {
    $type = 'discourse';
    if ($pdtb3_type =~ /^(AltLex|AltLexC)$/) {
      $is_secondary = 1;
    }
    if ($pdtb3_type =~ /^(Implicit)$/) {
      $is_implicit = 1;
    }
  }
  elsif ($pdtb3_type =~ /^(EntRel)$/) {
    $type = 'entrel';
  }
  elsif ($pdtb3_type =~ /^(Hypophora)$/) {
    $type = 'question-answer';
  }
  elsif ($pdtb3_type =~ /^(NoRel)$/) {
    $node->set_attr('discourse_macrostructure', 'coherence_gap');
  }
  
  if ($type) {
    AddToList($node, 'discourse', {'target_node.rf' => $target_node_rf,
                                  'type' => $type,
                                  'discourse_type' => $discourse_type,
                                  'a-connectors.rf' => $a_connectors,
                                  'start_range' => '0',
                                  'target_range' => '0',
                                  'is_secondary' => $is_secondary,
                                  'is_implicit' => $is_implicit,
                                  'sense_PDTB3' => $sense1A,
                                  'sense1B_PDTB3' => $sense1B,
                                  'comment' => 'PHASE:1 MANUALLY-FROM-PDTB'
                                 });

  }
} # transform_one_PDTB3_arrow


# Returns a list of possible values of attribute discourse_special
sub possible_values_discourse_special {
  my @values = PML::Schema()->find_type_by_path('!discourse-special.type')->get_values();
  push(@values, 'undef');
  return @values;
} # possible_values_discourse_special

# Returns a list of possible values of attribute discourse_feature
sub possible_values_discourse_feature {
  my @values = PML::Schema()->find_type_by_path('!discourse-feature.type')->get_values();
  push(@values, 'undef');
  return @values;
} # possible_values_discourse_feature

# Returns a list of possible values of attribute discourse_macrostructure
sub possible_values_discourse_macrostructure {
  my @values = PML::Schema()->find_type_by_path('!discourse-macrostructure.type')->get_values();
  push(@values, 'undef');
  return @values;
} # possible_values_discourse_macrostructure

# Returns a list of possible types of the discourse link
sub possible_types_discourse {
  my @values = PML::Schema()->find_type_by_path('!t-discourse-type.type')->get_values();
  return @values;
} # possible_types_discourse

# Returns a list of possible PDTB3 senses of the discourse link
sub possible_sense3s_discourse {
  my @values = PML::Schema()->find_type_by_path('!semclass-pdtb3.type')->get_values();
  return @values;
} # possible_sense3s_discourse

# Returns a list of possible types of the discourse link
sub possible_ranges_discourse {
  my @values = qw(0 1 2 3 4 5 6 7 8 9 10 group forward backward -1 -2 -3 -4 -5 -6 -7 -8 -9 -10);
  return @values;
} # possible_ranges_discourse


# Returns a list of possible genres of a document
sub possible_document_genres {
  my @values = qw(review invitation letter advice program plot sport comment news essay overview description weather survey topic_interv person_interv collection caption metatext other);
  return @values;
} # possible_document_genres


# Asks the user for the type of the discourse arrow and sets the type of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new type of the arrow
sub type_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_type = $this->attr('discourse/['.($position).']/discourse_type');
  my @selection = ($prev_type);
  ListQuery("Type of the link",'browse',[possible_types_discourse()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_type = $selection[0];
  # print "Selected type: $selected_type\n";
  $node->set_attr('discourse/['.($position).']/discourse_type',$selected_type);
  return $selected_type;
} # type_one_discourse_arrow



# Asks the user for the PDTB3 sense of the discourse arrow and sets the sense of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# returns the new PDTB3 sense of the arrow
sub sense3_one_discourse_arrow {
  my ($node, $position) = @_;
  my $prev_sense3 = $this->attr('discourse/['.($position).']/sense_PDTB3_manual') // $this->attr('discourse/['.($position).']/sense_PDTB3');
  my @selection = ($prev_sense3);
  ListQuery("PDTB3 sense of the link",'browse',[possible_sense3s_discourse()],\@selection,{dialog => {-popover=>'cursor',}}) || return 0;
  my $selected_sense3 = $selection[0];
  # print "Selected PDTB3 sense: $selected_sense3\n";
  $node->set_attr('discourse/['.($position).']/sense_PDTB3_manual',$selected_sense3);
  return $selected_sense3;
} # sense3_one_discourse_arrow



# Asks the user for the range of the discourse arrow and sets the range of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
# third argument - the attribute to be changed (either "start_range" or "target_range")
# fourth argument - a label to display to the user (either "Start range of the link" or "Target range of the link")
# returns the new range of the arrow
sub range_discourse_arrow {
  my ($node, $position, $attribute, $label) = @_;
  my $prev_range = $this->attr('discourse/['.($position).']/'.$attribute);
  my @selection = ($prev_range);
  my @possible_ranges = possible_ranges_discourse();
  if (@possible_ranges) { # workaround to make the selection window wide enough to make the title of the window visible
    push (@possible_ranges, "                                                                                ");
  }
  ListQuery($label,'browse',[@possible_ranges],\@selection,{dialog => {-popover=>'cursor',-width=>400,}}) || return 0;
  my $selected_range = $selection[0];
  # print "Selected range: $selected_range\n";
  $this->set_attr('discourse/['.($position).']/'.$attribute,$selected_range);
  return $selected_range;
} # start_range_discourse_arrow


=pod


=cut

# Asks the user for a comment of the discourse arrow and sets the comment of the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
sub comment_one_discourse_arrow {
  my ($node, $position) = @_;
  my $old_value = $this->attr('discourse/['.($position).']/comment');
  my $new_value = dialog_edit_text_area ("Edit the comment of the discourse arrow", $old_value, "Ok", "Cancel");
  if ($new_value) {
    $node->set_attr('discourse/['.($position).']/comment', $new_value);
  }
  else {
    $node->set_attr('discourse/['.($position).']/comment', undef);
  }
  return 1;
}



#bind type_a_discourse_arrow to r menu (Re-)type a discourse arrow
sub type_a_discourse_arrow {
  # print "type_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (re-)typed!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = type_one_discourse_arrow($this, 1); # ask the user for the type and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been (re-)typed!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to (re-)type",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    #my $total = existing_links($this);
    # print STDERR "(Re-)typing the discourse arrow at position $position\n";
    $changed = type_one_discourse_arrow($this, $position); # ask the user for the type and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) was (re-)typed\n";
    }
  }
} # type_a_discourse_arrow



#bind sense3_a_discourse_arrow to 3 menu (Re-)sense3 a discourse arrow
sub sense3_a_discourse_arrow {
  # print "sense3_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be (re-)sense3ed!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = sense3_one_discourse_arrow($this, 1); # ask the user for the sense and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been (re-)sense3ed!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to (re-)sense3",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    #my $total = existing_links($this);
    # print STDERR "(Re-)sense3ing the discourse arrow at position $position\n";
    $changed = sense3_one_discourse_arrow($this, $position); # ask the user for the sense and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) was (re-)sense3ed\n";
    }
  }
} # sense3_a_discourse_arrow


# Re-sense a discourse arrow and store info about the change in comment starting with PHASE:3
#bind phase3_resense_a_discourse_arrow to S menu Phase:3 Re-sense a discourse arrow
sub phase3_resense_a_discourse_arrow {
  # print STDERR "phase3_resense_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be re-sensed!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = phase3_resense_one_discourse_arrow($this, 1); # set the sense_manual and comment at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been re-sensed and commented with PHASE:3 RESENSED.\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to re-sense",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Re-sensing and commenting the discourse arrow at position $position\n";
    $changed = phase3_resense_one_discourse_arrow($this, $position); # re-sense and set the comment for the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been re-sensed and commented with PHASE:3 RESENSED\n";
    }
  }
} # phase3_resense_a_discourse_arrow


sub phase3_resense_one_discourse_arrow {
  my ($node, $position) = @_;
  # re-sense the arrow
  my $old_sense = $this->attr('discourse/['.($position).']/sense_PDTB3_manual') // $this->attr('discourse/['.($position).']/sense_PDTB3');
  my $new_sense = sense3_one_discourse_arrow($node, $position);
  if ($new_sense and $old_sense ne $new_sense) {
    # comment it with PHASE:3 RESENSED $old_sense->$new_sense
    my $old_value = $this->attr('discourse/['.($position).']/comment');
    #if ($old_value !~ /^PHASE:3 RESENSED/) {
    $old_value =~ s/^PHASE:\d\s*//;
    $old_value =~ s/^\s+//;
    my $delimiter = $old_value ? '; ' : '';
    my $new_value = "PHASE:3 RESENSED $old_sense" . '->' . "$new_sense$delimiter$old_value";
    $node->set_attr('discourse/['.($position).']/comment', $new_value);
    #}
    return 1;
  }
  return 0;
}



# Re-type a discourse arrow and store info about the change in comment starting with PHASE:3
#bind phase3_retype_a_discourse_arrow to R menu Phase:3 Re-type a discourse arrow
sub phase3_retype_a_discourse_arrow {
  # print STDERR "phase3_retype_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 1; # never set later !!!

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be commented!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = phase3_retype_one_discourse_arrow($this, 1); # set the discourse type and comment at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been re-typed commented with PHASE:3 RETYPED.\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to comment",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Re-typing and commenting the discourse arrow at position $position\n";
    $changed = phase3_retype_one_discourse_arrow($this, $position); # re-type and set the comment for the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been re-typed and commented with PHASE:3 RETYPED\n";
    }
  }
} # phase3_retype_a_discourse_arrow


sub phase3_retype_one_discourse_arrow {
  my ($node, $position) = @_;
  # re-type the arrow
  my $old_type = $this->attr('discourse/['.($position).']/discourse_type');
  my $new_type = type_one_discourse_arrow($node, $position);
  if ($new_type and $old_type ne $new_type) {
    # comment it with PHASE:3 RETYPED $old_type->$new_type
    my $old_value = $this->attr('discourse/['.($position).']/comment');
    #if ($old_value !~ /^PHASE:3 RETYPED/) {
    $old_value =~ s/^PHASE:\d\s*//;
    $old_value =~ s/^\s+//;
    my $delimiter = $old_value ? '; ' : '';
    my $new_value = "PHASE:3 RETYPED $old_type" . '->' . "$new_type$delimiter$old_value";
    $node->set_attr('discourse/['.($position).']/comment', $new_value);
    #}
    return 1;
  }
  return 0;
}


#bind phase2_manual_a_discourse_arrow to 2 menu Phase:2 MANUAL a discourse arrow
sub phase2_manual_a_discourse_arrow {
  # print STDERR "phase2_manual_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 1; # never set later !!!

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be commented!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = phase2_manual_one_discourse_arrow($this, 1); # set the comment at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been commented with PHASE:2 MANUAL.\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to comment",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Commenting the discourse arrow at position $position\n";
    $changed = phase2_manual_one_discourse_arrow($this, $position); # set the comment for the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been commented with PHASE:2 MANUAL\n";
    }
  }
} # phase2_manual_a_discourse_arrow


sub phase2_manual_one_discourse_arrow {
  my ($node, $position) = @_;
  my $old_value = $this->attr('discourse/['.($position).']/comment');
  if ($old_value =~ /^PHASE:2 MANUAL/) {
    return 0;
  }
  $old_value =~ s/^PHASE:\d\s*//;
  $old_value =~ s/^\s+//;
  my $delimiter = $old_value ? '; ' : '';
  my $new_value = "PHASE:2 MANUAL$delimiter$old_value";
  $node->set_attr('discourse/['.($position).']/comment', $new_value);
  return 1;
}



#bind start_range_discourse_arrow to w menu Set start range of a discourse arrow
sub start_range_discourse_arrow {
  # print "start_range_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be ranged!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = range_discourse_arrow($this, 1, 'start_range', 'Start range of the link'); # ask the user for the start range and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been start-ranged!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to set start range to",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    #my $total = existing_links($this);
    # print STDERR "Start-ranging the discourse arrow at position $position\n";
    $changed = range_discourse_arrow($this, $position, 'start_range', 'Start range of the link'); # ask the user for the start range and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been start-ranged\n";
    }
  }
} # start_range_discourse_arrow



#bind target_range_discourse_arrow to e menu Set target range of a discourse arrow
sub target_range_discourse_arrow {
  # print "target_range_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 0;

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be ranged!\n";
  }

  elsif (@arrows_discourse == 1) {
    my $type = $arrows_discourse[0]->{'type'};
    if ($type eq 'list') {
      print STDERR "A 'list' arrow is not supposed to have the target_range set.\n";
      return;
    }
    $changed = range_discourse_arrow($this, 1, 'target_range', 'Target range of the link'); # ask the user for the target range and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been target-ranged!\n";
    }
  }

  else {
    my @selection;
    ListQuery("Link to set target range to",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $type = $arrows_discourse[$position-1]->{'type'};
    if ($type eq 'list') {
      print STDERR "A 'list' arrow is not supposed to have the target_range set.\n";
      return;
    }
    # print STDERR "Target-ranging the discourse arrow at position $position\n";
    $changed = range_discourse_arrow($this, $position, 'target_range', 'Target range of the link'); # ask the user for the target range and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been target-ranged\n";
    }
  }
} # target_range_discourse_arrow


#bind source_a_discourse_arrow to o menu Set source of a discourse arrow
sub source_a_discourse_arrow {
  # print STDERR "source_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be commented!\n";
  }

  elsif (@arrows_discourse == 1) {
    my $changed = source_one_arrow($this, 'discourse', 1, 'arrow'); # ask the user for the src and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been set source of!\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to set source of",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Setting source of the discourse arrow at position $position\n";
    my $changed = source_one_arrow($this, 'discourse', $position, 'arrow'); # ask the user for the src and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been set source of\n";
    }
  }
} # source_a_discourse_arrow


#bind comment_a_discourse_arrow to c menu Comment a discourse arrow
sub comment_a_discourse_arrow {
  # print STDERR "comment_a_discourse_arrow\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 1; # never set later !!!

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be commented!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = comment_one_discourse_arrow($this, 1); # ask the user for the comment and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been commented!\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to comment",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Commenting the discourse arrow at position $position\n";
    $changed = comment_one_discourse_arrow($this, $position); # ask the user for the comment and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been commented\n";
    }
  }
} # comment_a_discourse_arrow


#bind comment_a_node to Ctrl+c menu Comment a node
sub comment_a_node {
  # print STDERR "comment_a_node\n";
  my $old_value = $this->attr('discourse_comment');
  my $new_value = dialog_edit_text_area ("Edit the comment of the node", $old_value, "Ok", "Cancel");
  if ($old_value or $new_value) {
    if (!($old_value and $new_value) or ($old_value ne $new_value)) {
      $this->set_attr('discourse_comment', $new_value);
      ChangingFile(1);
      # print STDERR "The node has been commented!\n";
    }
  }
} # comment_a_node


#bind set_inserted_connective to I menu Set an inserted connective
sub set_inserted_connective {
  # print STDERR "set_inserted_connective\n";

  my @arrows_discourse = ListV($this->{discourse});

  my $changed = 1; # never set later !!!

  if (@arrows_discourse == 0) {
    # print STDERR "No discourse arrow to be worked with!\n";
  }

  elsif (@arrows_discourse == 1) {
    $changed = set_inserted_connective_for_one_arrow($this, 1); # ask the user for the inserted connective and set it at the first (the only one) arrow
    if ($changed) {
      ChangingFile(1);
      # print STDERR "The (only one) discourse arrow has been inserted a connective to ;-)!\n";
    }
  }
  else {
    my @selection;
    ListQuery("Link to insert a connective to",'browse',[existing_links_discourse($this)],\@selection,{dialog => {-popover=>'cursor',}}) || return;
    $selection[0]=~/\((\d+)\)/;
    my $position = $1;
    my $total = existing_links_discourse($this);
    # print STDERR "Inserting a connective to the discourse arrow at position $position\n";
    $changed = set_inserted_connective_for_one_arrow($this, $position); # ask the user for the inserted connective and set it at the arrow given by $position
    if ($changed) {
      ChangingFile(1);
      # print STDERR "A discourse arrow ($position) has been inserted a connective to ;-)\n";
    }
  }
} # set_inserted_connective

# Asks the user for an inserted connective of the discourse arrow and sets it to the given arrow
# first argument - the node where the arrow starts
# second argument - the order of the arrow (there may be several discourse arrows starting here; starting from 1)
sub set_inserted_connective_for_one_arrow {
  my ($node, $position) = @_;
  my $old_value = $this->attr('discourse/['.($position).']/connective_inserted');
  my $new_value = dialog_edit_text_area ("Edit the inserted connective of the discourse arrow", $old_value, "Ok", "Cancel");
  if ($new_value) {
    $this->set_attr('discourse/['.($position).']/connective_inserted', $new_value);
  }
  else {
    $this->set_attr('discourse/['.($position).']/connective_inserted', undef);
  }
  return 1;
}



## PP+ZZ

sub get_nodelist_hook {
    my ($fsfile, $treeNo, $currentNode, $hidden)=@_;
    my $root = $fsfile->tree($treeNo);
    my @nodes;
    if (FileUserData('folded_clauses')) {
      @nodes = ($root,
		sort { $a->{deepord} <=> $b->{deepord} }
		grep {$_->{is_clause_head} or $_->{is_clause_coord}} $root->descendants);
    } else {
      @nodes = ($root, sort { $a->{deepord} <=> $b->{deepord} } $root->descendants);
    }
    $currentNode = $nodes[0] unless $currentNode && first { $_==$currentNode } @nodes;
    return [\@nodes, $currentNode];
}



#bind toggle_clause_folding to Ctrl+k menu Toggle Clause Folding
sub toggle_clause_folding {
  my $be_folded = !FileUserData('folded_clauses');
  FileUserData('folded_clauses', $be_folded);
  my $last_stylesheet = GetCurrentStylesheet();
  if ($be_folded) {
    if ($last_stylesheet =~ /25/) {
      SetCurrentStylesheet('PML_T_25_Discourse_Folded');
    }
    else {
      SetCurrentStylesheet('PML_T_Discourse_Folded');
    }
  } else {
    if ($last_stylesheet =~ /25/) {
      SetCurrentStylesheet('PML_T_25_Discourse');
    }
    else {
      SetCurrentStylesheet('PML_T_Discourse');
    }
  }
  ChangingFile(0);
}



sub collect_clause_nodes {
    my ($node, $clause_head) = @_;

    my $clause_head_2_all_clause_nodes = FileUserData('precomputed_clause_segmentation');
    my $saved_clause_head_2_all_clause_nodes = FileUserData('saved_precomputed_clause_segmentation');
    my $node_id_to_clause_head_id = FileUserData('precomputed_clause_head_id');

    if ($node->{is_clause_coord}) {
        $clause_head_2_all_clause_nodes->{$node} = [$node]; # added by JM
        foreach my $child ($node->children) {
            collect_clause_nodes($child,$child);
        }
    }

    elsif ($node->{is_clause_head}) {
        $clause_head_2_all_clause_nodes->{$node} = [$node];
        $saved_clause_head_2_all_clause_nodes->{$node} = [$node];
	$node_id_to_clause_head_id->{$node->{id}}=$node->{id};
        foreach my $child ($node->children) {
            collect_clause_nodes($child, $node);
        }
    }

    else {
#        print "Adding $node->{t_lemma} to $clause_head->{t_lemma}\n";
        push @{$clause_head_2_all_clause_nodes->{$clause_head}}, $node;
        push @{$saved_clause_head_2_all_clause_nodes->{$clause_head}}, $node;
	$node_id_to_clause_head_id->{$node->{id}}=$clause_head->{id};
        foreach my $child ($node->children) {
            collect_clause_nodes($child,$clause_head);
        }
    }
}


sub precompute_clause_segmentation {
  return if FileUserData('precomputed_clause_segmentation');
  my $clause_head_2_all_clause_nodes={};
  my $saved_clause_head_2_all_clause_nodes={};
  FileUserData('precomputed_clause_segmentation',$clause_head_2_all_clause_nodes);
  FileUserData('saved_precomputed_clause_segmentation',$saved_clause_head_2_all_clause_nodes);
  FileUserData('precomputed_clause_head_id',{});
    # marking clause coordinations
    foreach my $root (GetTrees()) { # originally: ($grp->{FSFile}->trees) {

        foreach my $node ($root->descendants) {
            if ($node->parent eq $root) {
              $node->{is_clause_head} = 1; # added by JM
            }
            if ($node->attr('gram/tense') && $node->attr('gram/tense') =~ /^(ant|sim|post)$/) {
                $node->{is_clause_head} = 1;
            }
        }

        foreach my $node ($root->descendants) {
            if ($node->{nodetype} eq "coap"
                    and grep {$_->{is_clause_head}} $node->children) {
                $node->{is_clause_coord} = 1;
            }
        }

        foreach my $root_child ($root->children) {
            $clause_head_2_all_clause_nodes->{$root} = [];
            $saved_clause_head_2_all_clause_nodes->{$root} = [];
            collect_clause_nodes($root_child,$root);
        }

        foreach my $node ($root->descendants) {
            if ($clause_head_2_all_clause_nodes->{$node}) {
                my @clause_nodes = @{$clause_head_2_all_clause_nodes->{$node}};
                my @tokens = map {$_->attr('m/form')}
                    sort {$a->{ord}<=>$b->{ord}} map {PML_T::GetANodes($_)} @clause_nodes;
		my $length = length(join('',@tokens));
		my $div = int ($length/18); #($length > 3*15) ? 3 : ($length>2*15) ? 2 : 1;
		$node->{clause_string} = join(' ',@tokens);
		$node->{clause_string} =~ s/(.{18,}?)\s/$1\n/g;
# 		$node->{clause_string} = join "\n",
# 		  map {
# 		    my $c = int(@tokens/$div);
# 		    join " ", @tokens[($_-1)*int($c) .. ($_*$c) + ($_==$div ?  (@tokens % $div) : -1 ) ];
# 		  } 1..$div;
            }
        }
    }
}


1;

} # package

=item Changelog since 20081203

20081203: Automatic displaying a dialog for selecting a type of a newly created textual coreference has been re-introduced
20081217: Added an initial support for discourse arrows
20090106: Discourse arrows can be removed now
20090109: Calling switch_to_predefined_mode removed from the main body (remains in switch_context_hook)
20090109: Added functions dialog_edit_line and dialog_edit_text_area; used for editing discourse types and comments
20090111: A type of the discourse arrow is automatically displayed next to the t_lemma of the starting node
20090113: Displaying the type of the discourse arrow has been moved to the stylesheet PML_T_Discourse
          Displaying the comment has been implemented there as well
          The stylesheet PML_T_Discourse is used for discourse files
20090226: The discourse arrows starting at one node are displayed as one arrow that splits into several arrows
          Several nodes can be marked with "space" at once and a discourse arrow to all of them can be created
20090305: Falling back to displaying separate arrows if several arrows start at the same node; needs reconsidering and reprogramming
20090318: A display mode with collapsed nodes according to segmentation to clauses has been added by Petr Pajas and Zdenek Zabokrtsky
20090410: Removed functionality for editing bridging anaphora and extended textual coreference
          Some code moved to nondeprel_common.mac
20090421: Many functions moved to nondeprel_common.mac
20090426: Any node can be commented now.
20090521: Groups of nodes can be created and removed. Discourse arrows contain information about the groups if the start node and/or the
          target node are representative nodes of groups.
          Possible types of discourse arrows are taken from the schema now.
20090710: Groups can be clicked on and selected. Thus, discourse links can be created much more easily among them.
20090715: Attributes is_heading and is_list_entry can be easily changed and are graphically depicted (in the stylesheet).
20090813: Comments of discourse arrows can be set if there are multiple arrows at a node (bug fix).
          Types and comments of the discourse links are ordered according to the order of the target nodes.
20090825: Connectives can be set to arrows (set_remembered_connectives_to_actual_node).
20091208: Fixed a problem with "coap" nodes in collapsed mode.
20091214: The analytical tree can be displayed - the function PML_T->AnalyticalTree has been bound to Ctrl+A.
20091215: Analytical nodes can be remembered (by Ctrl+clicking on a word in the sentences) in order to be then set as connectives.
20100216: Ongoing transition to the new discourse schema.
20100219: First version working with the new discourse schema. Ctrl+l creates a discourse 'list' out of remebered nodes and groups.
20100614: An arrow can be reversed with a single click.
20100629: $grp->{FSFile}->trees replaced with macro GetTrees()
20120321: Support for adding and changing source of the arrows; the last entered value is used for subsequent newly created arrows as well.
20120410: Basic support for PDT 2.5 data.
20120728: References to connectors have been divided to two separate lists t-connectors.rf and a-connectors.rf, according to the layer of the connectors
20120801: Connectors references to a-layer are automatically changed to references to t-layer whenever possible during the setting of the connective.
20130301: Attribute is_secondary has been added to the discourse arrow and a possibility to switch it has been implemented
20130529: Attribute is_negated has been added to the discourse arrow and a possibility to switch it has been implemented
20130709: Attribute discourse_special introduced (replacing is_heading and some discourse_comment values)

But: Unable to keep this changelog entirely up-to-date...

=cut

