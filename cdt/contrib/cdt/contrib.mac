# -*- mode: cperl; encoding: utf-8 -*-

#ifndef cdt
#define cdt

{
package CDT;
BEGIN { import TredMacro; }

use utf8;
#binding-context CDT
#include <contrib/treex/Treex_mode.inc>

my $arrow_types = { discourse => [qw{AGENTIVE AGENTIVE:expl
                                         AGENTIVE:reas AGENTIVE:sbj TELIC
                                         TELIC:goal TELIC:cons.dir
                                         TELIC:cons.sbj CONST CONST:exem
                                         CONST:apart CONST:rest FORMAL
                                         FORMAL:descr FORMAL:eval CONC COND
                                         TIME TIME:cont TIME:pre TIME:post
                                         CONJ CONJ:add CONJ:elab CONJ:seq
                                         CONTR CONTR:dir CONTR:sbj DISJ
                                         DISJ:dir DISJ:sbj

                                         QUEST ANSW DIREC EXPR INTACT
                                         INTACT:start INTACT:attn INTACT:inter
                                         INTACT:stop CONSOL CONSOL:source
                                         CONSOL:inst CONSOL:motiv

                                         SCENE REP JOINT
                                      }],
                    curly => [qw{arg loc patient agent source other time const
                                 about quant goal apart poss form experiencer
                                 elab recipient func location class event eval
                                 cause resem iden formal pos
                            }],
                    square => [qw{subj dobj nobj expl mod pred man preds pobj
                                  iobj aobj other @loc quant lobj time possd
                                  cause loc iter vobj scene namef error err
                                  agent relr dir cond attr
                        }]
                  };


sub _init_curly_dialog {
    my $dialog = shift;
    my $numbersign = \$_[0];
    my $checkbutton = $dialog->Checkbutton(-text => 'Add #',
                                           -underline => 4,
                                           -variable => $numbersign,
                                          )->pack;
    $dialog->bind('<numbersign>',
                  [sub {$checkbutton->invoke}] );
}

sub _init_discourse_dialog {
    my $dialog = shift;
    my ($paragraph, $attribution, $connector, $explicit) = \(@_);
    my $frame = $dialog->Frame()->pack;
    my $checkbutton_para = $frame->Checkbutton(-text => '+ Paragraph',
                                               -underline => 2,
                                               -variable => \$paragraph,
                                              )->pack(-side => 'left');
    $dialog->bind('<Alt-p>',
                  [sub {$checkbutton_para->invoke}] );

    my $checkbutton_attrib = $frame->Checkbutton(-text => 'Attribution',
                                                 -underline => 5,
                                                 -variable => \$attribution,
                                                )->pack(-side => 'left');
    $dialog->bind('<Alt-b>',
                  [sub {$checkbutton_attrib->invoke}] );

    my $checkbutton_expl = $frame->Checkbutton(-text => 'Explicit',
                                               -underline => 1,
                                               -variable => \$explicit,
                                              )->pack(-side => 'left');
    $dialog->bind('<Alt-x>',
                  [sub {$checkbutton_expl->invoke}] );

    $frame = $dialog->Frame()->pack;
    $frame->Label(-text => 'Connector:',
                  -underline => 2)->pack(-side => 'left');
    my $entry_conn = $frame->Entry(-textvariable => $connector)
                                  ->pack(-side => 'left');
    $dialog->bind('<Alt-n>',
                  [sub {$entry_conn->focus}]);
}


sub create_arrow {
    my ($source, $target, $arrow_type) = @_;
    return if $source == $target; # no loops
    return unless exists $arrow_types->{$arrow_type};
    my $type;

    if ('square' eq $arrow_type) {
        $type = ListQuery('Select the [relation] type',
                          'browse',
                          $arrow_types->{square},
                          undef,
                         );
        return unless $type;
        $type = "[$arrow_types->{square}->[$type->[0]]]";

    } elsif ('curly' eq $arrow_type) {
        my $numbersign;
        $type = ListQuery('Select the {relation} type',
                          'browse',
                          $arrow_types->{curly},
                          undef,
                          { init => sub {
                                _init_curly_dialog(shift, $numbersign);
                            } } );
        return unless $type;
        $type = "{$arrow_types->{curly}->[$type->[0]]}";
        $type .= '#' if $numbersign;

    } elsif ('discourse' eq $arrow_type) {
        my ($paragraph, $attribution, $connector, $explicit);
        $type = ListQuery('Select the discourse relation type',
                'browse',
                $arrow_types->{discourse},
                undef,
                { init => sub {
                      _init_discourse_dialog(shift,
                                             $paragraph,
                                             $attribution,
                                             $connector,
                                             $explicit);
                  }});
        return unless $type;
        $type = "$arrow_types->{discourse}->[$type->[0]]";
        if ($connector) {
            $connector = "($connector)" unless $explicit;
            $connector = "/$connector";
        }
        $type = join q(), $paragraph ? '+' : q(),
                          $type,
                          $connector,
                          $attribution ? '/ATTR' : q();
    }

    ChangingFile(1);
    if ($source->is_aligned_to($target, qr{\Q$type})) {
        $source->delete_aligned_node($target, $type);
    } else {
        $source->add_aligned_node($target, $type);
    }
    TredMacro::Redraw();
}

sub node_release_hook {
    my ($node, $target, $mod) = @_;
    return $tredview->node_release_hook(@_) unless $mod;
    my @zones = map $_->get_zone, $node, $target;
    return 'stop' if $zones[0] != $zones[1];
    my $mods = {Control => 'discourse',
                Alt     => 'curly',
                Shift   => 'square'};
    create_arrow($node, $target, $mods->{$mod});
}

my $marked_for_arrow;
sub MarkForArrow {
    ChangingFile(0);
    $marked_for_arrow = $this;
}

sub DrawArrow {
    ChangingFile(0);
    return unless $marked_for_arrow;
    return if $this->language ne $marked_for_arrow->language;
    create_arrow($this, $marked_for_arrow, $_[0]);
}


Bind('MarkForArrow' => { key  => 'k',
                         menu => 'Mark for arrow'});
my %arrow_bindings = ('Ctrl+k' => 'discourse',
                      'Alt+k'  => 'curly',
                      K        => 'square');
for my $key (keys %arrow_bindings) {
    Bind(sub { DrawArrow($arrow_bindings{$key}) }
         => { key  => $key,
              menu => "Draw arrow type $arrow_bindings{$key}"});
}

my @deprels = qw{ nobj pnct subj vobj attr dobj pobj mod conj coord preds time
                  possd namef quant neg relr loc man other rel qobj @loc @dir
                  eval pobj.dobj add expl appa appr cause scene goal avobj
                  part robj iobj cond focal title prg aobj xpl name inst epi
                  accom lobj pobj.subj iter cons conc contr @time list
                  pobj.pobj exem resem elab relpa namel agent predo modp xtop
                  relelab correl tobj numm fpreds dir event discmark source
                  voc fpredo err gobj possr concom nobj.dobj aobj.dobj obl
                  gobj.dobj attrg numa aobj.subj mods gobj.subj const
                  pobj.iobj nobj.subj about ex modo rep poss degr ben pred
                  pobj.agent attr.possd att space qobj.subj nobj.pobj
                  nobj.iobj mcomp fpred error dobj.patient attr.iobj
            };

sub SetDeprel {
    ChangingFile(0);
    return unless $this->get_parent;
    my $old_deprel = $this->attr('conll/deprel');
    my $deprel = ListQuery('Select the relation type',
                           'browse',
                           [@deprels],
                           undef,
                          );
    return if ! $deprel or $deprel eq $old_deprel;
    $this->set_attr('conll/deprel', $deprels[ $deprel->[0] ]);
    ChangingFile(1);
    recompute_visualization();
}

Bind( \&SetDeprel => { key  => 'd',
                       menu => 'Set deprel'});

sub ToggleNumberSignAtDeprel {
    ChangingFile(0);
    my $deprel = $this->attr('conll/deprel');
    return unless $deprel;
    ($deprel .= '#') =~ s/##$//;
    $this->set_attr('conll/deprel', $deprel);
    ChangingFile(1);
    recompute_visualization();
}

Bind( \&ToggleNumberSignAtDeprel => { key => '#',
                                      menu => 'Toggle # in deprel'});


1;


}

#endif cdt
