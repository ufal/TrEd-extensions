# -*- perl -*- ############################################################# Otakar Smrz, 2004/08/02
#
# migrate_annotation_syntax.btred ####################################################### 2004/09/19

# $Id: migrate_annotation_syntax.btred 469 2008-01-18 00:16:02Z smrz $

our $VERSION = do { q $Revision: 469 $ =~ /(\d+)/; sprintf "%4.2f", $1 / 100 };


package TredMacro;

use Algorithm::Diff;


our @annotes = qw "afun afunaux arabclause arabfa arabspec comment parallel paren";
our @changes = qw "form lemma tag x_input";

our $mapping;

our $nodes;


sub autostart {

    my $anno = FSFile->create('encoding' => "utf8");

    $anno->readFile(FileName() . ".anno.fs");

    $nodes = [ [], [] ];

    $mapping = {};

    @{$nodes->[0]} = map { @{($grp->{FSFile}->nodes($_))[0]} } 0 .. $grp->{FSFile}->lastTreeNo;
    @{$nodes->[1]} = map { @{($anno->nodes($_))[0]} } 0 .. $anno->lastTreeNo;

    Algorithm::Diff::traverse_balanced(@{$nodes}, { 'MATCH' => \&record_mappings,
                                                    'CHANGE' => \&record_mappings }, \&node_ident);

    migrate_annotation();

    ChangingFile(1);
}


sub migrate_annotation {

    return unless keys %{$mapping};

    my ($parent, $i);

    for ($i = 0; $i < @{$nodes->[0]}; $i++) {

        if (exists $mapping->{$nodes->[0][$i]}) {

            foreach (@annotes) {

                next if $nodes->[0][$i]->{'afun'} eq 'AuxS' and $_ eq 'comment';

                $this = $nodes->[0][$i];

                warn "-> " . "\t" . myThisAddress() . "\t" . ( defined $this->{'afun'} ? $this->{'afun'} : '???' ) .
                     "\t" . $_ . "\t" . $this->{$_} . "\t" . $mapping->{$this}->{$_} . "\n"
                    if defined $this->{$_} and $this->{$_} ne $mapping->{$this}->{$_} and ( $_ ne 'afun' or $this->{'afun'} ne '???' );

                $nodes->[0][$i]->{$_} = $mapping->{$nodes->[0][$i]}->{$_};
            }

            foreach (@changes) {

                $this = $nodes->[0][$i];

                warn "<- " . "\t" . myThisAddress() . "\t" . ( defined $this->{'afun'} ? $this->{'afun'} : '???' ) .
                     "\t" . $_ . "\t" . $this->{$_} . "\t" . $mapping->{$this}->{$_} . "\n"
                    if defined $mapping->{$this}->{$_} and $this->{$_} ne $mapping->{$this}->{$_};
            }

            if (node_ident($nodes->[0][$i]) eq node_ident($mapping->{$nodes->[0][$i]})) {

                if ($parent = $mapping->{$nodes->[0][$i]}->parent() and exists $mapping->{$parent}) {

                    if (grep { $_ eq $mapping->{$parent} } $nodes->[0][$i]->descendants()) {

                        CutPaste($mapping->{$parent}, $nodes->[0][$i]->root());
                    }

                    CutPaste($nodes->[0][$i], $mapping->{$parent});
                }
                elsif ($nodes->[0][$i]->{'afun'} ne 'AuxS') {

                    $nodes->[0][$i]->{'afunaux'} = $nodes->[0][$i]->{'afun'};
                    $nodes->[0][$i]->{'afun'} = '???';

                    $this = $nodes->[0][$i];

                    warn ">< " . "\t" . myThisAddress() . "\t" . ( defined $this->{'afun'} ? $this->{'afun'} : '???' ) .
                         "\t" . '...' . "\t" . $this->{'x_morph'} . "\t" . $this->{'afunaux'} . "\n";
                }
            }
            else {

                if ($parent = $mapping->{$nodes->[0][$i]}->parent() and exists $mapping->{$parent}) {

                    if (grep { $_ eq $mapping->{$parent} } $nodes->[0][$i]->descendants()) {

                        CutPaste($mapping->{$parent}, $nodes->[0][$i]->root());
                    }

                    CutPaste($nodes->[0][$i], $mapping->{$parent});
                }

                $nodes->[0][$i]->{'afunaux'} = $nodes->[0][$i]->{'afun'};
                $nodes->[0][$i]->{'afun'} = '???';

                $this = $nodes->[0][$i];

                warn "<> " . "\t" . myThisAddress() . "\t" . ( defined $this->{'afun'} ? $this->{'afun'} : '???' ) .
                     "\t" . '...' . "\t" . $this->{'x_morph'} . "\t" . $this->{'afunaux'} . "\n";
            }
        }
        else {

            $this = $nodes->[0][$i];

            warn "-- " . "\t" . myThisAddress() . "\t" . ( defined $this->{'afun'} ? $this->{'afun'} : '???' ) .
                 "\t" . '...' . "\t" . $this->{'x_morph'} . "\t" . $this->{'afunaux'} . "\n";
        }
    }
}


sub record_mappings {

    $mapping->{$nodes->[0][$_[0]]} = $nodes->[1][$_[1]];
    $mapping->{$nodes->[1][$_[1]]} = $nodes->[0][$_[0]];
}


sub node_ident {

    return $_[0]->{'afun'} eq 'AuxS' ? '#root#' : $_[0]->{'origf'};
}


sub myThisAddress {

    my $tree = $this->root()->{'form'};

    my $file = ThisAddress();

    $file =~ s/(?<=\#)\#[^\#]+\.([^\.]+)$/$tree\.$1/;

    return $file;
}
